{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prefacio \u00b6 En esta asignatura del master vamos a ver una introducci\u00f3n al lenguaje de programaci\u00f3n Swift , que es uno de los dos \u00fanicos lenguajes soportados por Apple para el desarrollo de aplicaciones en iOS. Swift fue introducido en el 2015 con la idea de sustituir progresivamente al lenguaje usado en iOS hasta entonces, Objective-C. Adem\u00e1s del lenguaje de programaci\u00f3n veremos tambi\u00e9n una introducci\u00f3n a la plataforma iOS . Qu\u00e9 estructura tiene una aplicaci\u00f3n b\u00e1sica y qu\u00e9 patrones de dise\u00f1o siguen habitualmente las aplicaciones en iOS","title":"Prefacio"},{"location":"#prefacio","text":"En esta asignatura del master vamos a ver una introducci\u00f3n al lenguaje de programaci\u00f3n Swift , que es uno de los dos \u00fanicos lenguajes soportados por Apple para el desarrollo de aplicaciones en iOS. Swift fue introducido en el 2015 con la idea de sustituir progresivamente al lenguaje usado en iOS hasta entonces, Objective-C. Adem\u00e1s del lenguaje de programaci\u00f3n veremos tambi\u00e9n una introducci\u00f3n a la plataforma iOS . Qu\u00e9 estructura tiene una aplicaci\u00f3n b\u00e1sica y qu\u00e9 patrones de dise\u00f1o siguen habitualmente las aplicaciones en iOS","title":"Prefacio"},{"location":"SUMMARY/","text":"Contenidos \u00b6 Introducci\u00f3n a Swift Preliminares Variables y constantes Tipos de datos de la librer\u00eda est\u00e1ndar Colecciones Control de flujo Funciones Opcionales Clases Extensiones Enumerados Ejercicios Introducci\u00f3n a las aplicaciones iOS Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC Comenzando nuestra primera aplicaci\u00f3n iOS Estructura del c\u00f3digo de una aplicaci\u00f3n La plantilla creada por Xcode Creaci\u00f3n de la interfaz (la vista) Implementaci\u00f3n del modelo Implementaci\u00f3n del controlador Recibir eventos de la vista Llamar al modelo Modificar la vista Ejercicios M\u00e1s sobre Swift Clausuras Estructuras Gesti\u00f3n de errores Protocolos Delegaci\u00f3n Concurrencia b\u00e1sica en iOS APIs de concurrencia Colas de operaciones Ejercicios Comunicaci\u00f3n modelo-controlador Key-Value Observing Notificaciones locales Ejercicios Internacionalizaci\u00f3n de aplicaciones iOS A\u00f1adir soporte para i18n Localizar la interfaz gr\u00e1fica Localizar los mensajes en el c\u00f3digo Testing El navegador de tests Pruebas unitarias Miniproyecto: Juego de las siete y media El modelo Pruebas unitarias Interfaz gr\u00e1fico simplificado Completar la interfaz Posibles mejoras Ap\u00e9ndice: control de versiones con Xcode","title":"Contenidos"},{"location":"SUMMARY/#contenidos","text":"Introducci\u00f3n a Swift Preliminares Variables y constantes Tipos de datos de la librer\u00eda est\u00e1ndar Colecciones Control de flujo Funciones Opcionales Clases Extensiones Enumerados Ejercicios Introducci\u00f3n a las aplicaciones iOS Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC Comenzando nuestra primera aplicaci\u00f3n iOS Estructura del c\u00f3digo de una aplicaci\u00f3n La plantilla creada por Xcode Creaci\u00f3n de la interfaz (la vista) Implementaci\u00f3n del modelo Implementaci\u00f3n del controlador Recibir eventos de la vista Llamar al modelo Modificar la vista Ejercicios M\u00e1s sobre Swift Clausuras Estructuras Gesti\u00f3n de errores Protocolos Delegaci\u00f3n Concurrencia b\u00e1sica en iOS APIs de concurrencia Colas de operaciones Ejercicios Comunicaci\u00f3n modelo-controlador Key-Value Observing Notificaciones locales Ejercicios Internacionalizaci\u00f3n de aplicaciones iOS A\u00f1adir soporte para i18n Localizar la interfaz gr\u00e1fica Localizar los mensajes en el c\u00f3digo Testing El navegador de tests Pruebas unitarias Miniproyecto: Juego de las siete y media El modelo Pruebas unitarias Interfaz gr\u00e1fico simplificado Completar la interfaz Posibles mejoras Ap\u00e9ndice: control de versiones con Xcode","title":"Contenidos"},{"location":"apendices/control_versiones/","text":"Control de versiones con Xcode \u00b6 Crear un repositorio local para el proyecto \u00b6 En este apartado veremos c\u00f3mo trabajar con un repositorio git local . Tenemos dos opciones: crear el repositorio git local al crear el proyecto o a\u00f1adirlo con posterioridad. Para crear el repositorio git local al crear el proyecto : en la \u00faltima pantalla del asistente (la misma donde se selecciona en qu\u00e9 carpeta guardar f\u00edsicamente el proyecto) veremos una casilla de verificaci\u00f3n que podemos marcar para crear un repositorio Git local ( Create Git repository on my Mac ) Para crear el repositorio git local una vez creado el proyecto : en cualquier momento, vamos al men\u00fa de Source Control , opci\u00f3n Create git repositories... . Nos pedir\u00e1 que marquemos para qu\u00e9 proyectos de los que tenemos abiertos queremos crear un repositorio git. En los dos casos Xcode har\u00e1 autom\u00e1ticamente un commit inicial del proyecto con el mensaje \"initial commit\" (recordad que cuando Xcode crea un proyecto iOS no est\u00e1 vac\u00edo sino que tiene algunos archivos, dependiendo de la plantilla elegida). Podemos ver m\u00e1s informaci\u00f3n sobre el repositorio git con el Source Control Navigator , que es el segundo icono del panel de la izquierda de Xcode. Trabajar con un repositorio remoto \u00b6 Usaremos github en los ejemplos ya que es el servidor que empleamos en el curso, pero las instrucciones son pr\u00e1cticamente iguales para otros proveedores como Bitbucket o Gitlab. Configurar la cuenta de nuestro proveedor \u00b6 Lo m\u00e1s c\u00f3modo es guardar primero los datos de nuestra cuenta en Github, para no tener que introducirlos cada vez que hagamos una operaci\u00f3n con el repositorio remoto. Para ello nos vamos a las prerencias de Xcode (Men\u00fa Xcode > Preferences... , o bien pulsar la tecla Command-, - cmd y una coma) y en la barra de herramientas seleccionamos la opci\u00f3n Accounts Desde esta opci\u00f3n podemos gestionar nuestra cuenta de desarrollador de Apple y tambi\u00e9n cuentas de terceros como Github, Bitbucket, etc. En la esquina inferior izquierda pulsamos sobre el + para a\u00f1adir una cuenta, seleccionamos el tipo (en nuestro caso \"Github\") e introducimos usuario y contrase\u00f1a. Vincular con el repositorio remoto \u00b6 Repositorio remoto ya creado Si ya hemos creado el repositorio git remoto, solo necesitamos saber su URL. En Xcode, vamos al Source Control Navigator , (segundo icono del panel de la izquierda de Xcode), pulsamos con el bot\u00f3n derecho del rat\u00f3n y en el men\u00fa contextual seleccionamos Add Existing Remote... En el cuadro de di\u00e1logo que aparecer\u00e1 colocamos la URL del repositorio remoto en el campo Location Crear el repositorio remoto desde Xcode Esta opci\u00f3n solo est\u00e1 disponible desde la versi\u00f3n 10 de Xcode. En el Source Control Navigator , (segundo icono del panel de la izquierda de Xcode), pulsamos con el bot\u00f3n derecho del rat\u00f3n y en el men\u00fa contextual seleccionamos Create ( nombre del proyecto ) Remote... . En el cuadro de di\u00e1logo que aparecer\u00e1 podemos seleccionar la cuenta (en nuestro caso Github), el nombre que tendr\u00e1 el repositorio, si va a ser p\u00fablico o privado, etc... Xcode har\u00e1 un push autom\u00e1ticamente tras crear el repositorio remoto Trabajar con el control de versiones \u00b6 Cuando el proyecto actual est\u00e9 bajo el control de versiones ver\u00e1s que en el Project Navigator del panel de la izquierda (el modo por defecto de ver los archivos del proyecto) los archivos que se han a\u00f1adido desde el \u00faltimo commit tienen una A a la derecha y los modificados una M . Ten en cuenta que tras crear el proyecto, si has creado el repositorio local, Xcode hace autom\u00e1ticamente un commit inicial y por eso ning\u00fan archivo aparece inicialmente marcado con una A , solo lo ver\u00e1s cuando crees archivos nuevos o modifiques los de la plantilla. Las operaciones a realizar con el control de versiones est\u00e1n localizadas en el men\u00fa de Source Control . Las opciones m\u00e1s habituales son: commit : aparecer\u00e1 un cuadro de di\u00e1logo (bastante grande) con todos los archivos que han cambiado desde el \u00faltimo commit. Por defecto aparecer\u00e1n seleccionados todos pero puedes seleccionar solo los que te interesen. En la parte inferior del cuadro de di\u00e1logo tendr\u00e1s que escribir el mensaje asociado al commit . push : aparecer\u00e1 un peque\u00f1o cuadro de di\u00e1logo en el que puedes elegir el repositorio remoto al que subir los cambios. Normalmente solo tendremos un remoto vinculado, de modo que bastar\u00e1 con pulsar sobre Push pull : igual a lo anterior pero ser\u00e1 para traerse los cambios desde el repositorio remoto. Discard all changes : volver\u00e1 a la versi\u00f3n local que ten\u00edamos en el \u00faltimo commit .","title":"Ap\u00e9ndice. Control de versiones en Xcode"},{"location":"apendices/control_versiones/#control-de-versiones-con-xcode","text":"","title":"Control de versiones con Xcode"},{"location":"apendices/control_versiones/#crear-un-repositorio-local-para-el-proyecto","text":"En este apartado veremos c\u00f3mo trabajar con un repositorio git local . Tenemos dos opciones: crear el repositorio git local al crear el proyecto o a\u00f1adirlo con posterioridad. Para crear el repositorio git local al crear el proyecto : en la \u00faltima pantalla del asistente (la misma donde se selecciona en qu\u00e9 carpeta guardar f\u00edsicamente el proyecto) veremos una casilla de verificaci\u00f3n que podemos marcar para crear un repositorio Git local ( Create Git repository on my Mac ) Para crear el repositorio git local una vez creado el proyecto : en cualquier momento, vamos al men\u00fa de Source Control , opci\u00f3n Create git repositories... . Nos pedir\u00e1 que marquemos para qu\u00e9 proyectos de los que tenemos abiertos queremos crear un repositorio git. En los dos casos Xcode har\u00e1 autom\u00e1ticamente un commit inicial del proyecto con el mensaje \"initial commit\" (recordad que cuando Xcode crea un proyecto iOS no est\u00e1 vac\u00edo sino que tiene algunos archivos, dependiendo de la plantilla elegida). Podemos ver m\u00e1s informaci\u00f3n sobre el repositorio git con el Source Control Navigator , que es el segundo icono del panel de la izquierda de Xcode.","title":"Crear un repositorio local para el proyecto"},{"location":"apendices/control_versiones/#trabajar-con-un-repositorio-remoto","text":"Usaremos github en los ejemplos ya que es el servidor que empleamos en el curso, pero las instrucciones son pr\u00e1cticamente iguales para otros proveedores como Bitbucket o Gitlab.","title":"Trabajar con un repositorio remoto"},{"location":"apendices/control_versiones/#configurar-la-cuenta-de-nuestro-proveedor","text":"Lo m\u00e1s c\u00f3modo es guardar primero los datos de nuestra cuenta en Github, para no tener que introducirlos cada vez que hagamos una operaci\u00f3n con el repositorio remoto. Para ello nos vamos a las prerencias de Xcode (Men\u00fa Xcode > Preferences... , o bien pulsar la tecla Command-, - cmd y una coma) y en la barra de herramientas seleccionamos la opci\u00f3n Accounts Desde esta opci\u00f3n podemos gestionar nuestra cuenta de desarrollador de Apple y tambi\u00e9n cuentas de terceros como Github, Bitbucket, etc. En la esquina inferior izquierda pulsamos sobre el + para a\u00f1adir una cuenta, seleccionamos el tipo (en nuestro caso \"Github\") e introducimos usuario y contrase\u00f1a.","title":"Configurar la cuenta de nuestro proveedor"},{"location":"apendices/control_versiones/#vincular-con-el-repositorio-remoto","text":"","title":"Vincular con el repositorio remoto"},{"location":"apendices/control_versiones/#trabajar-con-el-control-de-versiones","text":"Cuando el proyecto actual est\u00e9 bajo el control de versiones ver\u00e1s que en el Project Navigator del panel de la izquierda (el modo por defecto de ver los archivos del proyecto) los archivos que se han a\u00f1adido desde el \u00faltimo commit tienen una A a la derecha y los modificados una M . Ten en cuenta que tras crear el proyecto, si has creado el repositorio local, Xcode hace autom\u00e1ticamente un commit inicial y por eso ning\u00fan archivo aparece inicialmente marcado con una A , solo lo ver\u00e1s cuando crees archivos nuevos o modifiques los de la plantilla. Las operaciones a realizar con el control de versiones est\u00e1n localizadas en el men\u00fa de Source Control . Las opciones m\u00e1s habituales son: commit : aparecer\u00e1 un cuadro de di\u00e1logo (bastante grande) con todos los archivos que han cambiado desde el \u00faltimo commit. Por defecto aparecer\u00e1n seleccionados todos pero puedes seleccionar solo los que te interesen. En la parte inferior del cuadro de di\u00e1logo tendr\u00e1s que escribir el mensaje asociado al commit . push : aparecer\u00e1 un peque\u00f1o cuadro de di\u00e1logo en el que puedes elegir el repositorio remoto al que subir los cambios. Normalmente solo tendremos un remoto vinculado, de modo que bastar\u00e1 con pulsar sobre Push pull : igual a lo anterior pero ser\u00e1 para traerse los cambios desde el repositorio remoto. Discard all changes : volver\u00e1 a la versi\u00f3n local que ten\u00edamos en el \u00faltimo commit .","title":"Trabajar con el control de versiones"},{"location":"miniproyecto/proyecto/","text":"MiniProyecto de iOS de Tecnolog\u00edas de Desarrollo \u00b6 Juego de las siete y media \u00b6 Se propone implementar el conocido juego de cartas de \"las 7 y media\". Pod\u00e9is implementar la versi\u00f3n \"completa\" en la que el usuario juega contra la m\u00e1quina, ambos sacando cartas una a una y decidiendo si plantarse o seguir, o bien una versi\u00f3n simplificada en la que la m\u00e1quina no pide cartas sino que obtiene una puntuaci\u00f3n generada al azar. Para crear el proyecto, como siempre elige la plantilla de single view app . En la segunda pantalla del asistente dale como nombre SieteyMedia y marca la casilla de Include Unit Tests (no obstante aunque no marques esta \u00faltima los test se pueden a\u00f1adir luego) Estructura de clases del modelo (1 punto) \u00b6 Ampliaremos el modelo que implementamos en la primera sesi\u00f3n. Ya tenemos el enum Palo y las clases Carta y Mano . Vamos a a\u00f1adir las clases necesarias para el juego: la Baraja y el propio Juego Clase Baraja \u00b6 todas las cartas de la baraja Propiedades: cartas , un array de Carta M\u00e9todos: El Inicializador debe rellenar el array de cartas con todas las cartas de la baraja repartirCarta : obtiene la \u00faltima carta de la baraja y la elimina de ella. Pod\u00e9is hacer esto por ejemplo con popLast() barajar : debe cambiar al azar el orden de las cartas en el Array . Una forma de implementar esto es extender la clase Array a\u00f1adiendo un m\u00e9todo para intercambiar al azar el orden de sus componentes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Foundation extension Array { /// Shuffle the elements of `self` in-place. mutating func barajar () { // empty and single-element collections don't shuffle if count < 2 { return } for i in indices . dropLast () { let diff = distance ( from : i , to : endIndex ) let j = index ( i , offsetBy : numericCast ( arc4random_uniform ( numericCast ( diff )))) swapAt ( i , j ) } } } Esta extensi\u00f3n est\u00e1 tomada de Stackoverflow . Pod\u00e9is usarla o bien cualquier otra implementaci\u00f3n que encontr\u00e9is. La extensi\u00f3n la pod\u00e9is almacenar en un fichero Swift cuyo nombre pod\u00e9is elegir libremente, no hay una convenci\u00f3n est\u00e1ndar. Clase Juego \u00b6 La estructura es libre ya que depende de vuestra implementaci\u00f3n. No obstante, tened en cuenta que vais a necesitar m\u00e9todos para: Sumar las cartas que hay en una mano, teniendo en cuenta que el 10,11 y 12 valen medio punto, y el resto su valor Que el jugador saque una carta Que el jugador se plante acabar el juego y calcular el resultado ... Pruebas unitarias (0,5 puntos) \u00b6 Si se te olvid\u00f3 marcar la casilla Include Unit Tests al crear el proyecto debes crear ahora un conjunto de pruebas yendo a File > New > Target... y de entre las plantillas disponibles, elegir iOS Unit Testing Bundle . Deb\u00e9is implementar al menos las siguientes pruebas unitarias: Que al inicializar una Carta con datos correctos tanto el palo como el valor se han guardado adecuadamente (por ejemplo que al inicializar una carta como el 3 de copas si despu\u00e9s obtenemos la propiedad valor nos da 3 y la propiedad palo nos da copas ). Que al inicializar una Carta con valores incorrectos devuelve nil (por ejemplo el -1 de bastos). Que cuando se reparte una carta de la Baraja se ha eliminado de ella y el n\u00famero de cartas de la baraja ha disminuido en 1 Para comprobar si un array contiene un elemento puedes usar contains . A este m\u00e9todo se le pasa una clausura a la que Swift a su vez va pasando uno a uno los elementos. Hay que devolver true si el elemento pasado cumple la condici\u00f3n deseada (en este caso ser igual a la carta buscada) y false en caso contrario. Algo como 1 2 3 4 5 6 7 8 9 10 let presente = baraja . cartas . contains () { elemento in if //el numero del elemento actual y el palo coinciden con los de la carta buscada { return true } else { return false ; } } //presente valdr\u00e1 true si alg\u00fan elemento del array ha cumplido la condici\u00f3n Interfaz gr\u00e1fico simplificado (0,5 puntos) \u00b6 El ViewController contendr\u00e1 una instancia de la clase Juego . Es normal que el ViewController tenga referencia del modelo. Pero no es aconsejable que tambi\u00e9n pase al rev\u00e9s. En el modelo no se deber\u00eda guardar ninguna referencia al controller , para poder reutilizarlo independientemente de la interfaz gr\u00e1fica. El controller puede enterarse de que ha pasado algo \"interesante\" (por ejemplo que se acaba el juego) a trav\u00e9s de notificaciones. O podr\u00eda observar con KVO cu\u00e1ndo cambia una propiedad del juego que sea el estado (turno usuario, turno m\u00e1quina, gana usuario, gana m\u00e1quina, ...). En esta versi\u00f3n muy simplificada de la interfaz solo aparecen en pantalla tres botones: \"pedir carta\", \"plantarse\" y \"nueva partida\", pero no se ven las cartas gr\u00e1ficamente. Eso s\u00ed, el juego deber\u00eda funcionar correctamente, imprimiendo los mensajes con print . En esta versi\u00f3n simplificada no es necesario habilitar/deshabilitar los botones seg\u00fan la situaci\u00f3n del juego (por ejemplo no hace falta deshabilitar \"pedir carta\" cuando la partida se ha terminado). No pasa nada si pulsar los botones de forma inconsistente da errores, ya que luego los deshabilitaremos. Adem\u00e1s, para simplificar la mec\u00e1nica del juego no es necesario que la m\u00e1quina \"saque cartas de verdad\". Basta con generar una puntuaci\u00f3n al azar e informar al usuario de la puntuaci\u00f3n que ha sacado. Para que el juego tenga sentido as\u00ed primero deber\u00eda jugar el jugador humano y luego la m\u00e1quina. La versi\u00f3n anterior es solo una idea, pod\u00e9is implementar cualquier variante que quer\u00e1is , o cualquier mejora, incluyendo que la m\u00e1quina saque cartas una por una, apostar una cantidad,... Completar la interfaz (1 punto) \u00b6 En la interfaz completada deber\u00edan aparecer las cartas en pantalla conforme se van repartiendo. Adem\u00e1s los botones se deber\u00edan habilitar/deshabilitar adecuadamente (por ejemplo si la partida se ha terminado no se puede pedir carta). C\u00f3mo dibujar las cartas \u00b6 Cada vez que dibujemos en pantalla una carta estamos a\u00f1adiendo a la pantalla actual un UIImageView . Tenemos que guardar referencias a todas las im\u00e1genes a\u00f1adidas para poder borrarlas cuando acabe la partida. Definiremos esta propiedad en el view controller para guardarlas 1 2 //propiedad de ViewController.swift var vistasCartas = [ UIView ]() En lugar de dibujar las cartas directamente en su posici\u00f3n, podemos hacerlo fuera de la pantalla (es decir, con el origen del frame en coordenadas negativas) y luego hacer una animaci\u00f3n hasta su posici\u00f3n definitiva. La siguiente funci\u00f3n dibuja una carta con el efecto descrito. La posicion es el orden de la carta, para que se vayan colocando una al lado de la otra: 1, 2... En el c\u00f3digo de ejemplo usamos un tama\u00f1o de carta fijo de 70x100 puntos, en el apartado siguiente se te propone adaptarlo al tama\u00f1o real de la pantalla. N\u00f3tese que hablamos de puntos y no de pixeles ya que en c\u00f3digo no se usa la resoluci\u00f3n f\u00edsica sino una resoluci\u00f3n \"l\u00f3gica\". Hay dispositivos que tienen distinta resoluci\u00f3n f\u00edsica pero usan la misma resoluci\u00f3n l\u00f3gica, lo que simplifica el desarrollo. Pod\u00e9is ver una tabla con resoluciones f\u00edsicas y l\u00f3gicas de distintos dispositivos iOS en http://iosres.com 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func dibujarCarta ( carta : Carta , enPosicion : Int ) { let nombreImagen = String ( carta . valor ) + String ( carta . palo . rawValue ) //creamos un objeto imagen let imagenCarta = UIImage ( named : nombreImagen ) //para que la imagen sea un componente m\u00e1s del UI, //la encapsulamos en un UIImageView let cartaView = UIImageView ( image : imagenCarta ) //Inicialmente la colocamos fuera de la pantalla y m\u00e1s grande //para que parezca m\u00e1s cercana //\"frame\" son los l\u00edmites de la vista, definen pos y tama\u00f1o cartaView . frame = CGRect ( x : - 200 , y : - 200 , width : 200 , height : 300 ) //La rotamos, para que al \"repartirla\" haga un efecto de giro cartaView . transform = CGAffineTransform ( rotationAngle : CGFloat ( Double . pi )); //La a\u00f1adimos a la vista principal, si no no ser\u00eda visible self . view . addSubview ( cartaView ) //guardamos la vista en el array, para luego poder eliminarla self . vistasCartas . append ( cartaView ) //Animaci\u00f3n de repartir carta UIView . animate ( withDuration : 0.5 ){ //\"efecto caida\": la llevamos a la posici\u00f3n final cartaView . frame = CGRect ( x : 50 + 70 * ( enPosicion - 1 ), y : 100 , width : 70 , height : 100 ); //0 como \u00e1ngulo \"destino\", para que rote mientras \"cae\" cartaView . transform = CGAffineTransform ( rotationAngle : 0 ); } } Eliminar las cartas de la pantalla \u00b6 Una vez ha terminado la partida, o justo cuando comienza la siguiente, hay que borrar todas las cartas de la pantalla. Vamos recorriendo el array self.vistasCartas del view controller y vamos eliminando las cartas de la pantalla: 1 2 3 4 5 6 //Quitamos las cartas de la pantalla for vistaCarta in self . vistasCartas { vistaCarta . removeFromSuperview () } //ya no tenemos im\u00e1genes de cartas en pantalla, ponemos el array a vac\u00edo self . vistasCartas =[] Adaptar los dibujos a la resoluci\u00f3n de la pantalla (0,5 puntos ADICIONALES) \u00b6 OPCIONALMENTE, en lugar de dibujar las cartas con un tama\u00f1o y unas posiciones \"fijas\", puedes usar un porcentaje o fracci\u00f3n del ancho y alto total de la pantalla. Puedes obtener el ancho y alto de la pantalla del siguiente modo: 1 2 3 let limitesPantalla = UIScreen . main . bounds let anchoPantalla = limitesPantalla . width let altoPantalla = limitesPantalla . height C\u00f3mo manipular los botones \u00b6 Pod\u00e9is habilitar/deshabilitar los botones por c\u00f3digo poniendo su propiedad isEnabled a true o false respectivamente. Para que un bot\u00f3n aparezca inicialmente deshabilitado, en el \"attributes inspector\" de la parte derecha de Xcode desmarcar la casilla enabled dentro de state (est\u00e1 a mitad de panel) Para que se vea gr\u00e1ficamente que un bot\u00f3n est\u00e1 deshabilitado pod\u00e9is ponerle un color distinto seg\u00fan el estado. Teniendo seleccionado el bot\u00f3n, en el Attributes inspector de la parte derecha de la pantalla, seleccionar el estado que nos interese en el desplegable. Al elegir colores ( text , shadow , ...) ser\u00e1n los fijados para ese estado. C\u00f3mo mostrar mensajes al usuario \u00b6 Pod\u00e9is mostrar el resultado del juego (\"has ganado\", \"te has pasado\",...) con un UIAlertController , que har\u00e1 aparecer el t\u00edpico cuadro de di\u00e1logo modal. El siguiente c\u00f3digo muestra un cuadro que pone \"\u00a1\u00a1Has perdido!!\", con el t\u00edtulo \"Fin del juego\", y con un \u00fanico bot\u00f3n de \"OK\" que no hace nada especial, m\u00e1s que quitar el cuadro de di\u00e1logo. 1 2 3 4 5 6 7 8 9 let alert = UIAlertController ( title : \"Fin del juego\" , message : \"\u00a1\u00a1Has perdido!!\" , preferredStyle : UIAlertControllerStyle . alert ) let action = UIAlertAction ( title : \"OK\" , style : UIAlertActionStyle . default ) alert . addAction ( action ) self . present ( alert , animated : true , completion : nil ) Posibles mejoras (hasta 1 punto) \u00b6 El proyecto est\u00e1 abierto a cualquier posible mejora o modificaci\u00f3n que quer\u00e1is hacer, por ejemplo: Contabilizar y mostrar las partidas ganadas/perdidas (0,25) Que se pueda apostar una cantidad y vaya contabilizando la cantidad hasta el momento (0,5) Que la m\u00e1quina tambi\u00e9n vaya sacando cartas (1) ...","title":"Miniproyecto. Juego de las siete y media"},{"location":"miniproyecto/proyecto/#miniproyecto-de-ios-de-tecnologias-de-desarrollo","text":"","title":"MiniProyecto de iOS de Tecnolog\u00edas de Desarrollo"},{"location":"miniproyecto/proyecto/#juego-de-las-siete-y-media","text":"Se propone implementar el conocido juego de cartas de \"las 7 y media\". Pod\u00e9is implementar la versi\u00f3n \"completa\" en la que el usuario juega contra la m\u00e1quina, ambos sacando cartas una a una y decidiendo si plantarse o seguir, o bien una versi\u00f3n simplificada en la que la m\u00e1quina no pide cartas sino que obtiene una puntuaci\u00f3n generada al azar. Para crear el proyecto, como siempre elige la plantilla de single view app . En la segunda pantalla del asistente dale como nombre SieteyMedia y marca la casilla de Include Unit Tests (no obstante aunque no marques esta \u00faltima los test se pueden a\u00f1adir luego)","title":"Juego de las siete y media"},{"location":"miniproyecto/proyecto/#estructura-de-clases-del-modelo-1-punto","text":"Ampliaremos el modelo que implementamos en la primera sesi\u00f3n. Ya tenemos el enum Palo y las clases Carta y Mano . Vamos a a\u00f1adir las clases necesarias para el juego: la Baraja y el propio Juego","title":"Estructura de clases del modelo (1 punto)"},{"location":"miniproyecto/proyecto/#clase-baraja","text":"todas las cartas de la baraja Propiedades: cartas , un array de Carta M\u00e9todos: El Inicializador debe rellenar el array de cartas con todas las cartas de la baraja repartirCarta : obtiene la \u00faltima carta de la baraja y la elimina de ella. Pod\u00e9is hacer esto por ejemplo con popLast() barajar : debe cambiar al azar el orden de las cartas en el Array . Una forma de implementar esto es extender la clase Array a\u00f1adiendo un m\u00e9todo para intercambiar al azar el orden de sus componentes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Foundation extension Array { /// Shuffle the elements of `self` in-place. mutating func barajar () { // empty and single-element collections don't shuffle if count < 2 { return } for i in indices . dropLast () { let diff = distance ( from : i , to : endIndex ) let j = index ( i , offsetBy : numericCast ( arc4random_uniform ( numericCast ( diff )))) swapAt ( i , j ) } } } Esta extensi\u00f3n est\u00e1 tomada de Stackoverflow . Pod\u00e9is usarla o bien cualquier otra implementaci\u00f3n que encontr\u00e9is. La extensi\u00f3n la pod\u00e9is almacenar en un fichero Swift cuyo nombre pod\u00e9is elegir libremente, no hay una convenci\u00f3n est\u00e1ndar.","title":"Clase Baraja"},{"location":"miniproyecto/proyecto/#clase-juego","text":"La estructura es libre ya que depende de vuestra implementaci\u00f3n. No obstante, tened en cuenta que vais a necesitar m\u00e9todos para: Sumar las cartas que hay en una mano, teniendo en cuenta que el 10,11 y 12 valen medio punto, y el resto su valor Que el jugador saque una carta Que el jugador se plante acabar el juego y calcular el resultado ...","title":"Clase Juego"},{"location":"miniproyecto/proyecto/#pruebas-unitarias-05-puntos","text":"Si se te olvid\u00f3 marcar la casilla Include Unit Tests al crear el proyecto debes crear ahora un conjunto de pruebas yendo a File > New > Target... y de entre las plantillas disponibles, elegir iOS Unit Testing Bundle . Deb\u00e9is implementar al menos las siguientes pruebas unitarias: Que al inicializar una Carta con datos correctos tanto el palo como el valor se han guardado adecuadamente (por ejemplo que al inicializar una carta como el 3 de copas si despu\u00e9s obtenemos la propiedad valor nos da 3 y la propiedad palo nos da copas ). Que al inicializar una Carta con valores incorrectos devuelve nil (por ejemplo el -1 de bastos). Que cuando se reparte una carta de la Baraja se ha eliminado de ella y el n\u00famero de cartas de la baraja ha disminuido en 1 Para comprobar si un array contiene un elemento puedes usar contains . A este m\u00e9todo se le pasa una clausura a la que Swift a su vez va pasando uno a uno los elementos. Hay que devolver true si el elemento pasado cumple la condici\u00f3n deseada (en este caso ser igual a la carta buscada) y false en caso contrario. Algo como 1 2 3 4 5 6 7 8 9 10 let presente = baraja . cartas . contains () { elemento in if //el numero del elemento actual y el palo coinciden con los de la carta buscada { return true } else { return false ; } } //presente valdr\u00e1 true si alg\u00fan elemento del array ha cumplido la condici\u00f3n","title":"Pruebas unitarias (0,5 puntos)"},{"location":"miniproyecto/proyecto/#interfaz-grafico-simplificado-05-puntos","text":"El ViewController contendr\u00e1 una instancia de la clase Juego . Es normal que el ViewController tenga referencia del modelo. Pero no es aconsejable que tambi\u00e9n pase al rev\u00e9s. En el modelo no se deber\u00eda guardar ninguna referencia al controller , para poder reutilizarlo independientemente de la interfaz gr\u00e1fica. El controller puede enterarse de que ha pasado algo \"interesante\" (por ejemplo que se acaba el juego) a trav\u00e9s de notificaciones. O podr\u00eda observar con KVO cu\u00e1ndo cambia una propiedad del juego que sea el estado (turno usuario, turno m\u00e1quina, gana usuario, gana m\u00e1quina, ...). En esta versi\u00f3n muy simplificada de la interfaz solo aparecen en pantalla tres botones: \"pedir carta\", \"plantarse\" y \"nueva partida\", pero no se ven las cartas gr\u00e1ficamente. Eso s\u00ed, el juego deber\u00eda funcionar correctamente, imprimiendo los mensajes con print . En esta versi\u00f3n simplificada no es necesario habilitar/deshabilitar los botones seg\u00fan la situaci\u00f3n del juego (por ejemplo no hace falta deshabilitar \"pedir carta\" cuando la partida se ha terminado). No pasa nada si pulsar los botones de forma inconsistente da errores, ya que luego los deshabilitaremos. Adem\u00e1s, para simplificar la mec\u00e1nica del juego no es necesario que la m\u00e1quina \"saque cartas de verdad\". Basta con generar una puntuaci\u00f3n al azar e informar al usuario de la puntuaci\u00f3n que ha sacado. Para que el juego tenga sentido as\u00ed primero deber\u00eda jugar el jugador humano y luego la m\u00e1quina. La versi\u00f3n anterior es solo una idea, pod\u00e9is implementar cualquier variante que quer\u00e1is , o cualquier mejora, incluyendo que la m\u00e1quina saque cartas una por una, apostar una cantidad,...","title":"Interfaz gr\u00e1fico simplificado (0,5 puntos)"},{"location":"miniproyecto/proyecto/#completar-la-interfaz-1-punto","text":"En la interfaz completada deber\u00edan aparecer las cartas en pantalla conforme se van repartiendo. Adem\u00e1s los botones se deber\u00edan habilitar/deshabilitar adecuadamente (por ejemplo si la partida se ha terminado no se puede pedir carta).","title":"Completar la interfaz (1 punto)"},{"location":"miniproyecto/proyecto/#como-dibujar-las-cartas","text":"Cada vez que dibujemos en pantalla una carta estamos a\u00f1adiendo a la pantalla actual un UIImageView . Tenemos que guardar referencias a todas las im\u00e1genes a\u00f1adidas para poder borrarlas cuando acabe la partida. Definiremos esta propiedad en el view controller para guardarlas 1 2 //propiedad de ViewController.swift var vistasCartas = [ UIView ]() En lugar de dibujar las cartas directamente en su posici\u00f3n, podemos hacerlo fuera de la pantalla (es decir, con el origen del frame en coordenadas negativas) y luego hacer una animaci\u00f3n hasta su posici\u00f3n definitiva. La siguiente funci\u00f3n dibuja una carta con el efecto descrito. La posicion es el orden de la carta, para que se vayan colocando una al lado de la otra: 1, 2... En el c\u00f3digo de ejemplo usamos un tama\u00f1o de carta fijo de 70x100 puntos, en el apartado siguiente se te propone adaptarlo al tama\u00f1o real de la pantalla. N\u00f3tese que hablamos de puntos y no de pixeles ya que en c\u00f3digo no se usa la resoluci\u00f3n f\u00edsica sino una resoluci\u00f3n \"l\u00f3gica\". Hay dispositivos que tienen distinta resoluci\u00f3n f\u00edsica pero usan la misma resoluci\u00f3n l\u00f3gica, lo que simplifica el desarrollo. Pod\u00e9is ver una tabla con resoluciones f\u00edsicas y l\u00f3gicas de distintos dispositivos iOS en http://iosres.com 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func dibujarCarta ( carta : Carta , enPosicion : Int ) { let nombreImagen = String ( carta . valor ) + String ( carta . palo . rawValue ) //creamos un objeto imagen let imagenCarta = UIImage ( named : nombreImagen ) //para que la imagen sea un componente m\u00e1s del UI, //la encapsulamos en un UIImageView let cartaView = UIImageView ( image : imagenCarta ) //Inicialmente la colocamos fuera de la pantalla y m\u00e1s grande //para que parezca m\u00e1s cercana //\"frame\" son los l\u00edmites de la vista, definen pos y tama\u00f1o cartaView . frame = CGRect ( x : - 200 , y : - 200 , width : 200 , height : 300 ) //La rotamos, para que al \"repartirla\" haga un efecto de giro cartaView . transform = CGAffineTransform ( rotationAngle : CGFloat ( Double . pi )); //La a\u00f1adimos a la vista principal, si no no ser\u00eda visible self . view . addSubview ( cartaView ) //guardamos la vista en el array, para luego poder eliminarla self . vistasCartas . append ( cartaView ) //Animaci\u00f3n de repartir carta UIView . animate ( withDuration : 0.5 ){ //\"efecto caida\": la llevamos a la posici\u00f3n final cartaView . frame = CGRect ( x : 50 + 70 * ( enPosicion - 1 ), y : 100 , width : 70 , height : 100 ); //0 como \u00e1ngulo \"destino\", para que rote mientras \"cae\" cartaView . transform = CGAffineTransform ( rotationAngle : 0 ); } }","title":"C\u00f3mo dibujar las cartas"},{"location":"miniproyecto/proyecto/#eliminar-las-cartas-de-la-pantalla","text":"Una vez ha terminado la partida, o justo cuando comienza la siguiente, hay que borrar todas las cartas de la pantalla. Vamos recorriendo el array self.vistasCartas del view controller y vamos eliminando las cartas de la pantalla: 1 2 3 4 5 6 //Quitamos las cartas de la pantalla for vistaCarta in self . vistasCartas { vistaCarta . removeFromSuperview () } //ya no tenemos im\u00e1genes de cartas en pantalla, ponemos el array a vac\u00edo self . vistasCartas =[]","title":"Eliminar las cartas de la pantalla"},{"location":"miniproyecto/proyecto/#adaptar-los-dibujos-a-la-resolucion-de-la-pantalla-05-puntos-adicionales","text":"OPCIONALMENTE, en lugar de dibujar las cartas con un tama\u00f1o y unas posiciones \"fijas\", puedes usar un porcentaje o fracci\u00f3n del ancho y alto total de la pantalla. Puedes obtener el ancho y alto de la pantalla del siguiente modo: 1 2 3 let limitesPantalla = UIScreen . main . bounds let anchoPantalla = limitesPantalla . width let altoPantalla = limitesPantalla . height","title":"Adaptar los dibujos a la resoluci\u00f3n de la pantalla (0,5 puntos ADICIONALES)"},{"location":"miniproyecto/proyecto/#como-manipular-los-botones","text":"Pod\u00e9is habilitar/deshabilitar los botones por c\u00f3digo poniendo su propiedad isEnabled a true o false respectivamente. Para que un bot\u00f3n aparezca inicialmente deshabilitado, en el \"attributes inspector\" de la parte derecha de Xcode desmarcar la casilla enabled dentro de state (est\u00e1 a mitad de panel) Para que se vea gr\u00e1ficamente que un bot\u00f3n est\u00e1 deshabilitado pod\u00e9is ponerle un color distinto seg\u00fan el estado. Teniendo seleccionado el bot\u00f3n, en el Attributes inspector de la parte derecha de la pantalla, seleccionar el estado que nos interese en el desplegable. Al elegir colores ( text , shadow , ...) ser\u00e1n los fijados para ese estado.","title":"C\u00f3mo manipular los botones"},{"location":"miniproyecto/proyecto/#como-mostrar-mensajes-al-usuario","text":"Pod\u00e9is mostrar el resultado del juego (\"has ganado\", \"te has pasado\",...) con un UIAlertController , que har\u00e1 aparecer el t\u00edpico cuadro de di\u00e1logo modal. El siguiente c\u00f3digo muestra un cuadro que pone \"\u00a1\u00a1Has perdido!!\", con el t\u00edtulo \"Fin del juego\", y con un \u00fanico bot\u00f3n de \"OK\" que no hace nada especial, m\u00e1s que quitar el cuadro de di\u00e1logo. 1 2 3 4 5 6 7 8 9 let alert = UIAlertController ( title : \"Fin del juego\" , message : \"\u00a1\u00a1Has perdido!!\" , preferredStyle : UIAlertControllerStyle . alert ) let action = UIAlertAction ( title : \"OK\" , style : UIAlertActionStyle . default ) alert . addAction ( action ) self . present ( alert , animated : true , completion : nil )","title":"C\u00f3mo mostrar mensajes al usuario"},{"location":"miniproyecto/proyecto/#posibles-mejoras-hasta-1-punto","text":"El proyecto est\u00e1 abierto a cualquier posible mejora o modificaci\u00f3n que quer\u00e1is hacer, por ejemplo: Contabilizar y mostrar las partidas ganadas/perdidas (0,25) Que se pueda apostar una cantidad y vaya contabilizando la cantidad hasta el momento (0,5) Que la m\u00e1quina tambi\u00e9n vaya sacando cartas (1) ...","title":"Posibles mejoras (hasta 1 punto)"},{"location":"s1/ejercicios/","text":"Ejercicios de Swift B\u00e1sico \u00b6 Miniproyecto: Juego de las Siete y Media, parte I (1,5 puntos) \u00b6 En esta sesi\u00f3n vamos a implementar el modelo para un juego cartas de las siete y media, que terminaremos en las \u00faltimas sesiones de la asignatura. Por el momento no vamos a tener interfaz, solo la l\u00f3gica m\u00e1s b\u00e1sica y las estructuras de datos. A continuaci\u00f3n se da la lista de clases y enums a crear. Deb\u00e9is respetar lo m\u00e1ximo posible los nombres de propiedades y m\u00e9todos NOTA: el ejercicio est\u00e1 pensado para las cartas de la baraja espa\u00f1ola . Para los que no la conozc\u00e1is: hay 4 \"palos\" (bastos, copas, espadas y oros) y de cada palo hay 10 cartas, que son del 1 al 7 y del 10 al 12, ya que el 8 y 9 no se usan. El 1 se llama \"as\" igual que en la baraja francesa, el 10 es la sota (en la baraja francesa/inglesa es la J), el es 11 el caballo (Q o dama en la inglesa) y el 12 el rey . Enumerado Palo (0,25 puntos) \u00b6 Un enum para representar los cuatro palos de la baraja. Haz que sea internamente un String ( : String ), as\u00ed su propiedad .rawValue ser\u00e1 una cadena y podr\u00e1s mostrar el nombre del palo clase Carta (0,5 puntos) \u00b6 Propiedades: valor entero y palo , de tipo Palo M\u00e9todos Inicializador: se le pasa un valor y un palo. Podr\u00eda fallar si el valor que se le pasa no es correcto. Esto es lo que se llama en Swift un failable initializer , que devuelve un opcional, ya que podr\u00eda ser nil . Para definirlo, poner init? en lugar de init y en caso de error devolver nil (si no hay error no es necesario devolver nada). Recordad que el 8 y el 9 no se usan y que evidentemente no valen cartas menores que 1 ni mayores que 12. descripcion : devuelve un String con el nombre de la carta: el 1 de oros , el 10 de bastos ,... Clase Mano (0,75 puntos) \u00b6 un conjunto de cartas Propiedades almacenadas: cartas , un array de Carta Propiedades computadas: tama\u00f1o , la longitud del array (su propiedad count ) M\u00e9todos: El inicializador de la clase debe inicializar cartas como un array vac\u00edo (tambi\u00e9n lo pod\u00e9is hacer al definir la propiedad) addCarta : se le pasa una carta y la a\u00f1ade a la mano getCarta : se le pasa una posici\u00f3n (empezando por 0) y devuelve la carta como un opcional. Si es menor que 0 o mayor o igual que el tama\u00f1o, deber\u00eda devolver nil Programa principal \u00b6 Como \"programa principal\" para probar las clases anteriores puedes ejecutar este c\u00f3digo 1 2 3 4 5 6 7 8 9 10 var mano = Mano () mano . addCarta ( Carta ( 1 , . oros ) ! ) mano . addCarta ( Carta ( 10 , . espadas ) ! ) mano . addCarta ( Carta ( 7 , . copas ) ! ) print ( \"Hay \\( mano . tama\u00f1o ) cartas\" ) for num in 0. .< mano . tama\u00f1o { if let carta = mano . getCarta ( pos : num ) { print ( carta . descripcion ()) } } Si todo es correcto deber\u00edan aparecer en pantalla las tres cartas a\u00f1adidas a la mano. Anexo: opciones para escribir y probar el c\u00f3digo de este ejercicio \u00b6 Opci\u00f3n 1 : con el compilador de Swift en l\u00ednea de comandos: Usando el editor de texto que prefieras, escribe el c\u00f3digo del enumerado Palo las clases Carta , Baraja y Mano y la extensi\u00f3n de Array . Puedes guardar por ejemplo cada clase en un archivo .swift distinto, aunque en Swift no hay reglas sobre qu\u00e9 clases debe contener cada archivo Guarda el programa principal en un archivo main.swift Para compilar, abre una terminal, ve al directorio donde est\u00e9n los archivos y escribe swiftc *.swift . Esto compilar\u00e1 todos los archivos Swift y generar\u00e1 un ejecutable main Puedes ejecutar el programa escribiendo en la terminal ./main Opci\u00f3n 2 : en un playground de Xcode: Abre el programa Xcode, y crea un nuevo playground con File > New >Playground . Escribe aqu\u00ed el c\u00f3digo de todas las clases juntas, y tambi\u00e9n del programa principal. Como ir\u00e1s viendo, el playground se est\u00e1 compilando y ejecutando constantemente a medida que vas escribiendo c\u00f3digo, pero si quieres forzar la ejecuci\u00f3n puedes ir a Editor > Execute playground . Lo puedes usar una vez terminado todo, para ejecutar varias veces el programa principal. Opci\u00f3n 3 : en alg\u00fan entorno online de programaci\u00f3n en Swift, como por ejemplo en Repl.it . Esto te puede ser \u00fatil si no tienes un Mac disponible o no puedes instalar el compilador en l\u00ednea de comandos en tu sistema. Eso s\u00ed, tendr\u00e1s que escribir todo el c\u00f3digo junto al igual que lo haces en un playground NOTA: estas alternativas las podemos usar porque de momento todav\u00eda no estamos haciendo aplicaciones con interfaz de usuario. A partir de la siguiente sesi\u00f3n s\u00ed haremos aplicaciones iOS con lo que nuestra \u00fanica posibilidad va a ser trabajar en un Mac con un entorno tipo Xcode.","title":"Ejercicios"},{"location":"s1/ejercicios/#ejercicios-de-swift-basico","text":"","title":"Ejercicios de Swift B\u00e1sico"},{"location":"s1/ejercicios/#miniproyecto-juego-de-las-siete-y-media-parte-i-15-puntos","text":"En esta sesi\u00f3n vamos a implementar el modelo para un juego cartas de las siete y media, que terminaremos en las \u00faltimas sesiones de la asignatura. Por el momento no vamos a tener interfaz, solo la l\u00f3gica m\u00e1s b\u00e1sica y las estructuras de datos. A continuaci\u00f3n se da la lista de clases y enums a crear. Deb\u00e9is respetar lo m\u00e1ximo posible los nombres de propiedades y m\u00e9todos NOTA: el ejercicio est\u00e1 pensado para las cartas de la baraja espa\u00f1ola . Para los que no la conozc\u00e1is: hay 4 \"palos\" (bastos, copas, espadas y oros) y de cada palo hay 10 cartas, que son del 1 al 7 y del 10 al 12, ya que el 8 y 9 no se usan. El 1 se llama \"as\" igual que en la baraja francesa, el 10 es la sota (en la baraja francesa/inglesa es la J), el es 11 el caballo (Q o dama en la inglesa) y el 12 el rey .","title":"Miniproyecto: Juego de las Siete y Media, parte I (1,5 puntos)"},{"location":"s1/ejercicios/#enumerado-palo-025-puntos","text":"Un enum para representar los cuatro palos de la baraja. Haz que sea internamente un String ( : String ), as\u00ed su propiedad .rawValue ser\u00e1 una cadena y podr\u00e1s mostrar el nombre del palo","title":"Enumerado Palo (0,25 puntos)"},{"location":"s1/ejercicios/#clase-carta-05-puntos","text":"Propiedades: valor entero y palo , de tipo Palo M\u00e9todos Inicializador: se le pasa un valor y un palo. Podr\u00eda fallar si el valor que se le pasa no es correcto. Esto es lo que se llama en Swift un failable initializer , que devuelve un opcional, ya que podr\u00eda ser nil . Para definirlo, poner init? en lugar de init y en caso de error devolver nil (si no hay error no es necesario devolver nada). Recordad que el 8 y el 9 no se usan y que evidentemente no valen cartas menores que 1 ni mayores que 12. descripcion : devuelve un String con el nombre de la carta: el 1 de oros , el 10 de bastos ,...","title":"clase Carta (0,5 puntos)"},{"location":"s1/ejercicios/#clase-mano-075-puntos","text":"un conjunto de cartas Propiedades almacenadas: cartas , un array de Carta Propiedades computadas: tama\u00f1o , la longitud del array (su propiedad count ) M\u00e9todos: El inicializador de la clase debe inicializar cartas como un array vac\u00edo (tambi\u00e9n lo pod\u00e9is hacer al definir la propiedad) addCarta : se le pasa una carta y la a\u00f1ade a la mano getCarta : se le pasa una posici\u00f3n (empezando por 0) y devuelve la carta como un opcional. Si es menor que 0 o mayor o igual que el tama\u00f1o, deber\u00eda devolver nil","title":"Clase Mano (0,75 puntos)"},{"location":"s1/ejercicios/#programa-principal","text":"Como \"programa principal\" para probar las clases anteriores puedes ejecutar este c\u00f3digo 1 2 3 4 5 6 7 8 9 10 var mano = Mano () mano . addCarta ( Carta ( 1 , . oros ) ! ) mano . addCarta ( Carta ( 10 , . espadas ) ! ) mano . addCarta ( Carta ( 7 , . copas ) ! ) print ( \"Hay \\( mano . tama\u00f1o ) cartas\" ) for num in 0. .< mano . tama\u00f1o { if let carta = mano . getCarta ( pos : num ) { print ( carta . descripcion ()) } } Si todo es correcto deber\u00edan aparecer en pantalla las tres cartas a\u00f1adidas a la mano.","title":"Programa principal"},{"location":"s1/ejercicios/#anexo-opciones-para-escribir-y-probar-el-codigo-de-este-ejercicio","text":"Opci\u00f3n 1 : con el compilador de Swift en l\u00ednea de comandos: Usando el editor de texto que prefieras, escribe el c\u00f3digo del enumerado Palo las clases Carta , Baraja y Mano y la extensi\u00f3n de Array . Puedes guardar por ejemplo cada clase en un archivo .swift distinto, aunque en Swift no hay reglas sobre qu\u00e9 clases debe contener cada archivo Guarda el programa principal en un archivo main.swift Para compilar, abre una terminal, ve al directorio donde est\u00e9n los archivos y escribe swiftc *.swift . Esto compilar\u00e1 todos los archivos Swift y generar\u00e1 un ejecutable main Puedes ejecutar el programa escribiendo en la terminal ./main Opci\u00f3n 2 : en un playground de Xcode: Abre el programa Xcode, y crea un nuevo playground con File > New >Playground . Escribe aqu\u00ed el c\u00f3digo de todas las clases juntas, y tambi\u00e9n del programa principal. Como ir\u00e1s viendo, el playground se est\u00e1 compilando y ejecutando constantemente a medida que vas escribiendo c\u00f3digo, pero si quieres forzar la ejecuci\u00f3n puedes ir a Editor > Execute playground . Lo puedes usar una vez terminado todo, para ejecutar varias veces el programa principal. Opci\u00f3n 3 : en alg\u00fan entorno online de programaci\u00f3n en Swift, como por ejemplo en Repl.it . Esto te puede ser \u00fatil si no tienes un Mac disponible o no puedes instalar el compilador en l\u00ednea de comandos en tu sistema. Eso s\u00ed, tendr\u00e1s que escribir todo el c\u00f3digo junto al igual que lo haces en un playground NOTA: estas alternativas las podemos usar porque de momento todav\u00eda no estamos haciendo aplicaciones con interfaz de usuario. A partir de la siguiente sesi\u00f3n s\u00ed haremos aplicaciones iOS con lo que nuestra \u00fanica posibilidad va a ser trabajar en un Mac con un entorno tipo Xcode.","title":"Anexo: opciones para escribir y probar el c\u00f3digo de este ejercicio"},{"location":"s1/intro/","text":"En este cap\u00edtulo vamos a ver una introducci\u00f3n a las caracter\u00edsticas m\u00e1s b\u00e1sicas del lenguaje Swift.","title":"Intro"},{"location":"s1/swift_basico/","text":"Introducci\u00f3n b\u00e1sica a Swift \u00b6 Swift es un lenguaje originalmente desarrollado por Apple para la programaci\u00f3n de aplicaciones en las plataformas iOS y OSX. Pese a haber sido desarrollado con esta intenci\u00f3n, Swift es un lenguaje de prop\u00f3sito general. Es un lenguaje bastante completo y con muchas funcionalidades, pero tambi\u00e9n pensado para que las funcionalidades b\u00e1sicas sean sencillas de usar. Como muchos lenguajes modernos incluye no solo caracter\u00edsticas de programaci\u00f3n orientada a objetos sino tambi\u00e9n de programaci\u00f3n funcional. Preliminares \u00b6 En un programa Swift no hay un \"main\" como en C sino que el c\u00f3digo se empieza a ejecutar por la primera instrucci\u00f3n de \"nivel superior\", es decir las sentencias que no est\u00e1n dentro de funciones. Los \";\" al final de las sentencias son opcionales. Variables y constantes \u00b6 Swift tiene una serie de tipos b\u00e1sicos : Int , Double , Float , Bool Las variables se definen con var y las constantes con let . Si inicializamos su valor no es necesario especificar el tipo, ya que el compilador de Swift lo induce a partir del valor inicial. 1 2 3 4 5 6 7 8 9 var i = 1 //i es un Int var d = 1.5 //d es un Double //Tambi\u00e9n podemos declarar el tipo, si no la inicializamos var f : Float f = 1.5 //O incluso declarar e inicializar var f2 : Float = 1.5 type(of:) nos devuelve el tipo 1 2 3 var i = 1 print ( type ( of : i )) //Int type ( of : i )== Float . self //true El lenguaje es fuertemente tipado y no hay conversi\u00f3n autom\u00e1tica, no podemos asignar por ejemplo un valor 1.5 a una variable Int , el compilador no va a truncar el valor, pero s\u00ed podemos hacer un cast 1 var i : Int = Int ( 1.5 ) //1 Podemos usar Any para indicar \"cualquier tipo\". Algunos APIs en los que no se puede saber por adelantado el tipo de retorno lo usan Si declaramos una variable sin inicializar y la intentamos usar, es un error de compilaci\u00f3n Tipos de datos b\u00e1sicos (de la librer\u00eda est\u00e1ndar) \u00b6 String \u00b6 Se aplican la mayor\u00eda de convenciones habituales: delimitadas por dobles comillas, concatenadas con + ,... Se puede hacer interpolaci\u00f3n de cadenas (expresiones dentro de cadenas) usando \\() 1 2 3 var nombre = Pepe var edad = 33 print ( \" \\( nombre ) tiene \\( edad ) a\u00f1os\" ) Se pueden definir cadenas multil\u00ednea delimitadas con tres \" 1 2 3 4 5 6 var mensaje = \"\"\" Esto es una cadena multil\u00ednea. Se ignora el sangrado, se coloca todo al nivel del que tenga la primera l\u00ednea. Los delimitadores del final deben venir en su propia l\u00ednea \"\"\" Colecciones: arrays, conjuntos y diccionarios \u00b6 Arrays Se pueden declarar con [tipo] o Array<tipo> 1 2 var lista_enteros : [ Int ] var lista_cadenas : Array < String > Se pueden inicializar con una lista de valores literales [ ] . La notaci\u00f3n para acceder a un elemento es la misma que en C 1 2 var bizcocho = [ \"huevos\" , \"leche\" , \"harina\" ] bizcocho [ 2 ] = \"harina con levadura\" Si lo inicializamos con [tipo]() tendremos un array vac\u00edo. Pero los arrays pueden cambiar de tama\u00f1o din\u00e1micamente a diferencia de lenguajes m\u00e1s tradicionales como C++/Java 1 2 3 4 var nums = [ Int ]() nums . append ( 3 ) //nums == [3] nums . insert ( 1 , at : 0 ) //nums == [1,3] nums . remove ( at : 0 ) //nums == [3] Podemos concatenar arrays con + Podemos iterar sobre un array (en general sobre una colecci\u00f3n) con for ... in 1 2 3 4 var bizcocho = [ \"huevos\" , \"leche\" , \"harina\" ] for ingrediente in bizcocho { print ( ingrediente ) } Conjuntos Son listas de valores que no se pueden repetir. Si lo inicializamos con un valor literal, hay que especificar como tipo Set , si no Swift lo tomar\u00eda como un array 1 var generos : Set = [ \"Rock\" , \"Pop\" ] Algunas operaciones: insert(_) , remove(_) , operaciones de conjuntos: set1.union(set2) ,... Se puede iterar con for ... in como en los arrays Diccionarios \u00b6 Son listas de pares clave/valor. Lo que en Java ser\u00edan HashMaps o Maps en Javascript Inicializaci\u00f3n con valores literales: 1 2 3 var horasTrabajadas = [ \"Lunes\" : 7 , \"Martes\" : 8 , \"Mi\u00e9rcoles\" : 7 ] horasTrabajadas [ \"Lunes\" ]== 7 //true horasTrabajadas [ \"Jueves\" ]= 5 Se pueden declarar sin inicializar especificando el tipo de la clave y el tipo del valor 1 2 var horas = [ String : Int ] var masHoras = Dictionary < String : Int > Se puede iterar por ellos con for (clave,valor) in 1 2 3 4 var grupo = [ \"Billy\" : \"guitar\" , \"James\" : \"guitar\" , \"Darcy\" : \"bass\" , \"Jimmy\" : \"drums\" ] for ( nombre , instrumento ) in grupo { print ( \" \\( nombre ) on the \\( instrumento ) \" ) } Instrucciones de control de flujo \u00b6 Hay algunas instrucciones que son iguales a C/Java, como el if o el while con ciertas diferencias: Las condiciones no es necesario ponerlas entre par\u00e9ntesis Aunque un bloque de sentencias tenga una \u00fanica instrucci\u00f3n siempre hay que poner llaves, por ejemplo: 1 2 3 4 5 if edad < 18 { print ( \"Lo siento, no puedes entrar a este sitio\" ) } else { print ( \"Bienvenido\" ) } Ya hemos visto for ... in con colecciones. Tambi\u00e9n se puede aplicar a rangos : 1 2 3 4 5 6 7 for i in 1. .. 5 { print ( i ) } for i in 1. .< 3 { //rango semiabierto, llega solo hasta el 2 print ( i ) } Si solo nos interesa realizar un determinado n\u00famero de iteraciones y no en cu\u00e1l estamos, podemos usar la variable an\u00f3nima , _ 1 2 3 for _ in 1. .. 3 { print ( \"RA \" ) } Existe una instrucci\u00f3n equivalente al do...while que es el repeat ... while ( do es una palabra clave del lenguaje pero se usa en el manejo de errores) switch es similar a C/Java, pero * No hace falta break despu\u00e9s de cada case . Por defecto cuando salimos de un case se sale del switch * En los case se puede poner cualquier tipo de datos (Int, Float, String,...), varios valores, rangos, o condiciones. * Los case deben ser exhaustivos . Es decir deben cubrir todos los posibles valores de la variable (o si son infinitos, como en variables num\u00e9ricas, al menos debe haber un default ) 1 2 3 4 5 6 7 8 9 10 let valorCarta = - 1 switch valorCarta { case 1. .. 7 : print ( \"Es un \\( valorCarta ) \" ) case 8 , 9 : print ( \"Normalmente no se usan 8 y 9\" ) case 10 : print ( \"Sota\" ) case 11 : print ( \"Caballo\" ) case 12 : print ( \"Rey\" ) case let x where x < 0 : print ( \"WTF! \u00bfUna carta negativa?\" ) default : print ( \"Carta no v\u00e1lida\" ) } Funciones \u00b6 Para definir una funci\u00f3n se usa la sintaxis func nombre(par1:tipo1, par2:tipo2)->TipoRetorno . Si una funci\u00f3n no devuelve nada se omite el ->TipoRetorno 1 2 3 4 5 6 7 func generarSaludo ( nombre : String )-> String { return \"Hola \\( nombre ) \" } func imprimirSaludo ( nombre : String ) { print ( \"Hola \\( nombre ) \" ) } Los nombres de los par\u00e1metros no solo se usan dentro del c\u00f3digo de la funci\u00f3n, sino tambi\u00e9n como etiquetas al llamarla. Continuando con los ejemplos anteriores 1 generarSaludo ( nombre : \"Pepe\" ) Hay casos en los que quedar\u00eda m\u00e1s \"natural\" darle un nombre a la etiqueta diferente al que se usa dentro de la funci\u00f3n. En ese caso ponemos primero la etiqueta y luego el nombre \"interno\". Si no queremos usar etiqueta ponemos la variable an\u00f3nima: _ 1 2 3 4 func saludarA ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saludarA ( \"Pepe\" , el : \"Martes\" ) Los par\u00e1metros no son modificables dentro del cuerpo de la funci\u00f3n, es decir, dentro del cuerpo se tratan como si fueran constantes definidas con let . Podemos cambiar esto marcando el par\u00e1metro con inout , que se pone antes del tipo: func ejemplo(par : inout Int) . Para llamar a la funci\u00f3n hay que marcar expl\u00edcitamente el par\u00e1metro con un & . ejemplo(par:&valor) . Las funciones son \"ciudadanos de primera clase\", al igual que cualquier objeto se pueden pasar como par\u00e1metro y una funci\u00f3n puede devolver otra funci\u00f3n Opcionales \u00b6 nil es como el null de Java, pero es aplicable tambi\u00e9n a Int , Float , ... No obstante, una variable \"normal\" no puede valer nil . 1 var valor : Int = nil //esto no va a compilar Para indicar que una variable puede valer nil , debemos declararla como opcional , con un ? en la declaraci\u00f3n, despu\u00e9s del tipo, por ejemplo Int? 1 var valor : Int ? = nil //esto s\u00ed es OK Muchos m\u00e9todos de la librer\u00eda de Swift devuelven un valor opcional, con nil si fallan. Por ejemplo los m\u00e9todos que hacen conversi\u00f3n de tipos. 1 2 //como es l\u00f3gico esta conversi\u00f3n falla, y por tanto devuelve nil let num = Int ( \"hola\" ) En una variable opcional el valor no est\u00e1 accesible directamente sino que est\u00e1 \"envuelto\" ( wrapped ). No se puede operar con \u00e9l directamente, antes hay que desenvolverlo , ahora veremos c\u00f3mo. 1 2 3 let valor = Int ( \"1\" ) //esta conversi\u00f3n es OK, pero devuelve un 1 \"envuelto\" print ( valor ) //no es 1, sino que pone Optional(1) print ( valor + 1 ) //CRASH! esto no es v\u00e1lido Podemos desenvolver el opcional con ! , pero hay que llevar cuidado, ya que intentar desenvolver nil es un error 1 2 let valor = Int ( \"1\" ) print ( valor ! + 1 ) El patr\u00f3n t\u00edpico para desenvolver opcionales de forma segura es usar if let , que es una especie de condicional que solo se cumple si el valor desenvuelto es distinto de nil , y \"de paso\" le asigna el valor desenvuelto a la variable que ponemos en el let 1 2 3 4 let valor = Int ( \"1\" ) if let valorDesenvuelto = valor { print ( \"\u00a1Es un n\u00famero!: \\( valorDesenvuelto ) \" ) } Aunque en muchos ejemplos de if..let se usa una nueva variable para el valor desenvuelto podemos usar la misma del valor original, as\u00ed evitamos tener que crear una variable nueva solo para desenvolver 1 2 3 4 let valor = Int ( \"1\" ) if let valor = valor { print ( \"\u00a1Es un n\u00famero!: \\( valor ) \" ) } Como el c\u00f3digo para desenvolver valores es tedioso, se nos da la posibilidad de definir opcionales pero tratarlos como si no lo fueran, ya que no hace falta desenvolverlos: son los denominados Implicitly unwrapped optionals , declarados con tipo! , por ejemplo: 1 2 3 let valor : Int ! valor = Int ( \"1\" ) print ( valor ) Clases \u00b6 La sintaxis es similar a Java con algunas diferencias: + No se pone new para instanciar un nuevo objeto + En lugar de this , se pone self + Los constructores, aqu\u00ed llamados inicializadores se definen siempre como init por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 class Figura { var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } func descripcion () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ()) Propiedades computadas: son getters / setters , desde \"fuera\" parecen propiedades pero en realidad son m\u00e9todos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Figura { private var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } var descripcion : String { get { return \"Una figura con \\( numeroDeLados ) lados.\" } } var lados : Int { get { return numeroDeLados } set ( lados ) { self . numeroDeLados = lados } } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ) Los objetos se pasan por referencia igual que en Java 1 2 3 4 5 let h1 = Figura ( lados : 6 ) //no es copia, sino referencia. h2 y h2 \"apuntan\" al mismo objeto let h2 = h1 h2 . lados = 5 print ( h1 . descripcion ) //Una figura con 5 lados (!!) Las struct se parecen mucho a las clases, mucho m\u00e1s que en C, las veremos en siguientes sesiones Para la herencia se usa la notaci\u00f3n class ClaseHeredada : ClaseBase , y para sobreescribir un m\u00e9todo, override casting : algunas veces ciertos APIs devuelven resultados \"sin tipo\" ( Any ), pero es posible que nosotros sepamos que una variable es de una determinada clase. Podemos forzar esa conversi\u00f3n con as : dato as Clase . Tambi\u00e9n podemos hacer esto si tenemos una variable de una clase base pero nosotros sabemos que en realidad es una instancia de una clase derivada. CUIDADO: en el REPL los modificadores de acceso no funcionan Extensiones \u00b6 Nos permiten a\u00f1adir nueva funcionalidad a clases ya existentes, incluso aun sin acceso al c\u00f3digo fuente o en clases del sistema. Se pueden a\u00f1adir por ejemplo nuevos m\u00e9todos, inicializadores y propiedades computadas. Lo que no se puede hacer es sobreescribir los m\u00e9todos o propiedades ya existentes. 1 2 3 4 5 extension String { func reggaetonizar () -> String { return self + \" ya t\u00fa sabes\" } } Podemos usar los m\u00e9todos y propiedades de la extensi\u00f3n como us\u00e1bamos los originales: 1 print ( \"mami\" . reggaetonizar ()) //mami ya t\u00fa sabes Enumerados \u00b6 Se definen de forma similar a C pero no tienen nada que ver, son tipos \"por derecho propio\", no enteros 1 2 3 enum Direccion { case norte , sur , este , oeste } Pueden tener un valor \"interno\" ( raw ), cuyo tipo se indica como si el enumerado heredara de \u00e9l. Cuando se pone Int , Swift asigna valores comenzando por 0. Accedemos a este valor con rawValue . 1 2 3 4 enum Direccion : Int { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //0 Si indicamos String como tipo del rawValue Swift hace una \"conversi\u00f3n autom\u00e1tica\" de los nombres a Strings 1 2 3 4 enum Direccion : String { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //\"norte\" Los enum pueden tener m\u00e9todos y ser conforme a protocolos (estos \u00faltimos son similares a los interfaces de Java). 1 2 3 4 5 6 7 8 9 10 11 enum Direccion : String { case norte , sur , este , oeste func inicial ()-> String { let cadena = self . rawValue let inicial = cadena [ cadena . startIndex ] return String ( inicial ). uppercased () } } print ( Direccion . norte . inicial ()) //\"N\"","title":"Introducci\u00f3n b\u00e1sica a Swift"},{"location":"s1/swift_basico/#introduccion-basica-a-swift","text":"Swift es un lenguaje originalmente desarrollado por Apple para la programaci\u00f3n de aplicaciones en las plataformas iOS y OSX. Pese a haber sido desarrollado con esta intenci\u00f3n, Swift es un lenguaje de prop\u00f3sito general. Es un lenguaje bastante completo y con muchas funcionalidades, pero tambi\u00e9n pensado para que las funcionalidades b\u00e1sicas sean sencillas de usar. Como muchos lenguajes modernos incluye no solo caracter\u00edsticas de programaci\u00f3n orientada a objetos sino tambi\u00e9n de programaci\u00f3n funcional.","title":"Introducci\u00f3n b\u00e1sica a Swift"},{"location":"s1/swift_basico/#preliminares","text":"En un programa Swift no hay un \"main\" como en C sino que el c\u00f3digo se empieza a ejecutar por la primera instrucci\u00f3n de \"nivel superior\", es decir las sentencias que no est\u00e1n dentro de funciones. Los \";\" al final de las sentencias son opcionales.","title":"Preliminares"},{"location":"s1/swift_basico/#variables-y-constantes","text":"Swift tiene una serie de tipos b\u00e1sicos : Int , Double , Float , Bool Las variables se definen con var y las constantes con let . Si inicializamos su valor no es necesario especificar el tipo, ya que el compilador de Swift lo induce a partir del valor inicial. 1 2 3 4 5 6 7 8 9 var i = 1 //i es un Int var d = 1.5 //d es un Double //Tambi\u00e9n podemos declarar el tipo, si no la inicializamos var f : Float f = 1.5 //O incluso declarar e inicializar var f2 : Float = 1.5 type(of:) nos devuelve el tipo 1 2 3 var i = 1 print ( type ( of : i )) //Int type ( of : i )== Float . self //true El lenguaje es fuertemente tipado y no hay conversi\u00f3n autom\u00e1tica, no podemos asignar por ejemplo un valor 1.5 a una variable Int , el compilador no va a truncar el valor, pero s\u00ed podemos hacer un cast 1 var i : Int = Int ( 1.5 ) //1 Podemos usar Any para indicar \"cualquier tipo\". Algunos APIs en los que no se puede saber por adelantado el tipo de retorno lo usan Si declaramos una variable sin inicializar y la intentamos usar, es un error de compilaci\u00f3n","title":"Variables y constantes"},{"location":"s1/swift_basico/#tipos-de-datos-basicos-de-la-libreria-estandar","text":"","title":"Tipos de datos b\u00e1sicos (de la librer\u00eda est\u00e1ndar)"},{"location":"s1/swift_basico/#string","text":"Se aplican la mayor\u00eda de convenciones habituales: delimitadas por dobles comillas, concatenadas con + ,... Se puede hacer interpolaci\u00f3n de cadenas (expresiones dentro de cadenas) usando \\() 1 2 3 var nombre = Pepe var edad = 33 print ( \" \\( nombre ) tiene \\( edad ) a\u00f1os\" ) Se pueden definir cadenas multil\u00ednea delimitadas con tres \" 1 2 3 4 5 6 var mensaje = \"\"\" Esto es una cadena multil\u00ednea. Se ignora el sangrado, se coloca todo al nivel del que tenga la primera l\u00ednea. Los delimitadores del final deben venir en su propia l\u00ednea \"\"\"","title":"String"},{"location":"s1/swift_basico/#colecciones-arrays-conjuntos-y-diccionarios","text":"","title":"Colecciones: arrays, conjuntos y diccionarios"},{"location":"s1/swift_basico/#diccionarios","text":"Son listas de pares clave/valor. Lo que en Java ser\u00edan HashMaps o Maps en Javascript Inicializaci\u00f3n con valores literales: 1 2 3 var horasTrabajadas = [ \"Lunes\" : 7 , \"Martes\" : 8 , \"Mi\u00e9rcoles\" : 7 ] horasTrabajadas [ \"Lunes\" ]== 7 //true horasTrabajadas [ \"Jueves\" ]= 5 Se pueden declarar sin inicializar especificando el tipo de la clave y el tipo del valor 1 2 var horas = [ String : Int ] var masHoras = Dictionary < String : Int > Se puede iterar por ellos con for (clave,valor) in 1 2 3 4 var grupo = [ \"Billy\" : \"guitar\" , \"James\" : \"guitar\" , \"Darcy\" : \"bass\" , \"Jimmy\" : \"drums\" ] for ( nombre , instrumento ) in grupo { print ( \" \\( nombre ) on the \\( instrumento ) \" ) }","title":"Diccionarios"},{"location":"s1/swift_basico/#instrucciones-de-control-de-flujo","text":"Hay algunas instrucciones que son iguales a C/Java, como el if o el while con ciertas diferencias: Las condiciones no es necesario ponerlas entre par\u00e9ntesis Aunque un bloque de sentencias tenga una \u00fanica instrucci\u00f3n siempre hay que poner llaves, por ejemplo: 1 2 3 4 5 if edad < 18 { print ( \"Lo siento, no puedes entrar a este sitio\" ) } else { print ( \"Bienvenido\" ) } Ya hemos visto for ... in con colecciones. Tambi\u00e9n se puede aplicar a rangos : 1 2 3 4 5 6 7 for i in 1. .. 5 { print ( i ) } for i in 1. .< 3 { //rango semiabierto, llega solo hasta el 2 print ( i ) } Si solo nos interesa realizar un determinado n\u00famero de iteraciones y no en cu\u00e1l estamos, podemos usar la variable an\u00f3nima , _ 1 2 3 for _ in 1. .. 3 { print ( \"RA \" ) } Existe una instrucci\u00f3n equivalente al do...while que es el repeat ... while ( do es una palabra clave del lenguaje pero se usa en el manejo de errores) switch es similar a C/Java, pero * No hace falta break despu\u00e9s de cada case . Por defecto cuando salimos de un case se sale del switch * En los case se puede poner cualquier tipo de datos (Int, Float, String,...), varios valores, rangos, o condiciones. * Los case deben ser exhaustivos . Es decir deben cubrir todos los posibles valores de la variable (o si son infinitos, como en variables num\u00e9ricas, al menos debe haber un default ) 1 2 3 4 5 6 7 8 9 10 let valorCarta = - 1 switch valorCarta { case 1. .. 7 : print ( \"Es un \\( valorCarta ) \" ) case 8 , 9 : print ( \"Normalmente no se usan 8 y 9\" ) case 10 : print ( \"Sota\" ) case 11 : print ( \"Caballo\" ) case 12 : print ( \"Rey\" ) case let x where x < 0 : print ( \"WTF! \u00bfUna carta negativa?\" ) default : print ( \"Carta no v\u00e1lida\" ) }","title":"Instrucciones de control de flujo"},{"location":"s1/swift_basico/#funciones","text":"Para definir una funci\u00f3n se usa la sintaxis func nombre(par1:tipo1, par2:tipo2)->TipoRetorno . Si una funci\u00f3n no devuelve nada se omite el ->TipoRetorno 1 2 3 4 5 6 7 func generarSaludo ( nombre : String )-> String { return \"Hola \\( nombre ) \" } func imprimirSaludo ( nombre : String ) { print ( \"Hola \\( nombre ) \" ) } Los nombres de los par\u00e1metros no solo se usan dentro del c\u00f3digo de la funci\u00f3n, sino tambi\u00e9n como etiquetas al llamarla. Continuando con los ejemplos anteriores 1 generarSaludo ( nombre : \"Pepe\" ) Hay casos en los que quedar\u00eda m\u00e1s \"natural\" darle un nombre a la etiqueta diferente al que se usa dentro de la funci\u00f3n. En ese caso ponemos primero la etiqueta y luego el nombre \"interno\". Si no queremos usar etiqueta ponemos la variable an\u00f3nima: _ 1 2 3 4 func saludarA ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saludarA ( \"Pepe\" , el : \"Martes\" ) Los par\u00e1metros no son modificables dentro del cuerpo de la funci\u00f3n, es decir, dentro del cuerpo se tratan como si fueran constantes definidas con let . Podemos cambiar esto marcando el par\u00e1metro con inout , que se pone antes del tipo: func ejemplo(par : inout Int) . Para llamar a la funci\u00f3n hay que marcar expl\u00edcitamente el par\u00e1metro con un & . ejemplo(par:&valor) . Las funciones son \"ciudadanos de primera clase\", al igual que cualquier objeto se pueden pasar como par\u00e1metro y una funci\u00f3n puede devolver otra funci\u00f3n","title":"Funciones"},{"location":"s1/swift_basico/#opcionales","text":"nil es como el null de Java, pero es aplicable tambi\u00e9n a Int , Float , ... No obstante, una variable \"normal\" no puede valer nil . 1 var valor : Int = nil //esto no va a compilar Para indicar que una variable puede valer nil , debemos declararla como opcional , con un ? en la declaraci\u00f3n, despu\u00e9s del tipo, por ejemplo Int? 1 var valor : Int ? = nil //esto s\u00ed es OK Muchos m\u00e9todos de la librer\u00eda de Swift devuelven un valor opcional, con nil si fallan. Por ejemplo los m\u00e9todos que hacen conversi\u00f3n de tipos. 1 2 //como es l\u00f3gico esta conversi\u00f3n falla, y por tanto devuelve nil let num = Int ( \"hola\" ) En una variable opcional el valor no est\u00e1 accesible directamente sino que est\u00e1 \"envuelto\" ( wrapped ). No se puede operar con \u00e9l directamente, antes hay que desenvolverlo , ahora veremos c\u00f3mo. 1 2 3 let valor = Int ( \"1\" ) //esta conversi\u00f3n es OK, pero devuelve un 1 \"envuelto\" print ( valor ) //no es 1, sino que pone Optional(1) print ( valor + 1 ) //CRASH! esto no es v\u00e1lido Podemos desenvolver el opcional con ! , pero hay que llevar cuidado, ya que intentar desenvolver nil es un error 1 2 let valor = Int ( \"1\" ) print ( valor ! + 1 ) El patr\u00f3n t\u00edpico para desenvolver opcionales de forma segura es usar if let , que es una especie de condicional que solo se cumple si el valor desenvuelto es distinto de nil , y \"de paso\" le asigna el valor desenvuelto a la variable que ponemos en el let 1 2 3 4 let valor = Int ( \"1\" ) if let valorDesenvuelto = valor { print ( \"\u00a1Es un n\u00famero!: \\( valorDesenvuelto ) \" ) } Aunque en muchos ejemplos de if..let se usa una nueva variable para el valor desenvuelto podemos usar la misma del valor original, as\u00ed evitamos tener que crear una variable nueva solo para desenvolver 1 2 3 4 let valor = Int ( \"1\" ) if let valor = valor { print ( \"\u00a1Es un n\u00famero!: \\( valor ) \" ) } Como el c\u00f3digo para desenvolver valores es tedioso, se nos da la posibilidad de definir opcionales pero tratarlos como si no lo fueran, ya que no hace falta desenvolverlos: son los denominados Implicitly unwrapped optionals , declarados con tipo! , por ejemplo: 1 2 3 let valor : Int ! valor = Int ( \"1\" ) print ( valor )","title":"Opcionales"},{"location":"s1/swift_basico/#clases","text":"La sintaxis es similar a Java con algunas diferencias: + No se pone new para instanciar un nuevo objeto + En lugar de this , se pone self + Los constructores, aqu\u00ed llamados inicializadores se definen siempre como init por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 class Figura { var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } func descripcion () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ()) Propiedades computadas: son getters / setters , desde \"fuera\" parecen propiedades pero en realidad son m\u00e9todos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Figura { private var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } var descripcion : String { get { return \"Una figura con \\( numeroDeLados ) lados.\" } } var lados : Int { get { return numeroDeLados } set ( lados ) { self . numeroDeLados = lados } } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ) Los objetos se pasan por referencia igual que en Java 1 2 3 4 5 let h1 = Figura ( lados : 6 ) //no es copia, sino referencia. h2 y h2 \"apuntan\" al mismo objeto let h2 = h1 h2 . lados = 5 print ( h1 . descripcion ) //Una figura con 5 lados (!!) Las struct se parecen mucho a las clases, mucho m\u00e1s que en C, las veremos en siguientes sesiones Para la herencia se usa la notaci\u00f3n class ClaseHeredada : ClaseBase , y para sobreescribir un m\u00e9todo, override casting : algunas veces ciertos APIs devuelven resultados \"sin tipo\" ( Any ), pero es posible que nosotros sepamos que una variable es de una determinada clase. Podemos forzar esa conversi\u00f3n con as : dato as Clase . Tambi\u00e9n podemos hacer esto si tenemos una variable de una clase base pero nosotros sabemos que en realidad es una instancia de una clase derivada. CUIDADO: en el REPL los modificadores de acceso no funcionan","title":"Clases"},{"location":"s1/swift_basico/#extensiones","text":"Nos permiten a\u00f1adir nueva funcionalidad a clases ya existentes, incluso aun sin acceso al c\u00f3digo fuente o en clases del sistema. Se pueden a\u00f1adir por ejemplo nuevos m\u00e9todos, inicializadores y propiedades computadas. Lo que no se puede hacer es sobreescribir los m\u00e9todos o propiedades ya existentes. 1 2 3 4 5 extension String { func reggaetonizar () -> String { return self + \" ya t\u00fa sabes\" } } Podemos usar los m\u00e9todos y propiedades de la extensi\u00f3n como us\u00e1bamos los originales: 1 print ( \"mami\" . reggaetonizar ()) //mami ya t\u00fa sabes","title":"Extensiones"},{"location":"s1/swift_basico/#enumerados","text":"Se definen de forma similar a C pero no tienen nada que ver, son tipos \"por derecho propio\", no enteros 1 2 3 enum Direccion { case norte , sur , este , oeste } Pueden tener un valor \"interno\" ( raw ), cuyo tipo se indica como si el enumerado heredara de \u00e9l. Cuando se pone Int , Swift asigna valores comenzando por 0. Accedemos a este valor con rawValue . 1 2 3 4 enum Direccion : Int { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //0 Si indicamos String como tipo del rawValue Swift hace una \"conversi\u00f3n autom\u00e1tica\" de los nombres a Strings 1 2 3 4 enum Direccion : String { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //\"norte\" Los enum pueden tener m\u00e9todos y ser conforme a protocolos (estos \u00faltimos son similares a los interfaces de Java). 1 2 3 4 5 6 7 8 9 10 11 enum Direccion : String { case norte , sur , este , oeste func inicial ()-> String { let cadena = self . rawValue let inicial = cadena [ cadena . startIndex ] return String ( inicial ). uppercased () } } print ( Direccion . norte . inicial ()) //\"N\"","title":"Enumerados"},{"location":"s2/aplicaciones_ios/","text":"Introducci\u00f3n a las aplicaciones iOS \u00b6 Una vez vistos los conceptos b\u00e1sicos del lenguaje de programaci\u00f3n que vamos a usar, que es Swift, vamos a ver qu\u00e9 estructura tienen las aplicaciones en iOS. Como ahora mismo veremos, Apple utiliza mucho los patrones de dise\u00f1o software en iOS. De hecho todas las apps de esta plataforma siguen el conocido patr\u00f3n Modelo/Vista/Controlador. Por ello veremos primero en qu\u00e9 consiste, c\u00f3mo se implementa en iOS y qu\u00e9 clases b\u00e1sicas forman la estructura de toda aplicaci\u00f3n. Implementaremos nuestra primera aplicaci\u00f3n iOS para poder entender mejor todos estos conceptos. Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC \u00b6 Como acabamos de comentar, las aplicaciones iOS siguen el archiconocido patr\u00f3n de dise\u00f1o \"Modelo/Vista/Controlador\", abreviado com\u00fanmente como MVC. Aunque hay muchas variantes de este patr\u00f3n y los detalles var\u00edan mucho entre ellas, en general en todas: El modelo es el \"coraz\u00f3n\" de la aplicaci\u00f3n y la parte que no se ve , es decir, la estructura de clases que modelan la llamada l\u00f3gica de negocio . Una de las ideas b\u00e1sicas de MVC es que el modelo deber\u00eda ser independiente de la interfaz (la vista) y por tanto reutilizable aunque cambie la interfaz de la aplicaci\u00f3n. En general, los frameworks de desarrollo de aplicaciones MVC es en lo que menos suelen intervenir, e iOS no es una excepci\u00f3n. Es decir, el modelo estar\u00e1 constituido generalmente por clases propias, y no necesariamente de ninguna biblioteca del sistema. La vista es la interfaz de la aplicaci\u00f3n. Generalmente todas las plataformas de desarrollo para m\u00f3viles tienen una biblioteca de componentes de interfaz de usuario: botones, campos de texto, sliders , ... que podemos usar para componer la vista. Como veremos, en iOS podemos crear la interfaz \"arrastrando\" componentes en un editor gr\u00e1fico integrado en Xcode. O tambi\u00e9n podemos crear la interfaz por c\u00f3digo. El controlador es el elemento que presenta m\u00e1s diferencias de una variante a otra de MVC. responde a eventos (generalmente acciones del usuario - por ejemplo un tap sobre un bot\u00f3n) y realiza peticiones al modelo. Al contrario, tambi\u00e9n puede detectar un cambio en el modelo y solicitarle a la vista que lo muestre. Como veremos, en iOS el controlador es una clase que hereda de una propia del sistema. Aunque en MVC el papel de estos elementos est\u00e1 m\u00e1s o menos claro en t\u00e9rminos generales, no suele estar tan clara la relaci\u00f3n entre ellos (qui\u00e9n comunica con qui\u00e9n y c\u00f3mo). En la variante concreta de MVC que se usa en iOS, la relaci\u00f3n entre estos tres elementos se muestra en la siguiente figura: Como vemos, el controlador est\u00e1 \"enmedio\" de la vista y el modelo, aislando ambos entre s\u00ed, de modo que vista y modelo no tienen comunicaci\u00f3n directa. Esto nos permite modificar uno sin afectar al otro. En cuanto a la comunicaci\u00f3n entre vista y controlador: Cuando la vista genera un evento, el controlador lo recibe a trav\u00e9s de lo que en iOS se llama un action . B\u00e1sicamente es un m\u00e9todo del controlador que hace de callback del evento. El controlador guarda referencias a los elementos de la vista que nos interesa en lo que se denominan outlets . As\u00ed puede cambiar la vista (por ejemplo cambiar el texto de un campo o desactivar un bot\u00f3n) Y entre modelo y controlador: El controlador guarda una referencia al modelo y a trav\u00e9s de ella puede llamar a sus m\u00e9todos. Cuando se produce un cambio en el modelo, este \"avisa\" al controlador mediante m\u00e9todos est\u00e1ndar en iOS para comunicaci\u00f3n entre objetos, como son el KVO y las notificaciones locales. Comenzando nuestra primera aplicaci\u00f3n iOS \u00b6 Vamos a implementar una aplicaci\u00f3n muy sencilla a la que llamaremos \"UAdivino\". Es una versi\u00f3n del cl\u00e1sico juguete \" la bola 8 m\u00e1gica \", a la que se le formula una pregunta y que supuestamente responde, dando en realidad respuestas gen\u00e9ricas: \"s\u00ed\", \"\u00a1claro que no!\", \"es muy posible\",... Para crear la aplicaci\u00f3n arrancamos Xcode: En las opciones de la izquierda seleccionamos \"Create a new Xcode project\". En el siguiente paso elegimos la plantilla \"Single View App\", ya que nuestra aplicaci\u00f3n tiene una \u00fanica \"pantalla\". Tras darle a Next , escribimos el nombre del proyecto, UAdivino . Si estamos usando Xcode 11 hay que asegurarse que en el desplegable de User Interface se selecciona Storyboard (SwiftUI, la otra opci\u00f3n de la interfaz, no la usaremos de momento). En la \u00faltima pantalla del asistente podemos seleccionar la carpeta donde guardar el proyecto. Elegimos la que queramos. Estructura del c\u00f3digo de una aplicaci\u00f3n \u00b6 La siguiente figura, tomada de la \" App programming guide for iOS \" de Apple, muestra los elementos b\u00e1sicos de cualquier aplicaci\u00f3n iOS. Podemos distinguir la parte del modelo, la del controlador y la de la vista. N\u00f3tese que no hay un \u00fanico controlador ni una \u00fanica vista. En general, podr\u00edamos decir que por cada \"pantalla\" de nuestra aplicaci\u00f3n tendremos un controlador \"principal\" que controla una vista. Esa vista a su vez est\u00e1 formada por una jerarqu\u00eda de subvistas (paneles, botones, sliders ,...). Esto no hay que tomarlo literalmente, ya que en una \"pantalla\" puede haber m\u00e1s de un controlador, pero es \u00fatil para hacerse una idea aproximada. La plantilla creada por Xcode \u00b6 Para no tener que partir de cero, Xcode nos ha creado una plantilla con varias clases y archivos adicionales, que se corresponden con la estructura gen\u00e9rica de una aplicaci\u00f3n que acabamos de ver: Clases: AppDelegate : es la clase que gestiona lo que hacer ante los diferentes eventos del ciclo de vida de la aplicaci\u00f3n: cuando acaba de arrancar, cuando va a pasar a segundo plano, ... ViewController es el controlador \"inicial\" de la aplicaci\u00f3n, el que \"entra en acci\u00f3n\" cuando esta arranca. En nuestro caso adem\u00e1s es el \u00fanico controlador ya que nuestra aplicaci\u00f3n solo tiene una pantalla. Archivos de interfaz de usuario: los .storyboard , que constituyen el interfaz gr\u00e1fico de la aplicaci\u00f3n Main.storyboard : el interfaz en s\u00ed de la app , que luego editaremos LaunchScreen.storyboard : la pantalla que aparece mientras la aplicaci\u00f3n se est\u00e1 cargando Archivos de configuraci\u00f3n info.plist : propiedades de configuraci\u00f3n de la aplicaci\u00f3n, en un formato especial denominado plist que ya veremos con detalle en la asignatura de persistencia de datos. Por ahora nos basta con saber que es una lista de nombres y valores de propiedades y que los valores pueden ser num\u00e9ricos, cadenas o listas. Recursos: la carpeta Assets.xcassets , que es donde se colocan las im\u00e1genes y otros recursos de la aplicaci\u00f3n Creaci\u00f3n de la interfaz (la vista) \u00b6 La interfaz de la aplicaci\u00f3n va a tener el siguiente aspecto, con un \"cartel\" explicando qu\u00e9 hace la app , un bot\u00f3n para solicitar la respuesta, y un campo en el que aparecer\u00e1 dicha respuesta. Como hemos comentado, la interfaz est\u00e1 definida en el archivo Main.storyboard . \u00c1brelo y ver\u00e1s que en el editor aparece una pantalla de iPhone vac\u00eda. La flecha que apunta desde la izquierda indica que es la pantalla inicial de la app . En la parte inferior del editor aparece un mensaje de View as: iPhone ... y el modelo que tengas seleccionado en ese momento. Pulsando sobre \u00e9l puedes cambiar el dispositivo y/o la orientaci\u00f3n. Debido a la distinta resoluci\u00f3n de cada dispositivo, el dise\u00f1o de pantalla que hagas aqu\u00ed en principio solo se va a ver bien en un dispositivo y una orientaci\u00f3n concretas . Para hacer interfaces que se adapten al dispositivo necesitas autolayout y traits que se ver\u00e1n con posterioridad en el curso. Vamos a a\u00f1adir los componentes de la interfaz. Si est\u00e1s en Xcode 10, en la parte superior derecha de la barra de botones ver\u00e1s un bot\u00f3n con un cuadrado dentro de un c\u00edrculo (el primer bot\u00f3n de esta zona). Al pulsar en \u00e9l se mostrar\u00e1 una ventana flotante con los componentes de interfaz de usuario. Este bot\u00f3n ha cambiado en las \u00faltimas versiones de Xcode. En la 11 tiene un s\u00edmbolo de un + . En la 9 e inferiores no exist\u00eda, el panel de componentes se ve\u00eda en la parte inferior derecha de la ventana, sin necesidad de pulsar ning\u00fan bot\u00f3n. Primero vamos a hacer el \"cartel\" con el mensaje de \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\". En iOS este tipo de componente es un Label . B\u00fascalo en el panel de componentes y arr\u00e1stralo a la pantalla que estamos dise\u00f1ando. Una vez colocada puedes hacer las operaciones habituales: moverla con el rat\u00f3n, cambiar su tama\u00f1o arrastrando los puntos de las esquinas o editar el contenido con doble clic. Cambia el texto del Label por un mensaje como \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\" Las propiedades de cualquier componente tambi\u00e9n se pueden cambiar en el panel de la derecha estando seleccionado el componente. Este panel est\u00e1 dividido en varias secciones, por las que se navega con los iconos de la parte superior. La que m\u00e1s nos interesa por el momento es la cuarta, denominada \"property inspector\". Cambia el n\u00famero de l\u00edneas a 2 para que el texto quepa en la pantalla. Cambia tambi\u00e9n la alineaci\u00f3n del texto a centrado para que quede mejor. Arrastra los dos componentes que faltan: un bot\u00f3n ( Button ) y otro Label que debes dejar con el texto vac\u00edo y donde aparecer\u00e1 el mensaje del adivino. Implementaci\u00f3n del modelo \u00b6 En esta app el modelo lo \u00fanico que debe hacer es generar respuestas al azar a demanda. Lo podemos implementar en una clase Adivino que tenga un m\u00e9todo obtenerRespuesta Para colocar el c\u00f3digo de la clase debemos crear un archivo Swift: en Xcode, File > New > File... y en el asistente seleccionamos la plantilla \"Swift File\". Lo guardamos en la misma carpeta UAdivino 1 2 3 4 5 6 7 8 9 import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"Si\" , \"No\" , \"Ni de casualidad\" , \"\u00a1Por supuesto!\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } Podemos comprobar provisionalmente que el modelo funciona instanciando un Adivino cuando la app arranque y generando varias respuestas. Algo como: 1 2 3 4 let adivino = Adivino () for _ in 1. . 5 { print ( obtenerRespuesta ()) } Podemos insertar el c\u00f3digo anterior en la clase AppDelegate , dentro del primero de sus m\u00e9todos : application(_ application:, didFinishLaunchingWithOptions:) , que es el que se ejecuta al terminar de arrancar la aplicaci\u00f3n. Para ejecutar el proyecto pulsa al bot\u00f3n con el s\u00edmbolo de \"Play\" de la barra superior de Xcode, o bien selecciona la opci\u00f3n de men\u00fa Build > Run . Aparecer\u00e1 el simulador de iOS con la pantalla del iPhone, y en la consola de Xcode deber\u00edan aparecer los mensajes generados por el \"adivino\". Implementaci\u00f3n del controlador \u00b6 En el controlador es donde vamos a hacer la comunicaci\u00f3n entre la vista y el modelo. Cada vez que se pulse el bot\u00f3n, el modelo debe generar una respuesta Esta respuesta se debe mostrar como texto del Label que ahora tenemos provisionalmente vac\u00edo. Recibir eventos de la vista \u00b6 Para recibir eventos de la vista, necesitamos crear un action . Esto es lo que en otros entornos de programaci\u00f3n se conoce como listener , event handler , callback ,... Es simplemente un m\u00e9todo del controller al que el sistema llama cuando se produce un determinado evento sobre un componente de la interfaz. Para crear un action que vincule el bot\u00f3n y el controlador hay que seguir estos pasos en Xcode: Tener abierto el storyboard con la pantalla donde est\u00e1 el componente a vincular (en nuestro caso el bot\u00f3n) Pasar a editar en modo asistente , en el que se ve tanto la interfaz como el c\u00f3digo. En la esquina superior derecha hay dos grupos de tres botones. El primer grupo cambia el modo de edici\u00f3n. Nos interesa el segundo de los botones, con un icono de \"aros entrelazados\". Al pulsarlo, el editor se dividir\u00e1 para mostrar no solo la interfaz sino tambi\u00e9n el c\u00f3digo fuente del controller asociado. En el c\u00f3digo fuente del ViewController buscamos un \"hueco\" donde se pueda crear un m\u00e9todo que ser\u00e1 el llamado cuando se genere el evento. Finalmente, para vincular, hacer clic con el rat\u00f3n sobre el Button pero manteniendo pulsada tambi\u00e9n la tecla Ctrl . Sin soltar el rat\u00f3n, \"conectamos\" con el c\u00f3digo fuente del controller al punto del c\u00f3digo del ViewController que hemos decidido antes. Al soltar el bot\u00f3n del rat\u00f3n nos dar\u00e1 a elegir el tipo de conexi\u00f3n ( Connection ). Seleccionamos Action , escribimos el nombre que tendr\u00e1 el m\u00e9todo (por ejemplo botonPulsado ) y pulsamos el bot\u00f3n Connect . N\u00f3tese que el m\u00e9todo que se ha creado lleva una anotaci\u00f3n especial, @IBAction que indica que es un action . Adem\u00e1s a la izquierda del nombre sale un c\u00edrculo \"relleno\" que indica que est\u00e1 conectado a un componente de la interfaz. Si pasamos el rat\u00f3n por encima aparecer\u00e1 destacado el componente en fondo azul. Llamar al modelo \u00b6 Ahora en el m\u00e9todo del action botonPulsado tenemos que llamar al modelo. En nuestro caso es tan simple como llamar a obtenerRespuesta() pero para eso necesitamos declarar una instancia del modelo en el controlador. Por ello le a\u00f1adimos una nueva propiedad: 1 2 3 4 5 6 7 //En el ViewController.swift class ViewController : UIViewController { let miAdivino = Adivino () ... Ahora tenemos que obtener una respuesta cuando se pulse el bot\u00f3n: 1 2 3 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () } pero todav\u00eda nos falta mostrarla en la interfaz. Para eso necesitamos conectar el controller con la vista Modificar la vista \u00b6 Por cada componente de la interfaz de usuario que queramos modificar desde el controller necesitamos definir un outlet , que no es m\u00e1s que una variable que referencia al componente. Pero la variable no la declaramos nosotros sino que se crea de forma parecida a como se crean los action : gr\u00e1ficamente, con el rat\u00f3n. Queremos conectar el controller con el Label que por ahora tiene texto vac\u00edo: De nuevo ponemos el editor en modo asistente, y buscamos un \"hueco\" apropiado en el c\u00f3digo fuente del controller donde se pueda definir la variable. Arrastramos con Ctrl + clic desde el bot\u00f3n al c\u00f3digo del controller pero ahora cuando soltemos el bot\u00f3n del rat\u00f3n y nos pregunte el tipo de conexi\u00f3n dejamos Outlet . Escribimos un nombre apropiado para la variable (por ejemplo labelRespuesta ) y pulsamos sobre Connect . Vemos que la variable reci\u00e9n creada es del tipo UILabel y lleva la anotaci\u00f3n @IBOutlet para indicar que es un outlet . Si miramos la documentaci\u00f3n de iOS veremos que a trav\u00e9s de la propiedad text tenemos acceso al texto del componente. Por lo que finalmente el m\u00e9todo del action que hemos hecho antes quedar\u00e1: 1 2 3 4 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = respuesta } Ya deber\u00eda funcionar todo correctamente, as\u00ed que ya podemos probar la app .","title":"Introducci\u00f3n a las aplicaciones iOS"},{"location":"s2/aplicaciones_ios/#introduccion-a-las-aplicaciones-ios","text":"Una vez vistos los conceptos b\u00e1sicos del lenguaje de programaci\u00f3n que vamos a usar, que es Swift, vamos a ver qu\u00e9 estructura tienen las aplicaciones en iOS. Como ahora mismo veremos, Apple utiliza mucho los patrones de dise\u00f1o software en iOS. De hecho todas las apps de esta plataforma siguen el conocido patr\u00f3n Modelo/Vista/Controlador. Por ello veremos primero en qu\u00e9 consiste, c\u00f3mo se implementa en iOS y qu\u00e9 clases b\u00e1sicas forman la estructura de toda aplicaci\u00f3n. Implementaremos nuestra primera aplicaci\u00f3n iOS para poder entender mejor todos estos conceptos.","title":"Introducci\u00f3n a las aplicaciones iOS"},{"location":"s2/aplicaciones_ios/#patron-general-para-una-aplicacion-ios-mvc","text":"Como acabamos de comentar, las aplicaciones iOS siguen el archiconocido patr\u00f3n de dise\u00f1o \"Modelo/Vista/Controlador\", abreviado com\u00fanmente como MVC. Aunque hay muchas variantes de este patr\u00f3n y los detalles var\u00edan mucho entre ellas, en general en todas: El modelo es el \"coraz\u00f3n\" de la aplicaci\u00f3n y la parte que no se ve , es decir, la estructura de clases que modelan la llamada l\u00f3gica de negocio . Una de las ideas b\u00e1sicas de MVC es que el modelo deber\u00eda ser independiente de la interfaz (la vista) y por tanto reutilizable aunque cambie la interfaz de la aplicaci\u00f3n. En general, los frameworks de desarrollo de aplicaciones MVC es en lo que menos suelen intervenir, e iOS no es una excepci\u00f3n. Es decir, el modelo estar\u00e1 constituido generalmente por clases propias, y no necesariamente de ninguna biblioteca del sistema. La vista es la interfaz de la aplicaci\u00f3n. Generalmente todas las plataformas de desarrollo para m\u00f3viles tienen una biblioteca de componentes de interfaz de usuario: botones, campos de texto, sliders , ... que podemos usar para componer la vista. Como veremos, en iOS podemos crear la interfaz \"arrastrando\" componentes en un editor gr\u00e1fico integrado en Xcode. O tambi\u00e9n podemos crear la interfaz por c\u00f3digo. El controlador es el elemento que presenta m\u00e1s diferencias de una variante a otra de MVC. responde a eventos (generalmente acciones del usuario - por ejemplo un tap sobre un bot\u00f3n) y realiza peticiones al modelo. Al contrario, tambi\u00e9n puede detectar un cambio en el modelo y solicitarle a la vista que lo muestre. Como veremos, en iOS el controlador es una clase que hereda de una propia del sistema. Aunque en MVC el papel de estos elementos est\u00e1 m\u00e1s o menos claro en t\u00e9rminos generales, no suele estar tan clara la relaci\u00f3n entre ellos (qui\u00e9n comunica con qui\u00e9n y c\u00f3mo). En la variante concreta de MVC que se usa en iOS, la relaci\u00f3n entre estos tres elementos se muestra en la siguiente figura: Como vemos, el controlador est\u00e1 \"enmedio\" de la vista y el modelo, aislando ambos entre s\u00ed, de modo que vista y modelo no tienen comunicaci\u00f3n directa. Esto nos permite modificar uno sin afectar al otro. En cuanto a la comunicaci\u00f3n entre vista y controlador: Cuando la vista genera un evento, el controlador lo recibe a trav\u00e9s de lo que en iOS se llama un action . B\u00e1sicamente es un m\u00e9todo del controlador que hace de callback del evento. El controlador guarda referencias a los elementos de la vista que nos interesa en lo que se denominan outlets . As\u00ed puede cambiar la vista (por ejemplo cambiar el texto de un campo o desactivar un bot\u00f3n) Y entre modelo y controlador: El controlador guarda una referencia al modelo y a trav\u00e9s de ella puede llamar a sus m\u00e9todos. Cuando se produce un cambio en el modelo, este \"avisa\" al controlador mediante m\u00e9todos est\u00e1ndar en iOS para comunicaci\u00f3n entre objetos, como son el KVO y las notificaciones locales.","title":"Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC"},{"location":"s2/aplicaciones_ios/#comenzando-nuestra-primera-aplicacion-ios","text":"Vamos a implementar una aplicaci\u00f3n muy sencilla a la que llamaremos \"UAdivino\". Es una versi\u00f3n del cl\u00e1sico juguete \" la bola 8 m\u00e1gica \", a la que se le formula una pregunta y que supuestamente responde, dando en realidad respuestas gen\u00e9ricas: \"s\u00ed\", \"\u00a1claro que no!\", \"es muy posible\",... Para crear la aplicaci\u00f3n arrancamos Xcode: En las opciones de la izquierda seleccionamos \"Create a new Xcode project\". En el siguiente paso elegimos la plantilla \"Single View App\", ya que nuestra aplicaci\u00f3n tiene una \u00fanica \"pantalla\". Tras darle a Next , escribimos el nombre del proyecto, UAdivino . Si estamos usando Xcode 11 hay que asegurarse que en el desplegable de User Interface se selecciona Storyboard (SwiftUI, la otra opci\u00f3n de la interfaz, no la usaremos de momento). En la \u00faltima pantalla del asistente podemos seleccionar la carpeta donde guardar el proyecto. Elegimos la que queramos.","title":"Comenzando nuestra primera aplicaci\u00f3n iOS"},{"location":"s2/aplicaciones_ios/#estructura-del-codigo-de-una-aplicacion","text":"La siguiente figura, tomada de la \" App programming guide for iOS \" de Apple, muestra los elementos b\u00e1sicos de cualquier aplicaci\u00f3n iOS. Podemos distinguir la parte del modelo, la del controlador y la de la vista. N\u00f3tese que no hay un \u00fanico controlador ni una \u00fanica vista. En general, podr\u00edamos decir que por cada \"pantalla\" de nuestra aplicaci\u00f3n tendremos un controlador \"principal\" que controla una vista. Esa vista a su vez est\u00e1 formada por una jerarqu\u00eda de subvistas (paneles, botones, sliders ,...). Esto no hay que tomarlo literalmente, ya que en una \"pantalla\" puede haber m\u00e1s de un controlador, pero es \u00fatil para hacerse una idea aproximada.","title":"Estructura del c\u00f3digo de una aplicaci\u00f3n"},{"location":"s2/aplicaciones_ios/#la-plantilla-creada-por-xcode","text":"Para no tener que partir de cero, Xcode nos ha creado una plantilla con varias clases y archivos adicionales, que se corresponden con la estructura gen\u00e9rica de una aplicaci\u00f3n que acabamos de ver: Clases: AppDelegate : es la clase que gestiona lo que hacer ante los diferentes eventos del ciclo de vida de la aplicaci\u00f3n: cuando acaba de arrancar, cuando va a pasar a segundo plano, ... ViewController es el controlador \"inicial\" de la aplicaci\u00f3n, el que \"entra en acci\u00f3n\" cuando esta arranca. En nuestro caso adem\u00e1s es el \u00fanico controlador ya que nuestra aplicaci\u00f3n solo tiene una pantalla. Archivos de interfaz de usuario: los .storyboard , que constituyen el interfaz gr\u00e1fico de la aplicaci\u00f3n Main.storyboard : el interfaz en s\u00ed de la app , que luego editaremos LaunchScreen.storyboard : la pantalla que aparece mientras la aplicaci\u00f3n se est\u00e1 cargando Archivos de configuraci\u00f3n info.plist : propiedades de configuraci\u00f3n de la aplicaci\u00f3n, en un formato especial denominado plist que ya veremos con detalle en la asignatura de persistencia de datos. Por ahora nos basta con saber que es una lista de nombres y valores de propiedades y que los valores pueden ser num\u00e9ricos, cadenas o listas. Recursos: la carpeta Assets.xcassets , que es donde se colocan las im\u00e1genes y otros recursos de la aplicaci\u00f3n","title":"La plantilla creada por Xcode"},{"location":"s2/aplicaciones_ios/#creacion-de-la-interfaz-la-vista","text":"La interfaz de la aplicaci\u00f3n va a tener el siguiente aspecto, con un \"cartel\" explicando qu\u00e9 hace la app , un bot\u00f3n para solicitar la respuesta, y un campo en el que aparecer\u00e1 dicha respuesta. Como hemos comentado, la interfaz est\u00e1 definida en el archivo Main.storyboard . \u00c1brelo y ver\u00e1s que en el editor aparece una pantalla de iPhone vac\u00eda. La flecha que apunta desde la izquierda indica que es la pantalla inicial de la app . En la parte inferior del editor aparece un mensaje de View as: iPhone ... y el modelo que tengas seleccionado en ese momento. Pulsando sobre \u00e9l puedes cambiar el dispositivo y/o la orientaci\u00f3n. Debido a la distinta resoluci\u00f3n de cada dispositivo, el dise\u00f1o de pantalla que hagas aqu\u00ed en principio solo se va a ver bien en un dispositivo y una orientaci\u00f3n concretas . Para hacer interfaces que se adapten al dispositivo necesitas autolayout y traits que se ver\u00e1n con posterioridad en el curso. Vamos a a\u00f1adir los componentes de la interfaz. Si est\u00e1s en Xcode 10, en la parte superior derecha de la barra de botones ver\u00e1s un bot\u00f3n con un cuadrado dentro de un c\u00edrculo (el primer bot\u00f3n de esta zona). Al pulsar en \u00e9l se mostrar\u00e1 una ventana flotante con los componentes de interfaz de usuario. Este bot\u00f3n ha cambiado en las \u00faltimas versiones de Xcode. En la 11 tiene un s\u00edmbolo de un + . En la 9 e inferiores no exist\u00eda, el panel de componentes se ve\u00eda en la parte inferior derecha de la ventana, sin necesidad de pulsar ning\u00fan bot\u00f3n. Primero vamos a hacer el \"cartel\" con el mensaje de \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\". En iOS este tipo de componente es un Label . B\u00fascalo en el panel de componentes y arr\u00e1stralo a la pantalla que estamos dise\u00f1ando. Una vez colocada puedes hacer las operaciones habituales: moverla con el rat\u00f3n, cambiar su tama\u00f1o arrastrando los puntos de las esquinas o editar el contenido con doble clic. Cambia el texto del Label por un mensaje como \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\" Las propiedades de cualquier componente tambi\u00e9n se pueden cambiar en el panel de la derecha estando seleccionado el componente. Este panel est\u00e1 dividido en varias secciones, por las que se navega con los iconos de la parte superior. La que m\u00e1s nos interesa por el momento es la cuarta, denominada \"property inspector\". Cambia el n\u00famero de l\u00edneas a 2 para que el texto quepa en la pantalla. Cambia tambi\u00e9n la alineaci\u00f3n del texto a centrado para que quede mejor. Arrastra los dos componentes que faltan: un bot\u00f3n ( Button ) y otro Label que debes dejar con el texto vac\u00edo y donde aparecer\u00e1 el mensaje del adivino.","title":"Creaci\u00f3n de la interfaz (la vista)"},{"location":"s2/aplicaciones_ios/#implementacion-del-modelo","text":"En esta app el modelo lo \u00fanico que debe hacer es generar respuestas al azar a demanda. Lo podemos implementar en una clase Adivino que tenga un m\u00e9todo obtenerRespuesta Para colocar el c\u00f3digo de la clase debemos crear un archivo Swift: en Xcode, File > New > File... y en el asistente seleccionamos la plantilla \"Swift File\". Lo guardamos en la misma carpeta UAdivino 1 2 3 4 5 6 7 8 9 import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"Si\" , \"No\" , \"Ni de casualidad\" , \"\u00a1Por supuesto!\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } Podemos comprobar provisionalmente que el modelo funciona instanciando un Adivino cuando la app arranque y generando varias respuestas. Algo como: 1 2 3 4 let adivino = Adivino () for _ in 1. . 5 { print ( obtenerRespuesta ()) } Podemos insertar el c\u00f3digo anterior en la clase AppDelegate , dentro del primero de sus m\u00e9todos : application(_ application:, didFinishLaunchingWithOptions:) , que es el que se ejecuta al terminar de arrancar la aplicaci\u00f3n. Para ejecutar el proyecto pulsa al bot\u00f3n con el s\u00edmbolo de \"Play\" de la barra superior de Xcode, o bien selecciona la opci\u00f3n de men\u00fa Build > Run . Aparecer\u00e1 el simulador de iOS con la pantalla del iPhone, y en la consola de Xcode deber\u00edan aparecer los mensajes generados por el \"adivino\".","title":"Implementaci\u00f3n del modelo"},{"location":"s2/aplicaciones_ios/#implementacion-del-controlador","text":"En el controlador es donde vamos a hacer la comunicaci\u00f3n entre la vista y el modelo. Cada vez que se pulse el bot\u00f3n, el modelo debe generar una respuesta Esta respuesta se debe mostrar como texto del Label que ahora tenemos provisionalmente vac\u00edo.","title":"Implementaci\u00f3n del controlador"},{"location":"s2/aplicaciones_ios/#recibir-eventos-de-la-vista","text":"Para recibir eventos de la vista, necesitamos crear un action . Esto es lo que en otros entornos de programaci\u00f3n se conoce como listener , event handler , callback ,... Es simplemente un m\u00e9todo del controller al que el sistema llama cuando se produce un determinado evento sobre un componente de la interfaz. Para crear un action que vincule el bot\u00f3n y el controlador hay que seguir estos pasos en Xcode: Tener abierto el storyboard con la pantalla donde est\u00e1 el componente a vincular (en nuestro caso el bot\u00f3n) Pasar a editar en modo asistente , en el que se ve tanto la interfaz como el c\u00f3digo. En la esquina superior derecha hay dos grupos de tres botones. El primer grupo cambia el modo de edici\u00f3n. Nos interesa el segundo de los botones, con un icono de \"aros entrelazados\". Al pulsarlo, el editor se dividir\u00e1 para mostrar no solo la interfaz sino tambi\u00e9n el c\u00f3digo fuente del controller asociado. En el c\u00f3digo fuente del ViewController buscamos un \"hueco\" donde se pueda crear un m\u00e9todo que ser\u00e1 el llamado cuando se genere el evento. Finalmente, para vincular, hacer clic con el rat\u00f3n sobre el Button pero manteniendo pulsada tambi\u00e9n la tecla Ctrl . Sin soltar el rat\u00f3n, \"conectamos\" con el c\u00f3digo fuente del controller al punto del c\u00f3digo del ViewController que hemos decidido antes. Al soltar el bot\u00f3n del rat\u00f3n nos dar\u00e1 a elegir el tipo de conexi\u00f3n ( Connection ). Seleccionamos Action , escribimos el nombre que tendr\u00e1 el m\u00e9todo (por ejemplo botonPulsado ) y pulsamos el bot\u00f3n Connect . N\u00f3tese que el m\u00e9todo que se ha creado lleva una anotaci\u00f3n especial, @IBAction que indica que es un action . Adem\u00e1s a la izquierda del nombre sale un c\u00edrculo \"relleno\" que indica que est\u00e1 conectado a un componente de la interfaz. Si pasamos el rat\u00f3n por encima aparecer\u00e1 destacado el componente en fondo azul.","title":"Recibir eventos de la vista"},{"location":"s2/aplicaciones_ios/#llamar-al-modelo","text":"Ahora en el m\u00e9todo del action botonPulsado tenemos que llamar al modelo. En nuestro caso es tan simple como llamar a obtenerRespuesta() pero para eso necesitamos declarar una instancia del modelo en el controlador. Por ello le a\u00f1adimos una nueva propiedad: 1 2 3 4 5 6 7 //En el ViewController.swift class ViewController : UIViewController { let miAdivino = Adivino () ... Ahora tenemos que obtener una respuesta cuando se pulse el bot\u00f3n: 1 2 3 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () } pero todav\u00eda nos falta mostrarla en la interfaz. Para eso necesitamos conectar el controller con la vista","title":"Llamar al modelo"},{"location":"s2/aplicaciones_ios/#modificar-la-vista","text":"Por cada componente de la interfaz de usuario que queramos modificar desde el controller necesitamos definir un outlet , que no es m\u00e1s que una variable que referencia al componente. Pero la variable no la declaramos nosotros sino que se crea de forma parecida a como se crean los action : gr\u00e1ficamente, con el rat\u00f3n. Queremos conectar el controller con el Label que por ahora tiene texto vac\u00edo: De nuevo ponemos el editor en modo asistente, y buscamos un \"hueco\" apropiado en el c\u00f3digo fuente del controller donde se pueda definir la variable. Arrastramos con Ctrl + clic desde el bot\u00f3n al c\u00f3digo del controller pero ahora cuando soltemos el bot\u00f3n del rat\u00f3n y nos pregunte el tipo de conexi\u00f3n dejamos Outlet . Escribimos un nombre apropiado para la variable (por ejemplo labelRespuesta ) y pulsamos sobre Connect . Vemos que la variable reci\u00e9n creada es del tipo UILabel y lleva la anotaci\u00f3n @IBOutlet para indicar que es un outlet . Si miramos la documentaci\u00f3n de iOS veremos que a trav\u00e9s de la propiedad text tenemos acceso al texto del componente. Por lo que finalmente el m\u00e9todo del action que hemos hecho antes quedar\u00e1: 1 2 3 4 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = respuesta } Ya deber\u00eda funcionar todo correctamente, as\u00ed que ya podemos probar la app .","title":"Modificar la vista"},{"location":"s2/ejercicios/","text":"Ejercicios de introducci\u00f3n a las aplicaciones iOS (1,75 puntos) \u00b6 Desarrolla una app llamada iMoneda con la que se pueda \"lanzar\" una \"moneda virtual\" a ver si sale cara o cruz. La interfaz de la app ser\u00e1 muy sencilla y constar\u00e1 de: Un Button que al ser pulsado \"lanzar\u00e1\" la moneda. Un UIImageView para mostrar la imagen de la cara o de la cruz Un Label para mostrar el resultado en modo texto (\"cara\" o \"cruz\") La vista (0,5 puntos): Crea la interfaz arrastrando los componentes y coloc\u00e1ndolos donde creas conveniente. A\u00f1\u00e1dele al proyecto las im\u00e1genes de la cara y cruz de la moneda. Crea un image set en la carpeta Assets.xcassets llamado cara y otro llamado cruz y deja all\u00ed las im\u00e1genes correspondientes. Ver\u00e1s que est\u00e1n a @2x y @3x. El modelo (0,25 puntos): Crea: Un enumerado Tirada con los valores de cara y cruz Una clase Moneda con un \u00fanico m\u00e9todo lanzar() que devuelva una Tirada al azar El controlador (0,75 puntos): Define en \u00e9l una propiedad del tipo Moneda Crea dos outlet , uno para acceder al componente UIImageView y otro para el Label Crea un action que vincule el bot\u00f3n con alg\u00fan m\u00e9todo del ViewController En el c\u00f3digo del action : Usa el m\u00e9todo lanzar() de la Moneda para obtener una tirada Muestra el resultado en modo texto en el Label , (\"cara\", \"cruz\") Muestra la imagen apropiada Aclaraci\u00f3n: C\u00f3mo trabajar con im\u00e1genes Las im\u00e1genes se representan en iOS con objetos UIImage . Podemos obtener la imagen correspondiente a un recurso de los assets con su nombre: 1 let imagenCara = UIImage ( named : \"cara\" ) El UIImageView es un componente de interfaz que contiene una UIImage . Podemos cambiar la imagen asign\u00e1ndola a la propiedad image del UIImageView . 1 2 3 let imagenCara = UIImage ( named : \"cara\" ) //SUPONIENDO que el outlet que representa al UIImageView es imageView self . imageView . image = imagenCara (0,25 puntos) Finalmente a\u00f1\u00e1dele un icono a la app y una launch screen con los elementos que consideres. Puedes descargar iconos por ejemplo de icons8.com/icons Puedes cambiar el tama\u00f1o del icono con Vista Previa del Mac (Herramientas>Ajustar Tama\u00f1o...) o bien puedes generar autom\u00e1ticamente los tama\u00f1os necesarios con la ayuda de una web como por ejemplo appicon.co","title":"Ejercicios"},{"location":"s2/ejercicios/#ejercicios-de-introduccion-a-las-aplicaciones-ios-175-puntos","text":"Desarrolla una app llamada iMoneda con la que se pueda \"lanzar\" una \"moneda virtual\" a ver si sale cara o cruz. La interfaz de la app ser\u00e1 muy sencilla y constar\u00e1 de: Un Button que al ser pulsado \"lanzar\u00e1\" la moneda. Un UIImageView para mostrar la imagen de la cara o de la cruz Un Label para mostrar el resultado en modo texto (\"cara\" o \"cruz\") La vista (0,5 puntos): Crea la interfaz arrastrando los componentes y coloc\u00e1ndolos donde creas conveniente. A\u00f1\u00e1dele al proyecto las im\u00e1genes de la cara y cruz de la moneda. Crea un image set en la carpeta Assets.xcassets llamado cara y otro llamado cruz y deja all\u00ed las im\u00e1genes correspondientes. Ver\u00e1s que est\u00e1n a @2x y @3x. El modelo (0,25 puntos): Crea: Un enumerado Tirada con los valores de cara y cruz Una clase Moneda con un \u00fanico m\u00e9todo lanzar() que devuelva una Tirada al azar El controlador (0,75 puntos): Define en \u00e9l una propiedad del tipo Moneda Crea dos outlet , uno para acceder al componente UIImageView y otro para el Label Crea un action que vincule el bot\u00f3n con alg\u00fan m\u00e9todo del ViewController En el c\u00f3digo del action : Usa el m\u00e9todo lanzar() de la Moneda para obtener una tirada Muestra el resultado en modo texto en el Label , (\"cara\", \"cruz\") Muestra la imagen apropiada Aclaraci\u00f3n: C\u00f3mo trabajar con im\u00e1genes Las im\u00e1genes se representan en iOS con objetos UIImage . Podemos obtener la imagen correspondiente a un recurso de los assets con su nombre: 1 let imagenCara = UIImage ( named : \"cara\" ) El UIImageView es un componente de interfaz que contiene una UIImage . Podemos cambiar la imagen asign\u00e1ndola a la propiedad image del UIImageView . 1 2 3 let imagenCara = UIImage ( named : \"cara\" ) //SUPONIENDO que el outlet que representa al UIImageView es imageView self . imageView . image = imagenCara (0,25 puntos) Finalmente a\u00f1\u00e1dele un icono a la app y una launch screen con los elementos que consideres. Puedes descargar iconos por ejemplo de icons8.com/icons Puedes cambiar el tama\u00f1o del icono con Vista Previa del Mac (Herramientas>Ajustar Tama\u00f1o...) o bien puedes generar autom\u00e1ticamente los tama\u00f1os necesarios con la ayuda de una web como por ejemplo appicon.co","title":"Ejercicios de introducci\u00f3n a las aplicaciones iOS (1,75 puntos)"},{"location":"s2/recursos/","text":"Recursos en aplicaciones iOS \u00b6 Una app es m\u00e1s que c\u00f3digo, normalmente incluir\u00e1 el propio icono de la app , iconos adicionales para botones/ tab bars , im\u00e1genes, audios, videos o incluso texturas, stickers u otros muchos elementos dependiendo del tipo de app . Todos estos elementos reciben el nombre gen\u00e9rico de recursos . En el proyecto de Xcode podemos ver una carpeta llamada Assets.xcassets que es el asset catalog de la app. Sirve para almacenar los recursos que necesitemos usar en la app. En la documentaci\u00f3n de Apple podemos consultar el uso del editor del asset catalog , aqu\u00ed de momento nos vamos a limitar a ver c\u00f3mo a\u00f1adir un icono para la app y una serie de im\u00e1genes. Resoluciones en dispositivos iOS \u00b6 Antes de ver c\u00f3mo a\u00f1adir im\u00e1genes o iconos necesitamos discutir un poco el tema de la resoluci\u00f3n. El \"parque\" de dispositivos iOS en funcionamiento tiene resoluciones de pantalla muy distintas entre s\u00ed, bien por la diferencia de antig\u00fcedad o bien por tener la pantalla de un tama\u00f1o muy distinto. En dispositivos m\u00e1s o menos actuales van desde los 640x1136 del iPhone SE hasta los 2048x2732 pixeles del iPad Pro de 12.9 pulgadas ( fuente , tambi\u00e9n pod\u00e9is consultarlo en iOSRes ). Y eso sin contar los dispositivos antiguos de la \u00e9poca pre-\"retina display\". Si nuestra aplicaci\u00f3n usa im\u00e1gen es es normal que las im\u00e1genes que en un dispositivo de resoluci\u00f3n \"baja\" se ven bien se vean demasiado peque\u00f1as en uno de \"alta\" o bien que si iOS las escala para que ocupen el mismo porcentaje de pantalla se vean pixeladas en dispositivos de alta resoluci\u00f3n. Por eso deber\u00edamos a\u00f1adir cada imagen que use nuestra app a distintas resoluciones. Para simplificar el desarrollo, en iOS se consideran solo 3 resoluciones distintas, llamadas en la documentaci\u00f3n @1x , @2x y @3x . Como su propio nombre indica las dos \u00faltimas son m\u00faltiplos de la primera. Es decir que si tenemos una imagen de 100x100 pixeles como base, deber\u00edamos tener la misma a 200x200 para @2x y 300x300 para @3x . Evidentemente no se trata de que cojamos la misma imagen de 100x100 y la escalemos al doble o triple, ya que se ver\u00edan pixeladas, sino al contrario, que partamos de una imagen en alta resoluci\u00f3n y vayamos generando versiones m\u00e1s peque\u00f1as de la misma. En las \"Human Interface Guidelines\" de Apple tenemos m\u00e1s informaci\u00f3n sobre la resoluci\u00f3n de im\u00e1genes e iconos , adem\u00e1s de consejos de dise\u00f1o y usabilidad. En el mercado ya no quedan pr\u00e1cticamente dispositivos de resoluci\u00f3n @1x y de hecho no la necesitaremos salvo que queramos hacer compatible nuestra app con iOS9 o inferior. Icono de la aplicaci\u00f3n \u00b6 En el asset catalog hay un elemento denominado appIcon donde colocar el icono de la aplicaci\u00f3n. Debido a la diferente resoluci\u00f3n de los dispositivos iOS, como ya hemos visto, hay que proporcionar el icono en distintos tama\u00f1os, desde 120x120 para los iPhone a @2x hasta 180x180 a @3x. Por si fuera poco adem\u00e1s hay otros tama\u00f1os que se usan cuando nuestra app sale en los resultados de Spotlight (la b\u00fasqueda integrada en el dispositivo) , si tiene sus propio apartado de ajustes en los ajustes del sistema, cuando aparece en las notificaciones, etc. Si seleccionamos el appIcon veremos una plantilla donde \"dejar caer\" los iconos de cada tama\u00f1o necesario. Hay que tener en cuenta que deben estar en formato PNG sin transparencia. Para m\u00e1s informaci\u00f3n consultad el apartado correspondiente de las Human Interface Guidelines. Cuidado, el proyecto dar\u00e1 error de compilaci\u00f3n si usamos iconos que no son del tama\u00f1o esperado. No obstante si no disponemos de alguno de los tama\u00f1os el sistema lo obtendr\u00e1 escalando el que haya. Im\u00e1genes \u00b6 Como cada imagen deber\u00eda estar al menos en tama\u00f1o @2x y @3x , al a\u00f1adir una imagen a los recursos en realidad estamos a\u00f1adiendo un conjunto de im\u00e1genes o image set . Para crear un image set se puede pulsar el bot\u00f3n de + que aparece en la esquina inferior izquierda del editor del asset catalog y seleccionar New Image set . Por defecto se llamar\u00e1 simplemente Image pero podemos cambiarlo de nombre haciendo doble clic sobre el nombre actual. En el c\u00f3digo de la app podemos usar el nombre dado en el asset catalog para cargar la imagen: 1 let imagenLibro = UIImage ( named : \"libro\" ) Pista : si las im\u00e1genes tienen un nombre que acaba en @2x o @3x (algo como libro@2x.png ), xCode las usar\u00e1 autom\u00e1ticamente para la resoluci\u00f3n deseada. Xcode tomar\u00e1 la de @1x simplemente como la que no tenga nada especial en el nombre. En el Finder (el administrador de archivos ) podemos seleccionar entonces tres im\u00e1genes juntas (haciendo clic + Cmd para que al seleccionar una no se pierda la anterior) y \"dejarlas caer\" juntas en el image set para que cada una se coloque en su hueco. Launch screen \u00b6 Es una pantalla que iOS mostrar\u00e1 al inicio de la carga de la app . En otros sistemas como Android o el mismo MacOS muchas aplicaciones tienen una splash screen , que aparece al comienzo con un logo, una imagen, los cr\u00e9ditos de la app , etc. Sin embargo seg\u00fan las Human Interface Guidelines de Apple una launch screen no es nada de eso, sino que debe ser lo m\u00e1s parecida posible a la primera pantalla de la app . De este modo se le dar\u00e1 la impresi\u00f3n al usuario de que la aplicaci\u00f3n se carga r\u00e1pidamente. Es decir, la launch screen es una especie de versi\u00f3n \"est\u00e1tica\" o \"de cart\u00f3n piedra\" de la primera pantalla de la app . Evidentemente si la app muestra contenido din\u00e1mico este contenido no puede formar parte de la launch screen pero s\u00ed podemos por ejemplo colocar ciertos elementos de la interfaz como botones, cuadros de b\u00fasqueda, tab bars*, etc, como puede verse en este ejemplo incluido en la documentaci\u00f3n de Apple: En xCode la launch screen se dise\u00f1a como una pantalla m\u00e1s de la aplicaci\u00f3n, en el LaunchScreen.storyboard , arrastrando componentes de interfaz como en cualquier otra pantalla, aunque los elementos que se incluyan no van a ser interactivos. No se recomienda incluir textos ya que no van a poder adaptarse al idioma del dispositivo.","title":"Recursos en aplicaciones iOS"},{"location":"s2/recursos/#recursos-en-aplicaciones-ios","text":"Una app es m\u00e1s que c\u00f3digo, normalmente incluir\u00e1 el propio icono de la app , iconos adicionales para botones/ tab bars , im\u00e1genes, audios, videos o incluso texturas, stickers u otros muchos elementos dependiendo del tipo de app . Todos estos elementos reciben el nombre gen\u00e9rico de recursos . En el proyecto de Xcode podemos ver una carpeta llamada Assets.xcassets que es el asset catalog de la app. Sirve para almacenar los recursos que necesitemos usar en la app. En la documentaci\u00f3n de Apple podemos consultar el uso del editor del asset catalog , aqu\u00ed de momento nos vamos a limitar a ver c\u00f3mo a\u00f1adir un icono para la app y una serie de im\u00e1genes.","title":"Recursos en aplicaciones iOS"},{"location":"s2/recursos/#resoluciones-en-dispositivos-ios","text":"Antes de ver c\u00f3mo a\u00f1adir im\u00e1genes o iconos necesitamos discutir un poco el tema de la resoluci\u00f3n. El \"parque\" de dispositivos iOS en funcionamiento tiene resoluciones de pantalla muy distintas entre s\u00ed, bien por la diferencia de antig\u00fcedad o bien por tener la pantalla de un tama\u00f1o muy distinto. En dispositivos m\u00e1s o menos actuales van desde los 640x1136 del iPhone SE hasta los 2048x2732 pixeles del iPad Pro de 12.9 pulgadas ( fuente , tambi\u00e9n pod\u00e9is consultarlo en iOSRes ). Y eso sin contar los dispositivos antiguos de la \u00e9poca pre-\"retina display\". Si nuestra aplicaci\u00f3n usa im\u00e1gen es es normal que las im\u00e1genes que en un dispositivo de resoluci\u00f3n \"baja\" se ven bien se vean demasiado peque\u00f1as en uno de \"alta\" o bien que si iOS las escala para que ocupen el mismo porcentaje de pantalla se vean pixeladas en dispositivos de alta resoluci\u00f3n. Por eso deber\u00edamos a\u00f1adir cada imagen que use nuestra app a distintas resoluciones. Para simplificar el desarrollo, en iOS se consideran solo 3 resoluciones distintas, llamadas en la documentaci\u00f3n @1x , @2x y @3x . Como su propio nombre indica las dos \u00faltimas son m\u00faltiplos de la primera. Es decir que si tenemos una imagen de 100x100 pixeles como base, deber\u00edamos tener la misma a 200x200 para @2x y 300x300 para @3x . Evidentemente no se trata de que cojamos la misma imagen de 100x100 y la escalemos al doble o triple, ya que se ver\u00edan pixeladas, sino al contrario, que partamos de una imagen en alta resoluci\u00f3n y vayamos generando versiones m\u00e1s peque\u00f1as de la misma. En las \"Human Interface Guidelines\" de Apple tenemos m\u00e1s informaci\u00f3n sobre la resoluci\u00f3n de im\u00e1genes e iconos , adem\u00e1s de consejos de dise\u00f1o y usabilidad. En el mercado ya no quedan pr\u00e1cticamente dispositivos de resoluci\u00f3n @1x y de hecho no la necesitaremos salvo que queramos hacer compatible nuestra app con iOS9 o inferior.","title":"Resoluciones en dispositivos iOS"},{"location":"s2/recursos/#icono-de-la-aplicacion","text":"En el asset catalog hay un elemento denominado appIcon donde colocar el icono de la aplicaci\u00f3n. Debido a la diferente resoluci\u00f3n de los dispositivos iOS, como ya hemos visto, hay que proporcionar el icono en distintos tama\u00f1os, desde 120x120 para los iPhone a @2x hasta 180x180 a @3x. Por si fuera poco adem\u00e1s hay otros tama\u00f1os que se usan cuando nuestra app sale en los resultados de Spotlight (la b\u00fasqueda integrada en el dispositivo) , si tiene sus propio apartado de ajustes en los ajustes del sistema, cuando aparece en las notificaciones, etc. Si seleccionamos el appIcon veremos una plantilla donde \"dejar caer\" los iconos de cada tama\u00f1o necesario. Hay que tener en cuenta que deben estar en formato PNG sin transparencia. Para m\u00e1s informaci\u00f3n consultad el apartado correspondiente de las Human Interface Guidelines. Cuidado, el proyecto dar\u00e1 error de compilaci\u00f3n si usamos iconos que no son del tama\u00f1o esperado. No obstante si no disponemos de alguno de los tama\u00f1os el sistema lo obtendr\u00e1 escalando el que haya.","title":"Icono de la aplicaci\u00f3n"},{"location":"s2/recursos/#imagenes","text":"Como cada imagen deber\u00eda estar al menos en tama\u00f1o @2x y @3x , al a\u00f1adir una imagen a los recursos en realidad estamos a\u00f1adiendo un conjunto de im\u00e1genes o image set . Para crear un image set se puede pulsar el bot\u00f3n de + que aparece en la esquina inferior izquierda del editor del asset catalog y seleccionar New Image set . Por defecto se llamar\u00e1 simplemente Image pero podemos cambiarlo de nombre haciendo doble clic sobre el nombre actual. En el c\u00f3digo de la app podemos usar el nombre dado en el asset catalog para cargar la imagen: 1 let imagenLibro = UIImage ( named : \"libro\" ) Pista : si las im\u00e1genes tienen un nombre que acaba en @2x o @3x (algo como libro@2x.png ), xCode las usar\u00e1 autom\u00e1ticamente para la resoluci\u00f3n deseada. Xcode tomar\u00e1 la de @1x simplemente como la que no tenga nada especial en el nombre. En el Finder (el administrador de archivos ) podemos seleccionar entonces tres im\u00e1genes juntas (haciendo clic + Cmd para que al seleccionar una no se pierda la anterior) y \"dejarlas caer\" juntas en el image set para que cada una se coloque en su hueco.","title":"Im\u00e1genes"},{"location":"s2/recursos/#launch-screen","text":"Es una pantalla que iOS mostrar\u00e1 al inicio de la carga de la app . En otros sistemas como Android o el mismo MacOS muchas aplicaciones tienen una splash screen , que aparece al comienzo con un logo, una imagen, los cr\u00e9ditos de la app , etc. Sin embargo seg\u00fan las Human Interface Guidelines de Apple una launch screen no es nada de eso, sino que debe ser lo m\u00e1s parecida posible a la primera pantalla de la app . De este modo se le dar\u00e1 la impresi\u00f3n al usuario de que la aplicaci\u00f3n se carga r\u00e1pidamente. Es decir, la launch screen es una especie de versi\u00f3n \"est\u00e1tica\" o \"de cart\u00f3n piedra\" de la primera pantalla de la app . Evidentemente si la app muestra contenido din\u00e1mico este contenido no puede formar parte de la launch screen pero s\u00ed podemos por ejemplo colocar ciertos elementos de la interfaz como botones, cuadros de b\u00fasqueda, tab bars*, etc, como puede verse en este ejemplo incluido en la documentaci\u00f3n de Apple: En xCode la launch screen se dise\u00f1a como una pantalla m\u00e1s de la aplicaci\u00f3n, en el LaunchScreen.storyboard , arrastrando componentes de interfaz como en cualquier otra pantalla, aunque los elementos que se incluyan no van a ser interactivos. No se recomienda incluir textos ya que no van a poder adaptarse al idioma del dispositivo.","title":"Launch screen"},{"location":"s3/concurrencia/","text":"Concurrencia en iOS \u00b6 En muchas aplicaciones iOS necesitaremos efectuar varias operaciones de modo concurrente. El caso m\u00e1s t\u00edpico es cuando queremos hacer una operaci\u00f3n costosa en tiempo pero no queremos que se paralice la interfaz de usuario hasta que termine la operaci\u00f3n. APIs de concurrencia \u00b6 Tanto iOS como OSX tienen varios APIs con distinto nivel de abstracci\u00f3n para trabajar con operaciones concurrentes: En el nivel m\u00e1s bajo estar\u00eda trabajar directamente con threads , representados por la clase del sistema NSThread . La mayor\u00eda de aplicaciones no necesitan la flexibilidad que nos proporciona trabajar a este nivel, o no merece la pena teniendo en cuenta lo complicado del c\u00f3digo con respecto a las otras alternativas. En un nivel intermedio tenemos un framework de Apple llamado grand central dispatch o GCD. Tiene un nivel de abstracci\u00f3n razonable para la mayor\u00eda de aplicaciones, de hecho en Internet pod\u00e9is encontrar multitud de tutoriales y ejemplos que lo usan (pod\u00e9is verlo por la llamada a una funci\u00f3n llamada dispatch_async , que pone en marcha c\u00f3digo concurrente). En el nivel m\u00e1s alto de abstracci\u00f3n est\u00e1n las colas de operaciones (aunque no es mucho mayor que GCD). Es el API que vamos a usar aqu\u00ed ya que es el m\u00e1s sencillo de usar. Cada API usa internamente los otros de m\u00e1s bajo nivel. Es decir, GCD usa internamente threads y las colas de operaciones usan internamente GCD. Colas de operaciones \u00b6 En una cola de operaciones podemos a\u00f1adir trabajos concurrentes. Manejarlas a nivel b\u00e1sico es muy sencillo. Son instancias de OperationQueue y para a\u00f1adir un trabajo a una solo hay que llamar a addOperation() . Hay diversas formas de pasar el c\u00f3digo a ejecutar. La m\u00e1s c\u00f3moda es en forma de clausura . Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 let cola = OperationQueue (); cola . addOperation () { print ( \"comienza operaci\u00f3n 1...\" ); sleep ( 5 ) print ( \"...hecho 1\" ); } cola . addOperation () { print ( \"comienza operacion 2...\" ) sleep ( 3 ) print ( \"...hecho 2\" ); }; NOTA: podemos ver el resultado del c\u00f3digo anterior a\u00f1adi\u00e9ndolo por ejemplo a una aplicaci\u00f3n iOS. Si usamos una aplicaci\u00f3n de l\u00ednea de comandos tendremos que a\u00f1adir algo al c\u00f3digo ya que si no el programa principal terminar\u00eda inmediatamente despu\u00e9s del segundo addOperation y no se ver\u00edan los mensajes en pantalla. Por ejemplo podemos llamar a cola.waitUntilAllOperationsAreFinished() que como su propio nombre indica se espera hasta que todas las operaciones a\u00f1adidas a la cola han terminado. Si ejecutamos el c\u00f3digo anterior veremos que aunque el c\u00f3digo de la primera clausura comienza a ejecutarse primero, aun as\u00ed termina despu\u00e9s, es decir, ambas \"tareas\" se est\u00e1n ejecutando en paralelo y no secuencialmente. Por defecto este es el comportamiento de las colas de operaciones, aunque podemos definir dependencias entre tareas, de modo que se ejecute una solo cuando ha acabado otra determinada. Incluso podemos limitar el n\u00famero de operaciones concurrentes que se pueden ejecutar en una cola. La cola de operaciones principal de una app \u00b6 En aplicaciones iOS est\u00e1 predefinida lo que se llama la \"cola de operaciones principal\", que es la que ejecuta el c\u00f3digo que actualiza la interfaz de usuario. Podemos acceder a ella con OperationQueue.main . Esta cola de operaciones no puede ejecutar operaciones concurrentes para evitar inconsistencias, que se podr\u00edan dar si dos tareas estuvieran modificando simult\u00e1neamente el mismo elemento de la interfaz. Podemos comprobar esto imprimiendo el valor de OperationQueue.main.maxConcurrentOperationCount , que veremos que vale 1, es decir, no hay operaciones concurrentes en esta cola. Cuando necesitamos ejecutar una operaci\u00f3n especialmente costosa en tiempo no es recomendable bloquear la interfaz de usuario, por lo que se suele crear una cola de operaciones aparte de la principal y ejecutar la operaci\u00f3n en esta. Un problema adicional es que normalmente esta operaci\u00f3n costosa debe actualizar la interfaz de usuario al finalizar, pero ning\u00fan hilo de ejecuci\u00f3n que no sea el principal debe actualizar la interfaz de usuario, ya que lo contrario podr\u00eda producir resultados inconsistentes. Esto lo podemos resolver accediendo a la cola de operaciones principal con OperationQueue.main . Por ejemplo: 1 2 3 4 5 6 7 8 9 10 let background = OperationQueue (); background . addOperation () { print ( \"Comienzo mi duro trabajo...\" ) sleep ( 4 ) print ( \"...terminado!\" ) print ( \"pero yo NO DEBO tocar la interfaz\" ) OperationQueue . main . addOperation () { print ( \"Soy main. Desde aqu\u00ed s\u00ed se puede actualizar la interfaz\" ) } }","title":"Concurrencia en iOS"},{"location":"s3/concurrencia/#concurrencia-en-ios","text":"En muchas aplicaciones iOS necesitaremos efectuar varias operaciones de modo concurrente. El caso m\u00e1s t\u00edpico es cuando queremos hacer una operaci\u00f3n costosa en tiempo pero no queremos que se paralice la interfaz de usuario hasta que termine la operaci\u00f3n.","title":"Concurrencia en iOS"},{"location":"s3/concurrencia/#apis-de-concurrencia","text":"Tanto iOS como OSX tienen varios APIs con distinto nivel de abstracci\u00f3n para trabajar con operaciones concurrentes: En el nivel m\u00e1s bajo estar\u00eda trabajar directamente con threads , representados por la clase del sistema NSThread . La mayor\u00eda de aplicaciones no necesitan la flexibilidad que nos proporciona trabajar a este nivel, o no merece la pena teniendo en cuenta lo complicado del c\u00f3digo con respecto a las otras alternativas. En un nivel intermedio tenemos un framework de Apple llamado grand central dispatch o GCD. Tiene un nivel de abstracci\u00f3n razonable para la mayor\u00eda de aplicaciones, de hecho en Internet pod\u00e9is encontrar multitud de tutoriales y ejemplos que lo usan (pod\u00e9is verlo por la llamada a una funci\u00f3n llamada dispatch_async , que pone en marcha c\u00f3digo concurrente). En el nivel m\u00e1s alto de abstracci\u00f3n est\u00e1n las colas de operaciones (aunque no es mucho mayor que GCD). Es el API que vamos a usar aqu\u00ed ya que es el m\u00e1s sencillo de usar. Cada API usa internamente los otros de m\u00e1s bajo nivel. Es decir, GCD usa internamente threads y las colas de operaciones usan internamente GCD.","title":"APIs de concurrencia"},{"location":"s3/concurrencia/#colas-de-operaciones","text":"En una cola de operaciones podemos a\u00f1adir trabajos concurrentes. Manejarlas a nivel b\u00e1sico es muy sencillo. Son instancias de OperationQueue y para a\u00f1adir un trabajo a una solo hay que llamar a addOperation() . Hay diversas formas de pasar el c\u00f3digo a ejecutar. La m\u00e1s c\u00f3moda es en forma de clausura . Por ejemplo: 1 2 3 4 5 6 7 8 9 10 11 let cola = OperationQueue (); cola . addOperation () { print ( \"comienza operaci\u00f3n 1...\" ); sleep ( 5 ) print ( \"...hecho 1\" ); } cola . addOperation () { print ( \"comienza operacion 2...\" ) sleep ( 3 ) print ( \"...hecho 2\" ); }; NOTA: podemos ver el resultado del c\u00f3digo anterior a\u00f1adi\u00e9ndolo por ejemplo a una aplicaci\u00f3n iOS. Si usamos una aplicaci\u00f3n de l\u00ednea de comandos tendremos que a\u00f1adir algo al c\u00f3digo ya que si no el programa principal terminar\u00eda inmediatamente despu\u00e9s del segundo addOperation y no se ver\u00edan los mensajes en pantalla. Por ejemplo podemos llamar a cola.waitUntilAllOperationsAreFinished() que como su propio nombre indica se espera hasta que todas las operaciones a\u00f1adidas a la cola han terminado. Si ejecutamos el c\u00f3digo anterior veremos que aunque el c\u00f3digo de la primera clausura comienza a ejecutarse primero, aun as\u00ed termina despu\u00e9s, es decir, ambas \"tareas\" se est\u00e1n ejecutando en paralelo y no secuencialmente. Por defecto este es el comportamiento de las colas de operaciones, aunque podemos definir dependencias entre tareas, de modo que se ejecute una solo cuando ha acabado otra determinada. Incluso podemos limitar el n\u00famero de operaciones concurrentes que se pueden ejecutar en una cola.","title":"Colas de operaciones"},{"location":"s3/concurrencia/#la-cola-de-operaciones-principal-de-una-app","text":"En aplicaciones iOS est\u00e1 predefinida lo que se llama la \"cola de operaciones principal\", que es la que ejecuta el c\u00f3digo que actualiza la interfaz de usuario. Podemos acceder a ella con OperationQueue.main . Esta cola de operaciones no puede ejecutar operaciones concurrentes para evitar inconsistencias, que se podr\u00edan dar si dos tareas estuvieran modificando simult\u00e1neamente el mismo elemento de la interfaz. Podemos comprobar esto imprimiendo el valor de OperationQueue.main.maxConcurrentOperationCount , que veremos que vale 1, es decir, no hay operaciones concurrentes en esta cola. Cuando necesitamos ejecutar una operaci\u00f3n especialmente costosa en tiempo no es recomendable bloquear la interfaz de usuario, por lo que se suele crear una cola de operaciones aparte de la principal y ejecutar la operaci\u00f3n en esta. Un problema adicional es que normalmente esta operaci\u00f3n costosa debe actualizar la interfaz de usuario al finalizar, pero ning\u00fan hilo de ejecuci\u00f3n que no sea el principal debe actualizar la interfaz de usuario, ya que lo contrario podr\u00eda producir resultados inconsistentes. Esto lo podemos resolver accediendo a la cola de operaciones principal con OperationQueue.main . Por ejemplo: 1 2 3 4 5 6 7 8 9 10 let background = OperationQueue (); background . addOperation () { print ( \"Comienzo mi duro trabajo...\" ) sleep ( 4 ) print ( \"...terminado!\" ) print ( \"pero yo NO DEBO tocar la interfaz\" ) OperationQueue . main . addOperation () { print ( \"Soy main. Desde aqu\u00ed s\u00ed se puede actualizar la interfaz\" ) } }","title":"La cola de operaciones principal de una app"},{"location":"s3/ejercicios/","text":"Ejercicios (2,5 puntos) \u00b6 Vamos a realizar una peque\u00f1a aplicaci\u00f3n para consultar el tiempo meteorol\u00f3gico. La aplicaci\u00f3n terminada tendr\u00e1 el aspecto que se muestra en la figura Salvo que ya est\u00e9s metiendo todos los ejercicios de la asignatura en un \u00fanico repositorio git, aseg\u00farate de que cuando creas el proyecto Xcode crea un repositorio de git para \u00e9l (3\u00aa pantalla del asistente), lo necesitar\u00e1s para ir haciendo commit de los distintos apartados del ejercicio. A. Creaci\u00f3n de la interfaz (0,5 puntos) \u00b6 Como se ve en la figura, la interfaz tiene 4 componentes, seleccionables mediante el panel de componentes gr\u00e1ficos de la esquina inferior derecha de Xcode: - Una imagen ( image view ), para mostrar un icono con el estado del tiempo. Inicialmente estar\u00e1 vac\u00eda - Una etiqueta ( label ), para mostrar el estado del tiempo de forma textual. Inicialmente estar\u00e1 vac\u00eda - Un campo de texto de 1 l\u00ednea, para teclear la localidad ( text field ) - Un bot\u00f3n pulsable ( button ) que pondr\u00e1 \u201cConsultar tiempo\u201d Como ya hiciste en la aplicaci\u00f3n de UADivino, conecta los componentes de la interfaz con el ViewController : Outlets: recuerda que son componentes de la interfaz a los que quieres acceder para consultar/modificar sus propiedades. Se crean con Ctrl+arrastrar desde el componente hasta el ViewController.swift . Crea outlets para la imagen, la etiqueta y el campo de texto Action: recuerda que sirve para ejecutar tu c\u00f3digo en respuesta a eventos sobre la interfaz. Se crean igual que los outlets . Cada action genera un m\u00e9todo. Crea un action para el bot\u00f3n de \u201cconsultar tiempo\u201d B. Consulta del tiempo en la consola de depuraci\u00f3n (0,5 puntos) \u00b6 El estado del tiempo nos lo da un servicio externo, Openweathermap , que adem\u00e1s de la web ofrece la API que vamos a usar. Para obtener el tiempo en una localidad, con los mensajes traducidos a espa\u00f1ol y usando unidades del sistema m\u00e9trico, hay que hacer una petici\u00f3n HTTP a la URL https://api.openweathermap.org/data/2.5/weather?lang=es&units=metric&app_id=<TU_API_KEY>&q= concaten\u00e1ndole la localidad a buscar. El par\u00e1metro app_id debe contener nuestra API key (nuestra clave de desarrollador, pod\u00e9is daros de alta para obtener la vuestra propia). Por ejemplo si clicas en este enlace ver\u00e1s el tiempo para Alicante. El API devuelve los datos en formato JSON, que habr\u00e1 que analizar para extraer la informaci\u00f3n que nos interese. Para hacer una petici\u00f3n HTTP en iOS podemos usar la clase URLSession . Copia el siguiente c\u00f3digo en el ViewController.swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let OW_URL_BASE = \"https://api.openweathermap.org/data/2.5/weather?lang=es&units=metric&appid=1adb13e22f23c3de1ca37f3be90763a9&q=\" let OW_URL_BASE_ICON = \"https://openweathermap.org/img/w/\" func consultarTiempo ( localidad : String ) { let urlString = OW_URL_BASE + localidad let url = URL ( string : urlString ) let dataTask = URLSession . shared . dataTask ( with : url !) { datos , respuesta , error in let jsonStd = try ! JSONSerialization . jsonObject ( with : datos !, options : JSONSerialization . ReadingOptions . mutableContainers ) as ! [ String : AnyObject ] let weather = jsonStd [ \"weather\" ] ! as ! [ AnyObject ] let currentWeather = weather [ 0 ] as ! [ String : AnyObject ] let descripcion = currentWeather [ \"description\" ] ! as ! String print ( \"El tiempo en \\( localidad ) es: \\( descripcion ) \" ) //Estamos baj\u00e1ndonos la imagen pero todav\u00eda no la usamos let icono = currentWeather [ \"icon\" ] ! as ! String if let urlIcono = URL ( string : self . OW_URL_BASE_ICON + icono + \".png\" ) { let datosIcono = try ! Data ( contentsOf : urlIcono ) let imagenIcono = UIImage ( data : datosIcono ) } } dataTask . resume () } Aunque no est\u00e9 expl\u00edcito en el c\u00f3digo anterior, URLSession lanza la petici\u00f3n en background cuando se ejecuta el resume y cuando llega la respuesta del servidor se ejecuta el c\u00f3digo de la clausura En el action asociado al bot\u00f3n de \"consultar tiempo\" debes obtener el texto del campo de texto (propiedad text ) y llamar a la funci\u00f3n consultarTiempo que acabas de copiar y pegar, pas\u00e1ndole este dato. Si pruebas la aplicaci\u00f3n y todo ha ido bien, deber\u00eda aparecer el estado del tiempo en la consola. Haz un commit con el comentario \"Apartado B\" C. Mostrar el tiempo en la interfaz (0,5 puntos) \u00b6 A\u00f1ade c\u00f3digo que muestre el tiempo en la interfaz del m\u00f3vil. Lo primero que puedes hacer es mostrarle al usuario que se est\u00e1 haciendo una operaci\u00f3n de red, esto lo puedes hacer con un spinner que puedes hacer aparecer autom\u00e1ticamente en la barra de status de la parte superior Para poner el spinner har\u00edas: 1 UIApplication . shared . isNetworkActivityIndicatorVisible = true y para quitarlo, idem pero asign\u00e1ndole false ATENCION: el spinner no aparecer\u00e1 en grande sino en \"peque\u00f1ito\" y solo en la barra superior, en sesiones posteriores veremos c\u00f3mo poner un spinner m\u00e1s grande en la parte de la pantalla que queramos. Pon en marcha el spinner justo antes del dataTask.resume() y luego p\u00e1ralo una vez se haya cargado el icono del tiempo (la l\u00ednea let imagenIcono = UIImage(data: datosIcono) ). Pero recuerda que La interfaz solo se puede \"tocar\" desde la cola de operaciones principal. La llamada a dataTask.resume() est\u00e1 en esta cola, pero el c\u00f3digo que parsea los datos del tiempo est\u00e1 en background , como hemos dicho. Tendr\u00e1s que acceder desde all\u00ed a la cola principal para parar el spinner . Si el spinner no se llega a ver porque la respuesta del servidor llega demasiado r\u00e1pido, puedes probar a poner un sleep(segundos) con el n\u00famero de segundos que quieras, para parar artificialmente la ejecuci\u00f3n y comprobar si aparece el spinner . \u00a1Una vez comprobado, quita el sleep ! Una vez solucionado el tema del spinner a\u00f1ade c\u00f3digo para actualizar el label y la image . De nuevo recuerda que estas operaciones debes hacerlas desde la cola principal. Haz un commit poniendo como comentario \"Apartado C\". D. Gesti\u00f3n de errores en Swift (0,5) \u00b6 Ver\u00e1s que el c\u00f3digo que has copiado y pegado tiene un par de llamadas con try! . Aqu\u00ed lo que estamos diciendo es que estas funciones podr\u00edan fallar pero Sabemos que no lo van a hacer (lo que no es muy realista que digamos). Quita la admiraci\u00f3n de los try y mira qu\u00e9 sucede. \u00bfC\u00f3mo podr\u00edas arreglar el c\u00f3digo para que compile y funcione como antes sin volver a poner el ! ?. Hazlo y haz un commit poniendo como comentario \"apartado D\". E. Delegates y protocols (0,5) \u00b6 Vamos a hacer que en el campo de texto no se puedan introducir caracteres num\u00e9ricos . En iOS los campos de texto pueden tener un objeto delegate al que el campo de texto le va \"avisando\" de las cosas que ocurren en su \"ciclo de vida\" (se ha empezado a escribir, se ha terminado de escribir, se ha insertado texto ...). Este objeto debe ser conforme al protocolo UITextFieldDelegate . Aprovecharemos cuando el campo nos avise de que el usuario est\u00e1 escribiendo texto para rechazarlo si es num\u00e9rico. Vamos a crear una clase el TextoDelegate.swift que act\u00fae delegate del campo de texto, para ello hay que: Crear la clase con File > New > File , elegir como tipo Swift File Escribir en este fichero la clase TextoDelegate indicando que es una clase conforme al protocolo UITextFieldDelegate (recuerda que se pone como si fuera herencia, con dos puntos). Adem\u00e1s debe ser conforme al protocolo de NSObjectProtocol , pero lo m\u00e1s sencillo para conseguir esto es heredando de NSObject . En resumen, la cabecera de nuestra clase ser\u00e1 algo como: 1 2 3 class TextoDelegate : NSObject , UITextFieldDelegate { } - En el m\u00e9todo viewDidLoad del ViewController le decimos al campo de texto qui\u00e9n es su delegate (fijamos su propiedad delegate a una nueva instancia de TextoDelegate ) - El campo de texto nos avisar\u00e1 de que el usuario ha escrito un car\u00e1cter nuevo (o ha borrado uno), llamando a un m\u00e9todo 1 2 3 func textField ( _ textField : UITextField , shouldChangeCharactersIn range : NSRange , replacementString string : String ) -> Bool { //c\u00f3digo del m\u00e9todo } Tendremos que definir este m\u00e9todo en TextoDelegate y escribir su c\u00f3digo, teniendo en cuenta que el par\u00e1metro string es el nuevo texto que el usuario pretende insertar. Y que si devolvemos true dejamos que el texto se inserte, pero si devolvemos false no lo permitimos. Puedes intentar comprobar si se puede convertir el par\u00e1metro string a entero y si se puede devuelve false (no dejamos escribir). En caso contrario, devuelve true . Algo como: 1 2 3 4 5 6 7 8 9 var valor = Int ( string ) //Si se ha podido convertir es que era num\u00e9rico if let valor = valor { return false } //si al convertir da nil es que no era num\u00e9rico else { return true } Una vez hecho y comprobado que funciona, haz un commit con el comentario \"Apartado E\"","title":"Ejercicios"},{"location":"s3/ejercicios/#ejercicios-25-puntos","text":"Vamos a realizar una peque\u00f1a aplicaci\u00f3n para consultar el tiempo meteorol\u00f3gico. La aplicaci\u00f3n terminada tendr\u00e1 el aspecto que se muestra en la figura Salvo que ya est\u00e9s metiendo todos los ejercicios de la asignatura en un \u00fanico repositorio git, aseg\u00farate de que cuando creas el proyecto Xcode crea un repositorio de git para \u00e9l (3\u00aa pantalla del asistente), lo necesitar\u00e1s para ir haciendo commit de los distintos apartados del ejercicio.","title":"Ejercicios (2,5 puntos)"},{"location":"s3/ejercicios/#a-creacion-de-la-interfaz-05-puntos","text":"Como se ve en la figura, la interfaz tiene 4 componentes, seleccionables mediante el panel de componentes gr\u00e1ficos de la esquina inferior derecha de Xcode: - Una imagen ( image view ), para mostrar un icono con el estado del tiempo. Inicialmente estar\u00e1 vac\u00eda - Una etiqueta ( label ), para mostrar el estado del tiempo de forma textual. Inicialmente estar\u00e1 vac\u00eda - Un campo de texto de 1 l\u00ednea, para teclear la localidad ( text field ) - Un bot\u00f3n pulsable ( button ) que pondr\u00e1 \u201cConsultar tiempo\u201d Como ya hiciste en la aplicaci\u00f3n de UADivino, conecta los componentes de la interfaz con el ViewController : Outlets: recuerda que son componentes de la interfaz a los que quieres acceder para consultar/modificar sus propiedades. Se crean con Ctrl+arrastrar desde el componente hasta el ViewController.swift . Crea outlets para la imagen, la etiqueta y el campo de texto Action: recuerda que sirve para ejecutar tu c\u00f3digo en respuesta a eventos sobre la interfaz. Se crean igual que los outlets . Cada action genera un m\u00e9todo. Crea un action para el bot\u00f3n de \u201cconsultar tiempo\u201d","title":"A. Creaci\u00f3n de la interfaz (0,5 puntos)"},{"location":"s3/ejercicios/#b-consulta-del-tiempo-en-la-consola-de-depuracion-05-puntos","text":"El estado del tiempo nos lo da un servicio externo, Openweathermap , que adem\u00e1s de la web ofrece la API que vamos a usar. Para obtener el tiempo en una localidad, con los mensajes traducidos a espa\u00f1ol y usando unidades del sistema m\u00e9trico, hay que hacer una petici\u00f3n HTTP a la URL https://api.openweathermap.org/data/2.5/weather?lang=es&units=metric&app_id=<TU_API_KEY>&q= concaten\u00e1ndole la localidad a buscar. El par\u00e1metro app_id debe contener nuestra API key (nuestra clave de desarrollador, pod\u00e9is daros de alta para obtener la vuestra propia). Por ejemplo si clicas en este enlace ver\u00e1s el tiempo para Alicante. El API devuelve los datos en formato JSON, que habr\u00e1 que analizar para extraer la informaci\u00f3n que nos interese. Para hacer una petici\u00f3n HTTP en iOS podemos usar la clase URLSession . Copia el siguiente c\u00f3digo en el ViewController.swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let OW_URL_BASE = \"https://api.openweathermap.org/data/2.5/weather?lang=es&units=metric&appid=1adb13e22f23c3de1ca37f3be90763a9&q=\" let OW_URL_BASE_ICON = \"https://openweathermap.org/img/w/\" func consultarTiempo ( localidad : String ) { let urlString = OW_URL_BASE + localidad let url = URL ( string : urlString ) let dataTask = URLSession . shared . dataTask ( with : url !) { datos , respuesta , error in let jsonStd = try ! JSONSerialization . jsonObject ( with : datos !, options : JSONSerialization . ReadingOptions . mutableContainers ) as ! [ String : AnyObject ] let weather = jsonStd [ \"weather\" ] ! as ! [ AnyObject ] let currentWeather = weather [ 0 ] as ! [ String : AnyObject ] let descripcion = currentWeather [ \"description\" ] ! as ! String print ( \"El tiempo en \\( localidad ) es: \\( descripcion ) \" ) //Estamos baj\u00e1ndonos la imagen pero todav\u00eda no la usamos let icono = currentWeather [ \"icon\" ] ! as ! String if let urlIcono = URL ( string : self . OW_URL_BASE_ICON + icono + \".png\" ) { let datosIcono = try ! Data ( contentsOf : urlIcono ) let imagenIcono = UIImage ( data : datosIcono ) } } dataTask . resume () } Aunque no est\u00e9 expl\u00edcito en el c\u00f3digo anterior, URLSession lanza la petici\u00f3n en background cuando se ejecuta el resume y cuando llega la respuesta del servidor se ejecuta el c\u00f3digo de la clausura En el action asociado al bot\u00f3n de \"consultar tiempo\" debes obtener el texto del campo de texto (propiedad text ) y llamar a la funci\u00f3n consultarTiempo que acabas de copiar y pegar, pas\u00e1ndole este dato. Si pruebas la aplicaci\u00f3n y todo ha ido bien, deber\u00eda aparecer el estado del tiempo en la consola. Haz un commit con el comentario \"Apartado B\"","title":"B. Consulta del tiempo en la consola de depuraci\u00f3n (0,5 puntos)"},{"location":"s3/ejercicios/#c-mostrar-el-tiempo-en-la-interfaz-05-puntos","text":"A\u00f1ade c\u00f3digo que muestre el tiempo en la interfaz del m\u00f3vil. Lo primero que puedes hacer es mostrarle al usuario que se est\u00e1 haciendo una operaci\u00f3n de red, esto lo puedes hacer con un spinner que puedes hacer aparecer autom\u00e1ticamente en la barra de status de la parte superior Para poner el spinner har\u00edas: 1 UIApplication . shared . isNetworkActivityIndicatorVisible = true y para quitarlo, idem pero asign\u00e1ndole false ATENCION: el spinner no aparecer\u00e1 en grande sino en \"peque\u00f1ito\" y solo en la barra superior, en sesiones posteriores veremos c\u00f3mo poner un spinner m\u00e1s grande en la parte de la pantalla que queramos. Pon en marcha el spinner justo antes del dataTask.resume() y luego p\u00e1ralo una vez se haya cargado el icono del tiempo (la l\u00ednea let imagenIcono = UIImage(data: datosIcono) ). Pero recuerda que La interfaz solo se puede \"tocar\" desde la cola de operaciones principal. La llamada a dataTask.resume() est\u00e1 en esta cola, pero el c\u00f3digo que parsea los datos del tiempo est\u00e1 en background , como hemos dicho. Tendr\u00e1s que acceder desde all\u00ed a la cola principal para parar el spinner . Si el spinner no se llega a ver porque la respuesta del servidor llega demasiado r\u00e1pido, puedes probar a poner un sleep(segundos) con el n\u00famero de segundos que quieras, para parar artificialmente la ejecuci\u00f3n y comprobar si aparece el spinner . \u00a1Una vez comprobado, quita el sleep ! Una vez solucionado el tema del spinner a\u00f1ade c\u00f3digo para actualizar el label y la image . De nuevo recuerda que estas operaciones debes hacerlas desde la cola principal. Haz un commit poniendo como comentario \"Apartado C\".","title":"C. Mostrar el tiempo en la interfaz (0,5 puntos)"},{"location":"s3/ejercicios/#d-gestion-de-errores-en-swift-05","text":"Ver\u00e1s que el c\u00f3digo que has copiado y pegado tiene un par de llamadas con try! . Aqu\u00ed lo que estamos diciendo es que estas funciones podr\u00edan fallar pero Sabemos que no lo van a hacer (lo que no es muy realista que digamos). Quita la admiraci\u00f3n de los try y mira qu\u00e9 sucede. \u00bfC\u00f3mo podr\u00edas arreglar el c\u00f3digo para que compile y funcione como antes sin volver a poner el ! ?. Hazlo y haz un commit poniendo como comentario \"apartado D\".","title":"D. Gesti\u00f3n de errores en Swift (0,5)"},{"location":"s3/ejercicios/#e-delegates-y-protocols-05","text":"Vamos a hacer que en el campo de texto no se puedan introducir caracteres num\u00e9ricos . En iOS los campos de texto pueden tener un objeto delegate al que el campo de texto le va \"avisando\" de las cosas que ocurren en su \"ciclo de vida\" (se ha empezado a escribir, se ha terminado de escribir, se ha insertado texto ...). Este objeto debe ser conforme al protocolo UITextFieldDelegate . Aprovecharemos cuando el campo nos avise de que el usuario est\u00e1 escribiendo texto para rechazarlo si es num\u00e9rico. Vamos a crear una clase el TextoDelegate.swift que act\u00fae delegate del campo de texto, para ello hay que: Crear la clase con File > New > File , elegir como tipo Swift File Escribir en este fichero la clase TextoDelegate indicando que es una clase conforme al protocolo UITextFieldDelegate (recuerda que se pone como si fuera herencia, con dos puntos). Adem\u00e1s debe ser conforme al protocolo de NSObjectProtocol , pero lo m\u00e1s sencillo para conseguir esto es heredando de NSObject . En resumen, la cabecera de nuestra clase ser\u00e1 algo como: 1 2 3 class TextoDelegate : NSObject , UITextFieldDelegate { } - En el m\u00e9todo viewDidLoad del ViewController le decimos al campo de texto qui\u00e9n es su delegate (fijamos su propiedad delegate a una nueva instancia de TextoDelegate ) - El campo de texto nos avisar\u00e1 de que el usuario ha escrito un car\u00e1cter nuevo (o ha borrado uno), llamando a un m\u00e9todo 1 2 3 func textField ( _ textField : UITextField , shouldChangeCharactersIn range : NSRange , replacementString string : String ) -> Bool { //c\u00f3digo del m\u00e9todo } Tendremos que definir este m\u00e9todo en TextoDelegate y escribir su c\u00f3digo, teniendo en cuenta que el par\u00e1metro string es el nuevo texto que el usuario pretende insertar. Y que si devolvemos true dejamos que el texto se inserte, pero si devolvemos false no lo permitimos. Puedes intentar comprobar si se puede convertir el par\u00e1metro string a entero y si se puede devuelve false (no dejamos escribir). En caso contrario, devuelve true . Algo como: 1 2 3 4 5 6 7 8 9 var valor = Int ( string ) //Si se ha podido convertir es que era num\u00e9rico if let valor = valor { return false } //si al convertir da nil es que no era num\u00e9rico else { return true } Una vez hecho y comprobado que funciona, haz un commit con el comentario \"Apartado E\"","title":"E. Delegates y protocols (0,5)"},{"location":"s3/intro_swift_2/","text":"M\u00e1s sobre Swift \u00b6 Clausuras \u00b6 Una clausura es un bloque de c\u00f3digo que puede ser tratado como un objeto . Es algo as\u00ed como una funci\u00f3n an\u00f3nima con una sintaxis simplificada. A muchos m\u00e9todos de las bibliotecas del sistema se les pasa una funci\u00f3n para hacer su tarea. En lugar de eso se puede usar una clausura, lo que simplifica la sintaxis. Veamos un ejemplo. El m\u00e9todo sorted ordena un array. Debemos pasarle una funci\u00f3n que, dados dos datos, devuelva true si est\u00e1n ya \"en el orden correcto\". Podemos hacerlo as\u00ed: 1 2 3 4 5 6 func ascendente ( a : String , b : String )-> Bool { return a < b ; } let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : ascendente ) La funci\u00f3n ascendente se puede definir en forma de clausura como: 1 {( a : String , b : String )-> Bool in return a < b } Con clausuras definimos el c\u00f3digo donde lo necesitamos , no aparte, quedando m\u00e1s legible 1 2 3 let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : {( a : String , b : String )-> Bool in return a < b }) ord Simplificando la definici\u00f3n \u00b6 Podemos acortar todav\u00eda m\u00e1s la sintaxis de definici\u00f3n de las clausuras: Inferencia de tipos : en ocasiones el compilador puede inferir la signatura (tipos de par\u00e1metros y tipo de retorno), como en nuestro ejemplo, ya que a sorted se le debe pasar una funci\u00f3n con dos par\u00e1metros String y que debe devolver un Bool . Tambi\u00e9n podemos omitir los par\u00e9ntesis y la flecha 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in return a < b })) return impl\u00edcito : si la clausura solo contiene una expresi\u00f3n se asume que devuelve su resultado 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in a < b })) Par\u00e1metros por defecto por defecto los par\u00e1metros reciben como nombre $i donde i es el n\u00famero (empieza en 0) 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted ( by : { $0 < $1 }) Trailing closures : si una clausura es el \u00faltimo par\u00e1metro de un m\u00e9todo, se puede omitir su nombre y poner fuera de los par\u00e9ntesis. Esto de por s\u00ed no acorta la sintaxis, pero facilita la legibilidad si el c\u00f3digo de la clausura ocupa varias l\u00edneas 1 2 3 4 5 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted () { a , b in return a < b } Estructuras \u00b6 En Swift tambi\u00e9n existen struct s. En lenguajes como C++, clases y structs son completamente diferentes. En swift se parecen mucho: Ambas pueden contener propiedades y m\u00e9todos Definen inicializadores (== constructores ) Se instancian de forma muy parecida Se pueden definir como conformes a protocolos (parecidos a interfaces de Java) 1 2 3 4 5 6 7 8 9 struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) print ( p1 . descripcion ) Como vemos, en el c\u00f3digo anterior no hemos definido ning\u00fan inicializador y sin embargo lo hemos llamado para construir un Libro . En structs el compilador define autom\u00e1ticamente un inicializador (llamado memberwise initializer ) que acepta las variables miembro como par\u00e1metros. Sin embargo, hay funcionalidades que tienen las clases pero no las estructuras: Herencia Deinicializadores (== destructores) Varias variables pueden referenciar a la misma instancia. Es decir, como ahora veremos, los objetos se pasan por referencia y las estructuras por valor. Valor vs. referencia \u00b6 Las estructuras se pasan por valor y los objetos por referencia. Eso quiere decir que si asignamos una estructura a otra variable o la pasamos como par\u00e1metro de una funci\u00f3n estamos haciendo una copia , pero si asignamos objetos, son punteros que apuntan en realidad al mismo objeto . Por ejemplo con estructuras 1 2 3 4 5 6 7 8 9 10 11 struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) var p2 = p1 p1 . x = - 1.0 ; print ( p2 . descripcion ) //cambiar p1 no cambia el valor de p2 Si Punto2D pasara de ser una estructura a una clase, pasar\u00edan dos cosas: Ya no tendr\u00edamos autom\u00e1ticamente definido el memberwise initializer Al asignar o pasar como par\u00e1metro estar\u00edamos referenciando la misma instancia . 1 2 3 4 5 6 7 8 9 10 11 12 13 class Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D () p1 . x = 1 p1 . y = 0 var p2 = p1 //ahora p1 y p2 apuntan A LA MISMA INSTANCIA p1 . x = - 1.0 ; print ( p2 . descripcion ) //(-1.0, 0.0) Escoger estructuras vs. clases \u00b6 Se recomienda usar estructuras cuando se cumplan estas condiciones: La finalidad principal es simplemente encapsular unos cuantos datos La copia por valor no va a causar problemas Las propiedades de la estructura son tambi\u00e9n valores y no referencias (o sea, la estructura no contiene objetos) No necesitamos herencia En Swift, muchos tipos de la librer\u00eda est\u00e1ndar como los String , los arrays y los diccionarios se implementan como estructuras , de modo que se pasan por valor y no por referencia. Gesti\u00f3n de errores \u00b6 En Swift representamos un error con cualquier elemento que sea conforme al protocolo Error . Los enums son especialmente apropiados para representar errores 1 2 3 4 5 enum ErrorImpresora : Error { case sinPapel case sinTinta ( color : String ) case enLLamas } NOTA: ya veremos qu\u00e9 son los protocolos, por el momento basta con saber que son como los interfaces en Java Para se\u00f1alar que se ha producido un error, lo lanzamos con throw 1 throw ErrorImpresora . sinTinta ( color : \"Rojo\" ) Ante un error tenemos cuatro opciones: Propagarlo \"hacia arriba\" Capturarlo con un do..catch Manejarlo como un opcional Suponer que todo va a ir bien Propagar errores \u00b6 Podemos indicar que una funci\u00f3n/m\u00e9todo lanza errores marc\u00e1ndola con throws . El error llegar\u00e1 a la funci\u00f3n/m\u00e9todo que haya llamado a esta, que a su vez podr\u00eda propagarlo hacia arriba. N\u00f3tese que si llamamos a un m\u00e9todo marcado con throws debemos preceder la llamada de la palabra clave try Veamos un ejemplo, suponiendo el enum ErrorImpresora definido antes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Impresora { var temperatura = 0.0 //Marcado con \"throws\" porque lanza un error \"hacia arriba\" func verificarEstado () throws -> String { if self . temperatura > 80 { throw ErrorImpresora . enLlamas } else return \"OK\" } } //Lanza un error \"hacia arriba\" func miFuncion () throws { var miImpresora = Impresora () miImpresora . temperatura = 100 //Para llamar a un m\u00e9todo marcado con \"throws\" tenemos que usar \"try\" try miImpresora . verificarEstado () } try miFuncion () En el ejemplo anterior, el error acaba subiendo hasta el nivel superior y el programa abortar\u00eda. Capturar errores \u00b6 Podemos capturar un error envolviendo la llamada a los m\u00e9todos que los lanzan en un bloque do...catch , que es muy similar al try...catch de Java o de otros lenguajes 1 2 3 4 5 6 7 8 do { var miImpresora = Impresora () miImpresora . temperatura = 100 try miImpresora . verificarEstado () } catch ErrorImpresora . enLlamas { print ( \"SOCORROOOOOOOO!!!\" ) } Manejar un error como opcional \u00b6 En lugar de usar try en la llamada a un m\u00e9todo que puede generar un error podemos emplear la \"variante\" try? . Lo que hace esta forma es capturar el error y transformar el resultado del m\u00e9todo en un opcional, que podemos tratar con el patr\u00f3n habitual if let ... . Si ha habido un error el m\u00e9todo nos devolver\u00e1 nil 1 2 3 4 5 6 7 8 var miImpresora = Impresora () miImpresora . temperatura = 100 if let estado = try ? miImpresora . verificarEstado () { print ( \"Perfecto. El estado es \\( estado ) \" ) } else { print ( \"Ha habido un error\" ) } Ignorar los errores \u00b6 Podemos usar la \"variante\" try! cuando no queremos gestionar el error porque es cr\u00edtico y si se da no tiene sentido continuar con el programa. Si el error se produjera se lanzar\u00eda inmediatamente una excepci\u00f3n en tiempo de ejecuci\u00f3n y el programa abortar\u00eda. Protocolos \u00b6 El concepto de protocolo en Swift es similar al de interface en Java. Un protocolo es una plantilla de m\u00e9todos, propiedades y otros requisitos que definen una tarea o funcionalidad particular. Un protocolo no proporciona ninguna implementaci\u00f3n, sino que debe ser adoptado por una clase, un struct o una enumeraci\u00f3n. Un protocolo proporciona un tipo y se puede usar en muchos sitios donde se permiten usar tipos: - Como el tipo de un par\u00e1metro o de un valor devuelto por una funci\u00f3n, un m\u00e9todo o un inicializador. - Como el tipo de una constante, variable o propiedad. - Como el tipo de los \u00edtems de un array, diccionario u otros contenedores. Los protocolos se declaran con la palabra clave protocol . Dentro del protocolo especificamos las signaturas de los m\u00e9todos y si las propiedades computadas son de lectura y/o escritura. Si un m\u00e9todo modifica alguna propiedad del objeto debemos indicarlo con mutating 1 2 3 4 5 6 7 protocol ProtocoloEjemplo { func saludar ()-> String //Propiedad calculada: debemos decir si es gettable y/o settable var descripcion : String { get set } //si la funci\u00f3n muta alg\u00fan dato, debemos especificarlo mutating func reggaetonizar () } Para indicar que una clase adopta un protocolo usamos la misma notaci\u00f3n que con la herencia 1 2 3 4 5 6 7 8 9 10 11 12 13 class MiClase : ProtocoloEjemplo { var descripcion = \"Mi Clase\" func saludar ()-> String { return \"Hola soy \" + self . descripcion } func reggaetonizar () { self . descripcion += \" ya t\u00fa sabes\" } } let mc = MiClase () mc . reggaetonizar () mc . saludar () //Hola, soy Mi Clase ya t\u00fa sabes Al igual que en Java una clase solo puede heredar de una superclase, pero puede implementar uno o varios protocolos. En la primera l\u00ednea de la clase, donde indicamos herencia-protocolos, hay que poner la superclase antes que los protocolos para evitar ambig\u00fcedades 1 2 3 class MiOtraClase : Superclase , ProtocoloUno , ProtocoloDos { //Definici\u00f3n de la clase } El patr\u00f3n de dise\u00f1o \"delegaci\u00f3n\" \u00b6 Delegaci\u00f3n es un patr\u00f3n de dise\u00f1o que permite a una clase o estructura pasar (o delegar ) alguna de sus responsabilidades a una instancia de otro tipo. Este patr\u00f3n est\u00e1 relacionado con la idea de composici\u00f3n : cuando queremos que un objeto realice una tarea incluimos en \u00e9l otro objeto capaz de realizarla. Este patr\u00f3n es uno de los m\u00e1s comunes en los frameworks del sistema en iOS/OSX, ya que permite que las clases del sistema hagan su trabajo apoy\u00e1ndose en c\u00f3digo proporcionado por el programador. La idea es que la clase del sistema contendr\u00e1 una referencia a un objeto proporcionado por el desarrollador y que implementa una serie de funcionalidades. Para que el compilador pueda chequear que efectivamente las implementa, este objeto debe adoptar un determinado protocolo. Por ejemplo, como veremos en la asignatura de interfaz de usuario, las tablas en iOS se implementan habitualmente con la clase del sistema UITableView . N\u00f3tese que cuando en iOS hablamos de tablas en realidad estamos hablando de listas de datos (o visto de otro modo, tablas de una \u00fanica columna), que son omnipresentes en las interfaces de usuario de apps m\u00f3viles. UITableView necesariamente es una clase gen\u00e9rica. Pero se tiene que \"adaptar\" a los datos concretos que queremos mostrar. Lo que se hace en iOS es usar el patr\u00f3n delegaci\u00f3n. Un UITableView tiene una propiedad delegate que debe ser un objeto que adopte el protocolo UITableViewDelegate . Este protocolo incluye por ejemplo un m\u00e9todo que devuelve el contenido de una fila sabiendo su n\u00famero. De este modo, cuando iOS quiere dibujar la tabla en pantalla lo que va haciendo es \"pidi\u00e9ndole\" las filas una por una al delegate . Una alternativa que podr\u00eda haber adoptado Apple es hacer que el desarrollador creara una clase que heredara de UITableView y que tuviera que implementar en ella los m\u00e9todos apropiados, pero esta alternativa es m\u00e1s problem\u00e1tica, ya que como sabemos una clase solo puede heredar de otra, y si tuvi\u00e9ramos que heredar de UITableView para tener esta funcionalidad ya no podr\u00edamos heredar de otra clase. Este patr\u00f3n no se usa \u00fanicamente con tablas sino que est\u00e1 \"por todas partes\" en los frameworks del sistema en iOS. Ya vimos por ejemplo el ApplicationDelegate cuando creamos nuestra primera aplicaci\u00f3n, pero hay muchos m\u00e1s ejemplos.","title":"M\u00e1s sobre Swift"},{"location":"s3/intro_swift_2/#mas-sobre-swift","text":"","title":"M\u00e1s sobre Swift"},{"location":"s3/intro_swift_2/#clausuras","text":"Una clausura es un bloque de c\u00f3digo que puede ser tratado como un objeto . Es algo as\u00ed como una funci\u00f3n an\u00f3nima con una sintaxis simplificada. A muchos m\u00e9todos de las bibliotecas del sistema se les pasa una funci\u00f3n para hacer su tarea. En lugar de eso se puede usar una clausura, lo que simplifica la sintaxis. Veamos un ejemplo. El m\u00e9todo sorted ordena un array. Debemos pasarle una funci\u00f3n que, dados dos datos, devuelva true si est\u00e1n ya \"en el orden correcto\". Podemos hacerlo as\u00ed: 1 2 3 4 5 6 func ascendente ( a : String , b : String )-> Bool { return a < b ; } let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : ascendente ) La funci\u00f3n ascendente se puede definir en forma de clausura como: 1 {( a : String , b : String )-> Bool in return a < b } Con clausuras definimos el c\u00f3digo donde lo necesitamos , no aparte, quedando m\u00e1s legible 1 2 3 let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : {( a : String , b : String )-> Bool in return a < b }) ord","title":"Clausuras"},{"location":"s3/intro_swift_2/#simplificando-la-definicion","text":"Podemos acortar todav\u00eda m\u00e1s la sintaxis de definici\u00f3n de las clausuras: Inferencia de tipos : en ocasiones el compilador puede inferir la signatura (tipos de par\u00e1metros y tipo de retorno), como en nuestro ejemplo, ya que a sorted se le debe pasar una funci\u00f3n con dos par\u00e1metros String y que debe devolver un Bool . Tambi\u00e9n podemos omitir los par\u00e9ntesis y la flecha 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in return a < b })) return impl\u00edcito : si la clausura solo contiene una expresi\u00f3n se asume que devuelve su resultado 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in a < b })) Par\u00e1metros por defecto por defecto los par\u00e1metros reciben como nombre $i donde i es el n\u00famero (empieza en 0) 1 2 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted ( by : { $0 < $1 }) Trailing closures : si una clausura es el \u00faltimo par\u00e1metro de un m\u00e9todo, se puede omitir su nombre y poner fuera de los par\u00e9ntesis. Esto de por s\u00ed no acorta la sintaxis, pero facilita la legibilidad si el c\u00f3digo de la clausura ocupa varias l\u00edneas 1 2 3 4 5 let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted () { a , b in return a < b }","title":"Simplificando la definici\u00f3n"},{"location":"s3/intro_swift_2/#estructuras","text":"En Swift tambi\u00e9n existen struct s. En lenguajes como C++, clases y structs son completamente diferentes. En swift se parecen mucho: Ambas pueden contener propiedades y m\u00e9todos Definen inicializadores (== constructores ) Se instancian de forma muy parecida Se pueden definir como conformes a protocolos (parecidos a interfaces de Java) 1 2 3 4 5 6 7 8 9 struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) print ( p1 . descripcion ) Como vemos, en el c\u00f3digo anterior no hemos definido ning\u00fan inicializador y sin embargo lo hemos llamado para construir un Libro . En structs el compilador define autom\u00e1ticamente un inicializador (llamado memberwise initializer ) que acepta las variables miembro como par\u00e1metros. Sin embargo, hay funcionalidades que tienen las clases pero no las estructuras: Herencia Deinicializadores (== destructores) Varias variables pueden referenciar a la misma instancia. Es decir, como ahora veremos, los objetos se pasan por referencia y las estructuras por valor.","title":"Estructuras"},{"location":"s3/intro_swift_2/#valor-vs-referencia","text":"Las estructuras se pasan por valor y los objetos por referencia. Eso quiere decir que si asignamos una estructura a otra variable o la pasamos como par\u00e1metro de una funci\u00f3n estamos haciendo una copia , pero si asignamos objetos, son punteros que apuntan en realidad al mismo objeto . Por ejemplo con estructuras 1 2 3 4 5 6 7 8 9 10 11 struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) var p2 = p1 p1 . x = - 1.0 ; print ( p2 . descripcion ) //cambiar p1 no cambia el valor de p2 Si Punto2D pasara de ser una estructura a una clase, pasar\u00edan dos cosas: Ya no tendr\u00edamos autom\u00e1ticamente definido el memberwise initializer Al asignar o pasar como par\u00e1metro estar\u00edamos referenciando la misma instancia . 1 2 3 4 5 6 7 8 9 10 11 12 13 class Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D () p1 . x = 1 p1 . y = 0 var p2 = p1 //ahora p1 y p2 apuntan A LA MISMA INSTANCIA p1 . x = - 1.0 ; print ( p2 . descripcion ) //(-1.0, 0.0)","title":"Valor vs. referencia"},{"location":"s3/intro_swift_2/#escoger-estructuras-vs-clases","text":"Se recomienda usar estructuras cuando se cumplan estas condiciones: La finalidad principal es simplemente encapsular unos cuantos datos La copia por valor no va a causar problemas Las propiedades de la estructura son tambi\u00e9n valores y no referencias (o sea, la estructura no contiene objetos) No necesitamos herencia En Swift, muchos tipos de la librer\u00eda est\u00e1ndar como los String , los arrays y los diccionarios se implementan como estructuras , de modo que se pasan por valor y no por referencia.","title":"Escoger estructuras vs. clases"},{"location":"s3/intro_swift_2/#gestion-de-errores","text":"En Swift representamos un error con cualquier elemento que sea conforme al protocolo Error . Los enums son especialmente apropiados para representar errores 1 2 3 4 5 enum ErrorImpresora : Error { case sinPapel case sinTinta ( color : String ) case enLLamas } NOTA: ya veremos qu\u00e9 son los protocolos, por el momento basta con saber que son como los interfaces en Java Para se\u00f1alar que se ha producido un error, lo lanzamos con throw 1 throw ErrorImpresora . sinTinta ( color : \"Rojo\" ) Ante un error tenemos cuatro opciones: Propagarlo \"hacia arriba\" Capturarlo con un do..catch Manejarlo como un opcional Suponer que todo va a ir bien","title":"Gesti\u00f3n de errores"},{"location":"s3/intro_swift_2/#propagar-errores","text":"Podemos indicar que una funci\u00f3n/m\u00e9todo lanza errores marc\u00e1ndola con throws . El error llegar\u00e1 a la funci\u00f3n/m\u00e9todo que haya llamado a esta, que a su vez podr\u00eda propagarlo hacia arriba. N\u00f3tese que si llamamos a un m\u00e9todo marcado con throws debemos preceder la llamada de la palabra clave try Veamos un ejemplo, suponiendo el enum ErrorImpresora definido antes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Impresora { var temperatura = 0.0 //Marcado con \"throws\" porque lanza un error \"hacia arriba\" func verificarEstado () throws -> String { if self . temperatura > 80 { throw ErrorImpresora . enLlamas } else return \"OK\" } } //Lanza un error \"hacia arriba\" func miFuncion () throws { var miImpresora = Impresora () miImpresora . temperatura = 100 //Para llamar a un m\u00e9todo marcado con \"throws\" tenemos que usar \"try\" try miImpresora . verificarEstado () } try miFuncion () En el ejemplo anterior, el error acaba subiendo hasta el nivel superior y el programa abortar\u00eda.","title":"Propagar errores"},{"location":"s3/intro_swift_2/#capturar-errores","text":"Podemos capturar un error envolviendo la llamada a los m\u00e9todos que los lanzan en un bloque do...catch , que es muy similar al try...catch de Java o de otros lenguajes 1 2 3 4 5 6 7 8 do { var miImpresora = Impresora () miImpresora . temperatura = 100 try miImpresora . verificarEstado () } catch ErrorImpresora . enLlamas { print ( \"SOCORROOOOOOOO!!!\" ) }","title":"Capturar errores"},{"location":"s3/intro_swift_2/#manejar-un-error-como-opcional","text":"En lugar de usar try en la llamada a un m\u00e9todo que puede generar un error podemos emplear la \"variante\" try? . Lo que hace esta forma es capturar el error y transformar el resultado del m\u00e9todo en un opcional, que podemos tratar con el patr\u00f3n habitual if let ... . Si ha habido un error el m\u00e9todo nos devolver\u00e1 nil 1 2 3 4 5 6 7 8 var miImpresora = Impresora () miImpresora . temperatura = 100 if let estado = try ? miImpresora . verificarEstado () { print ( \"Perfecto. El estado es \\( estado ) \" ) } else { print ( \"Ha habido un error\" ) }","title":"Manejar un error como opcional"},{"location":"s3/intro_swift_2/#ignorar-los-errores","text":"Podemos usar la \"variante\" try! cuando no queremos gestionar el error porque es cr\u00edtico y si se da no tiene sentido continuar con el programa. Si el error se produjera se lanzar\u00eda inmediatamente una excepci\u00f3n en tiempo de ejecuci\u00f3n y el programa abortar\u00eda.","title":"Ignorar los errores"},{"location":"s3/intro_swift_2/#protocolos","text":"El concepto de protocolo en Swift es similar al de interface en Java. Un protocolo es una plantilla de m\u00e9todos, propiedades y otros requisitos que definen una tarea o funcionalidad particular. Un protocolo no proporciona ninguna implementaci\u00f3n, sino que debe ser adoptado por una clase, un struct o una enumeraci\u00f3n. Un protocolo proporciona un tipo y se puede usar en muchos sitios donde se permiten usar tipos: - Como el tipo de un par\u00e1metro o de un valor devuelto por una funci\u00f3n, un m\u00e9todo o un inicializador. - Como el tipo de una constante, variable o propiedad. - Como el tipo de los \u00edtems de un array, diccionario u otros contenedores. Los protocolos se declaran con la palabra clave protocol . Dentro del protocolo especificamos las signaturas de los m\u00e9todos y si las propiedades computadas son de lectura y/o escritura. Si un m\u00e9todo modifica alguna propiedad del objeto debemos indicarlo con mutating 1 2 3 4 5 6 7 protocol ProtocoloEjemplo { func saludar ()-> String //Propiedad calculada: debemos decir si es gettable y/o settable var descripcion : String { get set } //si la funci\u00f3n muta alg\u00fan dato, debemos especificarlo mutating func reggaetonizar () } Para indicar que una clase adopta un protocolo usamos la misma notaci\u00f3n que con la herencia 1 2 3 4 5 6 7 8 9 10 11 12 13 class MiClase : ProtocoloEjemplo { var descripcion = \"Mi Clase\" func saludar ()-> String { return \"Hola soy \" + self . descripcion } func reggaetonizar () { self . descripcion += \" ya t\u00fa sabes\" } } let mc = MiClase () mc . reggaetonizar () mc . saludar () //Hola, soy Mi Clase ya t\u00fa sabes Al igual que en Java una clase solo puede heredar de una superclase, pero puede implementar uno o varios protocolos. En la primera l\u00ednea de la clase, donde indicamos herencia-protocolos, hay que poner la superclase antes que los protocolos para evitar ambig\u00fcedades 1 2 3 class MiOtraClase : Superclase , ProtocoloUno , ProtocoloDos { //Definici\u00f3n de la clase }","title":"Protocolos"},{"location":"s3/intro_swift_2/#el-patron-de-diseno-delegacion","text":"Delegaci\u00f3n es un patr\u00f3n de dise\u00f1o que permite a una clase o estructura pasar (o delegar ) alguna de sus responsabilidades a una instancia de otro tipo. Este patr\u00f3n est\u00e1 relacionado con la idea de composici\u00f3n : cuando queremos que un objeto realice una tarea incluimos en \u00e9l otro objeto capaz de realizarla. Este patr\u00f3n es uno de los m\u00e1s comunes en los frameworks del sistema en iOS/OSX, ya que permite que las clases del sistema hagan su trabajo apoy\u00e1ndose en c\u00f3digo proporcionado por el programador. La idea es que la clase del sistema contendr\u00e1 una referencia a un objeto proporcionado por el desarrollador y que implementa una serie de funcionalidades. Para que el compilador pueda chequear que efectivamente las implementa, este objeto debe adoptar un determinado protocolo. Por ejemplo, como veremos en la asignatura de interfaz de usuario, las tablas en iOS se implementan habitualmente con la clase del sistema UITableView . N\u00f3tese que cuando en iOS hablamos de tablas en realidad estamos hablando de listas de datos (o visto de otro modo, tablas de una \u00fanica columna), que son omnipresentes en las interfaces de usuario de apps m\u00f3viles. UITableView necesariamente es una clase gen\u00e9rica. Pero se tiene que \"adaptar\" a los datos concretos que queremos mostrar. Lo que se hace en iOS es usar el patr\u00f3n delegaci\u00f3n. Un UITableView tiene una propiedad delegate que debe ser un objeto que adopte el protocolo UITableViewDelegate . Este protocolo incluye por ejemplo un m\u00e9todo que devuelve el contenido de una fila sabiendo su n\u00famero. De este modo, cuando iOS quiere dibujar la tabla en pantalla lo que va haciendo es \"pidi\u00e9ndole\" las filas una por una al delegate . Una alternativa que podr\u00eda haber adoptado Apple es hacer que el desarrollador creara una clase que heredara de UITableView y que tuviera que implementar en ella los m\u00e9todos apropiados, pero esta alternativa es m\u00e1s problem\u00e1tica, ya que como sabemos una clase solo puede heredar de otra, y si tuvi\u00e9ramos que heredar de UITableView para tener esta funcionalidad ya no podr\u00edamos heredar de otra clase. Este patr\u00f3n no se usa \u00fanicamente con tablas sino que est\u00e1 \"por todas partes\" en los frameworks del sistema en iOS. Ya vimos por ejemplo el ApplicationDelegate cuando creamos nuestra primera aplicaci\u00f3n, pero hay muchos m\u00e1s ejemplos.","title":"El patr\u00f3n de dise\u00f1o \"delegaci\u00f3n\""},{"location":"s4/comunicacion/","text":"Comunicaci\u00f3n modelo-controlador \u00b6 Ya hemos visto c\u00f3mo se comunican bidireccionalmente el controlador y la vista: Cuando la vista genera un evento (como por ejemplo un tap en un bot\u00f3n) llama a un m\u00e9todo del controlador (un action ) El controlador puede acceder al estado actual de ciertos elementos de la vista y manipularlo a trav\u00e9s de los outlet . Tambi\u00e9n hemos visto que el controlador mantiene una referencia a las clases del modelo y que as\u00ed podemos llamar a la l\u00f3gica de negocio, pero nos falta la otra direcci\u00f3n: c\u00f3mo avisa el modelo al controlador de que se ha producido un evento importante. Por ejemplo supongamos una aplicaci\u00f3n de mensajer\u00eda en la que las clases del modelo reciben un nuevo mensaje, y hay que pas\u00e1rselo al controlador para que \u00e9ste lo muestre en la vista. Una opci\u00f3n para comunicar eventos del modelo al controlador ser\u00eda que el primero mantuviera una referencia al segundo y as\u00ed pudiera llamar a cierto m\u00e9todo o m\u00e9todos. Pero esto acoplar\u00eda el c\u00f3digo del modelo al controlador, y no nos permitir\u00eda reutilizar el modelo o partes sgnificativas de \u00e9l en otras aplicaciones, o \"protegerlo\" de posibles cambios en el controlador. Vamos a ver aqu\u00ed m\u00e9todos \"no invasivos\" para que el modelo comunique con el controlador, sin necesidad de acoplar el c\u00f3digo de ambos. Es inevitable que controlador tenga conocimiento del modelo, pero como vamos a ver no es inevitable que el modelo tenga conocimiento del controlador. En Foundation hay dos formas b\u00e1sicas de conseguir que dos objetos se comuniquen acoplando el c\u00f3digo de ambos lo menos posible: Key-Value observing o KVO: un objeto puede \"vigilar\" el cambio en el valor de las propiedades de otro. Cuando se produzca un cambio, se llamar\u00e1 a una funci\u00f3n o clausura que act\u00faa de callback . Podemos usar este mecanismo para hacer que el controlador observe las propiedades del modelo que nos interesa actualizar din\u00e1micamente en la vista. Notificaciones: un objeto puede recibir notificaciones sobre eventos que le interesen. As\u00edmismo otro objeto puede enviar notificaciones. El encargado de gestionar las notificaciones es un objeto intermediario denominado \"centro de notificaciones\". Podemos usar las notificaciones de modo que el modelo notifique que ha habido un cambio y el controlador reciba la notificaci\u00f3n y actualice la vista. Key-Value Observing \u00b6 Gracias a Foundation, un objeto cualquiera puede observar cambios en las propiedades de otro. Especificamos un bloque de c\u00f3digo (funci\u00f3n o clausura) a ejecutar cuando se produzca este cambio. Esta funcionalidad se denomina Key-Value Observing o KVO. N\u00f3tese que para que esto pueda funcionar el runtime tiene que \"interceptar\" de alg\u00fan modo los cambios en las propiedades. Estas funcionalidades est\u00e1n integradas en el runtime de Objective-C, el \"antiguo\" lenguaje de desarrollo de Apple, y Swift todav\u00eda no las incorpora de forma totalmente nativa. As\u00ed, para que KVO funcione con nuestras clases Swift vamos a tener que usar algunas anotaciones y palabras clave especiales que referencian a Objective-C Por ejemplo supongamos el siguiente c\u00f3digo, que define una clase Persona 1 2 3 4 5 6 7 8 9 10 11 12 13 class Persona { var nombre : String var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } let pepito = Persona ( nombre : \"Pepe\" ) pepito . cumplirA\u00f1os () print ( \" \\( pepito . nombre ) tiene \\( pepito . edad ) a\u00f1o/s\" ) Supongamos que nos interesa enterarnos de cu\u00e1ndo cambia la edad de una persona, y ejecutar cierto c\u00f3digo en respuesta a esto. Podemos hacerlo con KVO. Lo primero es cambiar ciertos elementos de la clase para que use el runtime de ObjectiveC: Hacer que la clase herede de la clase base NSObject , que es la ra\u00edz de la jerarqu\u00eda de clases de ObjectiveC \"Marcar\" las propiedades que nos interesa observar con la anotaci\u00f3n @objc y la palabra clave dynamic (en lugar de usar @objc podr\u00edamos marcar la clase entera con @objcMembers ). 1 2 3 4 5 6 7 8 9 10 class Persona : NSObject { var nombre : String @objc dynamic var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } Lo siguiente que necesitamos es poder especificar qu\u00e9 propiedad queremos observar. Esto se hace con una expresi\u00f3n denominada keypath . Un keypath es simplemente la trayectoria a seguir desde un objeto \"inicial\" hasta la propiedad que nos interesa. Por ejemplo algo como \"persona1.nombre\". O si una persona tuviera una propiedad conyuge : Persona podr\u00edamos ir encadenando propiedades: persona1.conyuge.nombre . Hasta Swift 3 los keypath se especificaban como cadenas, pero desde Swift 4 se han a\u00f1adido de forma \"nativa\", con una sintaxis propia que permite el chequeo de tipos por parte del compilador. Con la nueva sintaxis Los keypath comienzan por una barra invertida y se ponen sin comillas, ya que no son cadenas. Se especifican de forma gen\u00e9rica, es decir, comienzan no por un nombre de objeto concreto sino por un nombre de clase, por ejemplo \\Persona.nombre . Si el contexto permite resolver la ambig\u00fcedad se puede omitir el nombre de la clase (pero no el . , por consistencia): por ejemplo \\.nombre , \\.conyuge.nombre . Ahora ya tenemos todos los elementos para indicar que en el ejemplo anterior queremos observar los cambios en la propiedad \"edad\" del objeto \"pepito\" y en respuesta a ellos ejecutar cierto c\u00f3digo. Para ello usamos el m\u00e9todo observe sobre la instancia a observar. El primer par\u00e1metro es el keypath que nos interesa observar y el \u00faltimo una clausura con el c\u00f3digo a ejecutar cuando cambia: 1 2 3 4 5 import Foundation let observador = pepito . observe ( \\ . edad ) { obj , cambio in print ( \" \\( obj . nombre ) ahora tiene \\( obj . edad \") } N\u00f3tese que en el keypath se puede omitir Persona al comienzo ya que claramente \"edad\" debe ser una propiedad de esta clase. La clausura con el c\u00f3digo a ejecutar recibe dos par\u00e1metros: obj , que es el objeto que estamos observando, y cambio , que nos da m\u00e1s informaci\u00f3n sobre el cambio producido (luego veremos el uso de este \u00faltimo) Cuando ya no nos interese seguir observando podemos parar el KVO llamando a invalidate sobre el valor devuelto por observe : 1 observador . invalidate () Importante: las observaciones se seguir\u00e1n realizando mientras el objeto devuelto por observe siga definido. Cuando se \"pierde\" (por ejemplo era una variable local a una funci\u00f3n y esta ya ha terminado) el KVO se para autom\u00e1ticamente. En versiones antiguas de iOS hab\u00eda que pararlo manualmente y se produc\u00eda un error si se recib\u00edan nuevas observaciones cuando el observador ya no exist\u00eda. En el ejemplo anterior solo nos interesaba el estado actual del objeto una vez producido el cambio. En algunos casos nos puede interesar m\u00e1s informaci\u00f3n, como saber adem\u00e1s cu\u00e1l era el valor anterior de la propiedad. Para ello se usa un par\u00e1metro de observe que antes hemos omitido, llamado options , de tipo OptionSet . Desde el punto de vista de su uso, un OptionSet es un array de constantes donde especificamos un conjunto de opciones que no son mutuamente excluyentes. En nuestro caso las opciones son constantes de la clase NSKeyValueObservingOptions . Vamos a indicar por ejemplo que nos interesa que se nos informe expl\u00edcitamente del valor actual y del antiguo: 1 2 3 4 let obs = pepito . observe ( \\ . edad , options :[. new , . old ]) { obj , cambio in print ( \"Antes: \\( cambio . oldValue ! ) \" ) print ( \"Ahora: \\( cambio . newValue ! ) \" ) } En options hemos indicado qu\u00e9 informaci\u00f3n queremos y esta la tenemos disponible a trav\u00e9s de propiedades del segundo par\u00e1metro de la clausura (nuestro par\u00e1metro cambio ). Hay m\u00e1s opciones de KVO, por ejemplo con .prior indicar\u00edamos que queremos recibir dos avisos, uno inmediatamente antes del cambio y otro inmediatamente despu\u00e9s. Se recomienda consultar la documentaci\u00f3n para ver m\u00e1s opciones. Notificaciones locales \u00b6 Son algo similar a lo que en aplicaciones enterprise se llaman colas de mensajes . Implementan el patr\u00f3n de dise\u00f1o publicar/suscribir. Cuando un objeto quiere avisar al resto del sistema, publica una notificaci\u00f3n asign\u00e1ndole un nombre, y opcionalmente un payload (datos asociados). Los objetos que quieren recibir la notificaci\u00f3n indican el nombre de la que le interesa, y qu\u00e9 m\u00e9todo o clausura ejecutar cuando se reciba. El encargado de gestionar las notificaciones es el NotificationCenter . Hay uno por defecto ya inicializado en cada aplicaci\u00f3n ( NotificationCenter.default ). Se pueden crear m\u00e1s, pero en la mayor\u00eda de aplicaciones nos bastar\u00e1 con uno. A este centro de notificaciones es a quien le decimos que env\u00ede las notificaciones (publicar) o que queremos recibir las de un determinado tipo (suscribir). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import Foundation class Emisor { func enviar ( mensaje : String ) { //Obtenemos el centro de notificaciones por defecto //Las notificaciones tienen un nombre, un objeto que las env\u00eda (si lo ponemos a nil no queda constancia de qui\u00e9n) y datos adicionales, un diccionario con los datos que queramos let nc = NotificationCenter . default nc . post ( name : NSNotification . Name ( rawValue : \"saludo\" ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : mensaje ]) } } class Receptor { func suscribirse () { let nc = NotificationCenter . default //primer par\u00e1metro: a\u00f1adimos como observador a nosotros (self) //selector: al recibir la notificaci\u00f3n se llama al m\u00e9todo recibir //name: nombre de la notificaci\u00f3n que nos interesa //object: objeto del que nos interesa recibir notificaciones. nil == cualquiera nc . addObserver ( self , selector : #selector ( self . recibir ), name : NSNotification . Name ( rawValue : \"saludo\" ), object : nil ) } @objc func recibir ( notificacion : Notification ) { print ( \"recibido!!\" ) if let userInfo = notificacion . userInfo { let mensaje = userInfo [ \"mensaje\" ] as ! String print ( \"dice: \\( mensaje ) \" ) } } } var e = Emisor () var r = Receptor () r . suscribirse () e . enviar ( mensaje : \"holaaaa\" )","title":"Comunicaci\u00f3n entre componentes"},{"location":"s4/comunicacion/#comunicacion-modelo-controlador","text":"Ya hemos visto c\u00f3mo se comunican bidireccionalmente el controlador y la vista: Cuando la vista genera un evento (como por ejemplo un tap en un bot\u00f3n) llama a un m\u00e9todo del controlador (un action ) El controlador puede acceder al estado actual de ciertos elementos de la vista y manipularlo a trav\u00e9s de los outlet . Tambi\u00e9n hemos visto que el controlador mantiene una referencia a las clases del modelo y que as\u00ed podemos llamar a la l\u00f3gica de negocio, pero nos falta la otra direcci\u00f3n: c\u00f3mo avisa el modelo al controlador de que se ha producido un evento importante. Por ejemplo supongamos una aplicaci\u00f3n de mensajer\u00eda en la que las clases del modelo reciben un nuevo mensaje, y hay que pas\u00e1rselo al controlador para que \u00e9ste lo muestre en la vista. Una opci\u00f3n para comunicar eventos del modelo al controlador ser\u00eda que el primero mantuviera una referencia al segundo y as\u00ed pudiera llamar a cierto m\u00e9todo o m\u00e9todos. Pero esto acoplar\u00eda el c\u00f3digo del modelo al controlador, y no nos permitir\u00eda reutilizar el modelo o partes sgnificativas de \u00e9l en otras aplicaciones, o \"protegerlo\" de posibles cambios en el controlador. Vamos a ver aqu\u00ed m\u00e9todos \"no invasivos\" para que el modelo comunique con el controlador, sin necesidad de acoplar el c\u00f3digo de ambos. Es inevitable que controlador tenga conocimiento del modelo, pero como vamos a ver no es inevitable que el modelo tenga conocimiento del controlador. En Foundation hay dos formas b\u00e1sicas de conseguir que dos objetos se comuniquen acoplando el c\u00f3digo de ambos lo menos posible: Key-Value observing o KVO: un objeto puede \"vigilar\" el cambio en el valor de las propiedades de otro. Cuando se produzca un cambio, se llamar\u00e1 a una funci\u00f3n o clausura que act\u00faa de callback . Podemos usar este mecanismo para hacer que el controlador observe las propiedades del modelo que nos interesa actualizar din\u00e1micamente en la vista. Notificaciones: un objeto puede recibir notificaciones sobre eventos que le interesen. As\u00edmismo otro objeto puede enviar notificaciones. El encargado de gestionar las notificaciones es un objeto intermediario denominado \"centro de notificaciones\". Podemos usar las notificaciones de modo que el modelo notifique que ha habido un cambio y el controlador reciba la notificaci\u00f3n y actualice la vista.","title":"Comunicaci\u00f3n modelo-controlador"},{"location":"s4/comunicacion/#key-value-observing","text":"Gracias a Foundation, un objeto cualquiera puede observar cambios en las propiedades de otro. Especificamos un bloque de c\u00f3digo (funci\u00f3n o clausura) a ejecutar cuando se produzca este cambio. Esta funcionalidad se denomina Key-Value Observing o KVO. N\u00f3tese que para que esto pueda funcionar el runtime tiene que \"interceptar\" de alg\u00fan modo los cambios en las propiedades. Estas funcionalidades est\u00e1n integradas en el runtime de Objective-C, el \"antiguo\" lenguaje de desarrollo de Apple, y Swift todav\u00eda no las incorpora de forma totalmente nativa. As\u00ed, para que KVO funcione con nuestras clases Swift vamos a tener que usar algunas anotaciones y palabras clave especiales que referencian a Objective-C Por ejemplo supongamos el siguiente c\u00f3digo, que define una clase Persona 1 2 3 4 5 6 7 8 9 10 11 12 13 class Persona { var nombre : String var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } let pepito = Persona ( nombre : \"Pepe\" ) pepito . cumplirA\u00f1os () print ( \" \\( pepito . nombre ) tiene \\( pepito . edad ) a\u00f1o/s\" ) Supongamos que nos interesa enterarnos de cu\u00e1ndo cambia la edad de una persona, y ejecutar cierto c\u00f3digo en respuesta a esto. Podemos hacerlo con KVO. Lo primero es cambiar ciertos elementos de la clase para que use el runtime de ObjectiveC: Hacer que la clase herede de la clase base NSObject , que es la ra\u00edz de la jerarqu\u00eda de clases de ObjectiveC \"Marcar\" las propiedades que nos interesa observar con la anotaci\u00f3n @objc y la palabra clave dynamic (en lugar de usar @objc podr\u00edamos marcar la clase entera con @objcMembers ). 1 2 3 4 5 6 7 8 9 10 class Persona : NSObject { var nombre : String @objc dynamic var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } Lo siguiente que necesitamos es poder especificar qu\u00e9 propiedad queremos observar. Esto se hace con una expresi\u00f3n denominada keypath . Un keypath es simplemente la trayectoria a seguir desde un objeto \"inicial\" hasta la propiedad que nos interesa. Por ejemplo algo como \"persona1.nombre\". O si una persona tuviera una propiedad conyuge : Persona podr\u00edamos ir encadenando propiedades: persona1.conyuge.nombre . Hasta Swift 3 los keypath se especificaban como cadenas, pero desde Swift 4 se han a\u00f1adido de forma \"nativa\", con una sintaxis propia que permite el chequeo de tipos por parte del compilador. Con la nueva sintaxis Los keypath comienzan por una barra invertida y se ponen sin comillas, ya que no son cadenas. Se especifican de forma gen\u00e9rica, es decir, comienzan no por un nombre de objeto concreto sino por un nombre de clase, por ejemplo \\Persona.nombre . Si el contexto permite resolver la ambig\u00fcedad se puede omitir el nombre de la clase (pero no el . , por consistencia): por ejemplo \\.nombre , \\.conyuge.nombre . Ahora ya tenemos todos los elementos para indicar que en el ejemplo anterior queremos observar los cambios en la propiedad \"edad\" del objeto \"pepito\" y en respuesta a ellos ejecutar cierto c\u00f3digo. Para ello usamos el m\u00e9todo observe sobre la instancia a observar. El primer par\u00e1metro es el keypath que nos interesa observar y el \u00faltimo una clausura con el c\u00f3digo a ejecutar cuando cambia: 1 2 3 4 5 import Foundation let observador = pepito . observe ( \\ . edad ) { obj , cambio in print ( \" \\( obj . nombre ) ahora tiene \\( obj . edad \") } N\u00f3tese que en el keypath se puede omitir Persona al comienzo ya que claramente \"edad\" debe ser una propiedad de esta clase. La clausura con el c\u00f3digo a ejecutar recibe dos par\u00e1metros: obj , que es el objeto que estamos observando, y cambio , que nos da m\u00e1s informaci\u00f3n sobre el cambio producido (luego veremos el uso de este \u00faltimo) Cuando ya no nos interese seguir observando podemos parar el KVO llamando a invalidate sobre el valor devuelto por observe : 1 observador . invalidate () Importante: las observaciones se seguir\u00e1n realizando mientras el objeto devuelto por observe siga definido. Cuando se \"pierde\" (por ejemplo era una variable local a una funci\u00f3n y esta ya ha terminado) el KVO se para autom\u00e1ticamente. En versiones antiguas de iOS hab\u00eda que pararlo manualmente y se produc\u00eda un error si se recib\u00edan nuevas observaciones cuando el observador ya no exist\u00eda. En el ejemplo anterior solo nos interesaba el estado actual del objeto una vez producido el cambio. En algunos casos nos puede interesar m\u00e1s informaci\u00f3n, como saber adem\u00e1s cu\u00e1l era el valor anterior de la propiedad. Para ello se usa un par\u00e1metro de observe que antes hemos omitido, llamado options , de tipo OptionSet . Desde el punto de vista de su uso, un OptionSet es un array de constantes donde especificamos un conjunto de opciones que no son mutuamente excluyentes. En nuestro caso las opciones son constantes de la clase NSKeyValueObservingOptions . Vamos a indicar por ejemplo que nos interesa que se nos informe expl\u00edcitamente del valor actual y del antiguo: 1 2 3 4 let obs = pepito . observe ( \\ . edad , options :[. new , . old ]) { obj , cambio in print ( \"Antes: \\( cambio . oldValue ! ) \" ) print ( \"Ahora: \\( cambio . newValue ! ) \" ) } En options hemos indicado qu\u00e9 informaci\u00f3n queremos y esta la tenemos disponible a trav\u00e9s de propiedades del segundo par\u00e1metro de la clausura (nuestro par\u00e1metro cambio ). Hay m\u00e1s opciones de KVO, por ejemplo con .prior indicar\u00edamos que queremos recibir dos avisos, uno inmediatamente antes del cambio y otro inmediatamente despu\u00e9s. Se recomienda consultar la documentaci\u00f3n para ver m\u00e1s opciones.","title":"Key-Value Observing"},{"location":"s4/comunicacion/#notificaciones-locales","text":"Son algo similar a lo que en aplicaciones enterprise se llaman colas de mensajes . Implementan el patr\u00f3n de dise\u00f1o publicar/suscribir. Cuando un objeto quiere avisar al resto del sistema, publica una notificaci\u00f3n asign\u00e1ndole un nombre, y opcionalmente un payload (datos asociados). Los objetos que quieren recibir la notificaci\u00f3n indican el nombre de la que le interesa, y qu\u00e9 m\u00e9todo o clausura ejecutar cuando se reciba. El encargado de gestionar las notificaciones es el NotificationCenter . Hay uno por defecto ya inicializado en cada aplicaci\u00f3n ( NotificationCenter.default ). Se pueden crear m\u00e1s, pero en la mayor\u00eda de aplicaciones nos bastar\u00e1 con uno. A este centro de notificaciones es a quien le decimos que env\u00ede las notificaciones (publicar) o que queremos recibir las de un determinado tipo (suscribir). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import Foundation class Emisor { func enviar ( mensaje : String ) { //Obtenemos el centro de notificaciones por defecto //Las notificaciones tienen un nombre, un objeto que las env\u00eda (si lo ponemos a nil no queda constancia de qui\u00e9n) y datos adicionales, un diccionario con los datos que queramos let nc = NotificationCenter . default nc . post ( name : NSNotification . Name ( rawValue : \"saludo\" ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : mensaje ]) } } class Receptor { func suscribirse () { let nc = NotificationCenter . default //primer par\u00e1metro: a\u00f1adimos como observador a nosotros (self) //selector: al recibir la notificaci\u00f3n se llama al m\u00e9todo recibir //name: nombre de la notificaci\u00f3n que nos interesa //object: objeto del que nos interesa recibir notificaciones. nil == cualquiera nc . addObserver ( self , selector : #selector ( self . recibir ), name : NSNotification . Name ( rawValue : \"saludo\" ), object : nil ) } @objc func recibir ( notificacion : Notification ) { print ( \"recibido!!\" ) if let userInfo = notificacion . userInfo { let mensaje = userInfo [ \"mensaje\" ] as ! String print ( \"dice: \\( mensaje ) \" ) } } } var e = Emisor () var r = Receptor () r . suscribirse () e . enviar ( mensaje : \"holaaaa\" )","title":"Notificaciones locales"},{"location":"s4/ejercicios/","text":"Ejercicios de comunicaci\u00f3n entre objetos (1.5 puntos) \u00b6 En las plantillas de la sesi\u00f3n hay un proyecto de Xcode llamado Conversor . Se trata de un conversor de moneda entre euros y d\u00f3lares que actualiza el tipo de cambio en tiempo real (lo deber\u00eda actualizar de alg\u00fan servidor, pero lo que hace es calcular un valor aleatorio cada 5 segundos). Si escribimos por ejemplo una cantidad en euros y pulsamos el bot\u00f3n \u201cobtener\u201d que hay al lado del campo para los d\u00f3lares, veremos la cantidad en d\u00f3lares (y viceversa). A. Uso de notificaciones (1 punto) El problema es que aunque el c\u00e1lculo se hace con la cotizaci\u00f3n actual, *la etiqueta con la cotizaci\u00f3n (\u201c1\u20ac=\u2026$\u201d) no se actualiza autom\u00e1ticamente cada vez que cambie esta. Tenemos que solucionarlo. Es decir, debemos hacer que la vista se actualice autom\u00e1ticamente cuando var\u00ede el tipo de cambio. Se os pide hacerlo usando notificaciones Estructura del c\u00f3digo: El outlet que nos da acceso a la etiqueta se llama tipoCambioLabel , definido en ViewController El conversor est\u00e1 definido como una propiedad conversor en ViewController Cada 5 segundos se dispara un \u201ctimer\u201d que llama al m\u00e9todo actualizarTipoDeCambio del conversor. Este m\u00e9todo a su vez cambia el valor de la propiedad unEURenUSD . Desde el m\u00e9todo actualizarTipoDeCambio se debe enviar una notificaci\u00f3n (dadle el nombre que quer\u00e1is) y el View Controller deber\u00eda suscribirse a ellas para poder actualizar la etiqueta en pantalla. B. Internacionalizaci\u00f3n (0,5 puntos): haz que la interfaz de la app se vea correctamente en espa\u00f1ol e ingl\u00e9s. Como el idioma base de desarrollo deber\u00eda ser el ingl\u00e9s primero tendr\u00e1s que cambiar los textos de los componentes a este idioma.","title":"Ejercicios"},{"location":"s4/ejercicios/#ejercicios-de-comunicacion-entre-objetos-15-puntos","text":"En las plantillas de la sesi\u00f3n hay un proyecto de Xcode llamado Conversor . Se trata de un conversor de moneda entre euros y d\u00f3lares que actualiza el tipo de cambio en tiempo real (lo deber\u00eda actualizar de alg\u00fan servidor, pero lo que hace es calcular un valor aleatorio cada 5 segundos). Si escribimos por ejemplo una cantidad en euros y pulsamos el bot\u00f3n \u201cobtener\u201d que hay al lado del campo para los d\u00f3lares, veremos la cantidad en d\u00f3lares (y viceversa). A. Uso de notificaciones (1 punto) El problema es que aunque el c\u00e1lculo se hace con la cotizaci\u00f3n actual, *la etiqueta con la cotizaci\u00f3n (\u201c1\u20ac=\u2026$\u201d) no se actualiza autom\u00e1ticamente cada vez que cambie esta. Tenemos que solucionarlo. Es decir, debemos hacer que la vista se actualice autom\u00e1ticamente cuando var\u00ede el tipo de cambio. Se os pide hacerlo usando notificaciones Estructura del c\u00f3digo: El outlet que nos da acceso a la etiqueta se llama tipoCambioLabel , definido en ViewController El conversor est\u00e1 definido como una propiedad conversor en ViewController Cada 5 segundos se dispara un \u201ctimer\u201d que llama al m\u00e9todo actualizarTipoDeCambio del conversor. Este m\u00e9todo a su vez cambia el valor de la propiedad unEURenUSD . Desde el m\u00e9todo actualizarTipoDeCambio se debe enviar una notificaci\u00f3n (dadle el nombre que quer\u00e1is) y el View Controller deber\u00eda suscribirse a ellas para poder actualizar la etiqueta en pantalla. B. Internacionalizaci\u00f3n (0,5 puntos): haz que la interfaz de la app se vea correctamente en espa\u00f1ol e ingl\u00e9s. Como el idioma base de desarrollo deber\u00eda ser el ingl\u00e9s primero tendr\u00e1s que cambiar los textos de los componentes a este idioma.","title":"Ejercicios de comunicaci\u00f3n entre objetos (1.5 puntos)"},{"location":"s4/i18n/","text":"Internacionalizaci\u00f3n de aplicaciones iOS \u00b6 En un mercado global hay que tener previsto desde el principio la adaptaci\u00f3n de los mensajes y textos mostrados por la app al idioma local, y tambi\u00e9n de otras convenciones (unidades de medida, formatos de n\u00fameros y fechas,...). Al proceso de preparaci\u00f3n de la app para soportar distintos idiomas se le denomina internacionalizaci\u00f3n (o i18n, por el n\u00famero de letras existentes entre la \"i\" inicial y la \"n\" final de la palabra completa). A la adaptaci\u00f3n para un idioma concreto se la denomina localizaci\u00f3n . Vamos a ver aqu\u00ed una introducci\u00f3n a las funcionalidades b\u00e1sicas que nos da la plataforma iOS para internacionalizar y localizar nuestras aplicaciones. A\u00f1adir soporte para i18n \u00b6 En la versi\u00f3n actual de Xcode los proyectos ya incluyen por defecto soporte para i18n . Si en un proyecto Xcode seleccionamos el icono del proyecto en el project navigator , al final de las propiedades podemos comprobar que aparece marcada una casilla denominada Use base internationalization . Si el proyecto ha sido desarrollado con una versi\u00f3n antigua de Xcode, la marcaremos. El idioma de desarrollo o development language es el que se va a usar por defecto para desarrollar la interfaz. Adem\u00e1s de este podemos a\u00f1adir otros idiomas. En la versi\u00f3n actual de Xcode solo est\u00e1 previsto el ingl\u00e9s como development language y no se puede cambiar desde el IDE. Podr\u00edamos cambiarlo editando manualmente el archivo .pbxproj del proyecto, aunque aqu\u00ed vamos a usar el ingl\u00e9s como idioma base. Localizar la interfaz gr\u00e1fica \u00b6 Al dise\u00f1ar la interfaz hay que recordar que debemos usar el development language en los textos de los componentes. Por tanto por defecto pondremos los textos de los botones, Label , etc en ingl\u00e9s . Para que sea m\u00e1s f\u00e1cil probar las funcionalidades se recomienda terminar primero la interfaz y luego seguir el proceso descrito. M\u00e1s tarde veremos qu\u00e9 sucede si se a\u00f1aden nuevos elementos a la interfaz. A\u00f1adir idiomas \u00b6 Supongamos que ya hemos terminado de desarrollar la interfaz en ingl\u00e9s, que es el idioma base por defecto y queremos traducirla. Podemos a\u00f1adir idiomas a la app en la secci\u00f3n Localizations . Para a\u00f1adir un idioma basta pulsar + F\u00edjate en que cuando a\u00f1adimos un idioma aparece un cuadro de di\u00e1logo que nos dice qu\u00e9 archivos de la interfaz se van a internacionalizar, lo habitual ser\u00e1 seleccionarlos todos pero podemos escoger los que nos interesen. Adem\u00e1s podemos elegir el m\u00e9todo usado. Por defecto es Localizable strings , pero hay otro m\u00e9todo llamado Interface builder storyboard : Localizable strings : por cada idioma hay un archivo de texto Strings en el que se almacena la traducci\u00f3n de los textos de cada bot\u00f3n, label, etc. El storyboard es \u00fanico para todos los idiomas, y lo que se hace es cambiar solamente el texto. Interface builder storyboard : tenemos una copia del storyboard por cada idioma, y la editamos por separado. Aqu\u00ed vamos a describir c\u00f3mo usar los Localizable strings , ya que es el m\u00e9todo m\u00e1s com\u00fan. Los archivos .strings \u00b6 Si hemos a\u00f1adido idiomas adicionales veremos que en el project navigator los iconos de storyboard aparecen con una flecha a la izquierda indicando que en realidad son varios archivos. Al desplegarlo veremos que es el storyboard en s\u00ed m\u00e1s un archivo .strings por cada idioma a\u00f1adido. Al abrir este archivo .strings veremos que es un archivo de texto en el que por cada componente de usuario que contenga texto hay una l\u00ednea en el formato 1 \"identificador-del-componente\" = \"Texto mostrado\" Lo \u00fanico que tenemos que hacer es cambiar el texto al idioma correspondiente . El identificador del componente es un tanto cr\u00edptico ya que es autogenerado por Xcode,y se corresponde con el Object Id que podemos ver en el Identity inspector , aunque casi siempre es f\u00e1cil saber de qu\u00e9 componente se trata simplemente por el texto mostrado. Probar la interfaz \u00b6 Podemos previsualizar c\u00f3mo quedar\u00e1 la interfaz en los distintos idiomas sin necesidad de ejecutar la app . En el assistant editor , clicamos en la barra superior del editor, seleccionamos Preview , y el storyboard que queremos ver. Se mostrar\u00e1 el storyboard en el idioma base. Este idioma aparecer\u00e1 en la esquina inferior derecha, pulsando sobre \u00e9l podemos cambiarlo. Tambi\u00e9n podemos probar la app en el simulador y cambiar aqu\u00ed el idioma del sistema. Habr\u00e1 que salir de la app , ir al icono de settings (o configuraci\u00f3n en la versi\u00f3n en espa\u00f1ol) y en el apartado General cambiar el Language & Region . El proceso es un poco m\u00e1s tedioso que la simple previsualizaci\u00f3n porque hay que salir y volver a entrar en la app y adem\u00e1s el simulador tarda unos segundos en aplicar el nuevo idioma. A\u00f1adir elementos a la interfaz tras internacionalizar \u00b6 Hay un problema con el proceso descrito en los apartados anteriores y es que cuando se a\u00f1aden nuevos elementos a la interfaz de usuario, Xcode no actualiza autom\u00e1ticamente los archivos .Strings . Una posible soluci\u00f3n ser\u00eda editar manualmente los .Strings pero es un proceso tedioso porque, como hemos visto, cada componente viene identificado con su Object id y tendr\u00edamos que consultarlo manualmente en Xcode y copiarlo al archivo de texto, repitiendo la operaci\u00f3n para cada nuevo elemento de la interfaz. Apple tiene algunas herramientas que permiten automatizar el proceso en cierta medida, pero son herramientas en l\u00ednea de comandos y su uso no es precisamente trivial. Por ejemplo podr\u00edamos usar la herramienta ibtool . Supongamos que hemos a\u00f1adido una etiqueta al Main.storyboard y queremos actualizar el Main.Strings de espa\u00f1ol. Tendr\u00edamos que abrir una terminal e ir hasta el directorio donde est\u00e9 este archivo. La estructura de de directorios y archivos relativa a la internacionalizaci\u00f3n ser\u00e1 como la siguiente: Como vemos, los archivos de espa\u00f1ol est\u00e1n en un subdirectorio llamado es.lproj . En el ejemplo solo hay un Main.Strings porque la launchscreen est\u00e1 vac\u00eda y por eso no ha generado ning\u00fan archivo. Los archivos del idioma base est\u00e1n en base.lproj , y este es el que contiene los storyboards . Con la opci\u00f3n --import-strings-file le decimos a ibtool cu\u00e1l es la versi\u00f3n actual del .Strings de la que queremos partir, y con --generate-strings-file en qu\u00e9 archivo queremos generar el resultado. Finalmente ponemos el nombre del archivo con el storyboard . Por ejemplo, suponiendo que abrimos la terminal y nos movemos al directorio es.lproj , el comando ser\u00eda algo como: 1 ibtool --generate-strings-file Main.Strings --import-strings-file Main.Strings ../Base.lproj/Main.storyboard Ponemos el mismo valor para el --generate-strings-file que para el --import-strings-file para actualizar el archivo, no queremos generar uno nuevo. Una vez hecho esto, ya podemos editar manualmente el .Strings para a\u00f1adir las traducciones de los nuevos elementos de la interfaz. Hay herramientas de terceros que automatizan bastante m\u00e1s el proceso, algunas comerciales y otras open source como por ejemplo BartyCrouch . Esta sigue siendo una herramienta de l\u00ednea de comandos pero con comandos mucho m\u00e1s sencillos, Por ejemplo podemos ejecutar simplemente bartycrouch -p trayectoria/hasta/el/proyecto para actualizar autom\u00e1ticamente todos los archivos Strings . Localizar los mensajes en el c\u00f3digo \u00b6 Hay mensajes que no est\u00e1n fijos en la interfaz, sino que se generan desde el c\u00f3digo. Por ejemplo recordemos la app UAdivino que hicimos en el tema de \"Introducci\u00f3n a las aplicaciones iOS\". Lo que tenemos que hacer para internacionalizar este tipo de mensajes es usar localized strings . Este tipo de strings no se toman de manera literal sino que se consideran claves en un archivo .Strings . El sistema sustituir\u00e1 la clave por el valor asociado en el idioma actual. La representaci\u00f3n interna de los mensajes en el c\u00f3digo ser\u00eda parecida, aunque puede ser m\u00e1s breve, ya que no es el mensaje que va a ser el usuario final. 1 2 3 4 5 6 7 8 9 import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"si\" , \"no\" , \"ni_casualidad\" , \"claro\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } En el momento en que queremos asignar el mensaje a un elemento de usuario podemos usar la macro NSLocalizedString , que obtiene el mensaje asociado a la clave 1 2 3 4 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = NSLocalizedString ( respuesta , comment : \"\" ) } El segundo par\u00e1metro de NSLocalizedString es un comentario que pueda ayudar a un traductor de la app a entender el contexto del mensaje. En este caso no tiene sentido y lo dejamos vac\u00edo. Para que esto funcione nos falta todav\u00eda crear el archivo .strings . Por defecto se debe llamar Localizable.strings . Para crearlo, en Xcode se elige File > New > File . De entre las plantillas disponibles hay que ir a la secci\u00f3n Resource y elegir all\u00ed Strings File . Teniendo seleccionado el archivo, en el File inspector del panel de la derecha de Xcode pulsamos el bot\u00f3n Localize... para que tenga versiones en distintos idiomas. Nos preguntar\u00e1 qu\u00e9 versi\u00f3n inicial queremos crear (por defecto English ). Una vez creada esta podemos marcar el resto de idiomas que hemos a\u00f1adido a nuestra app (en nuestro caso solo espa\u00f1ol) Esto habr\u00e1 creado dos archivos distintos para Localizable.strings , uno para ingl\u00e9s y otro para espa\u00f1ol. Ahora solo tenemos que editar las claves y los valores de cada uno de ellos. Para la versi\u00f3n inglesa ser\u00eda algo como: 1 2 3 4 \"si\" = \"Yes!\" ; \"no\" = \"No!\" ; \"ni_casualidad\" = \"No way!\" ; \"claro\" = \"Sure!\" ; Y para la espa\u00f1ola: 1 2 3 4 \"si\" = \"\u00a1Si!\" ; \"no\" = \"\u00a1No!\" ; \"ni_casualidad\" = \"\u00a1Ni de casualidad!\" ; \"claro\" = \"\u00a1Claro que s\u00ed!\" ; Para probar esta funcionalidad tendremos que ejecutar la app en el simulador y cambiar el idioma desde la aplicaci\u00f3n de settings/configuraci\u00f3n . Es posible que en algunos casos tengamos mensajes con una parte fija y una variable. Por ejemplo un saludo en el que queremos incluir el nombre del usuario. Por desgracia, en la versi\u00f3n actual de iOS la interpolaci\u00f3n de cadenas de Swift todav\u00eda no funciona para los mensajes internacionalizados. Tenemos que usar placeholders en el mensaje, que son caracteres que funcionan de modo similar a como lo hacen los caracteres de formato en el printf de C: 1 2 3 /* .strings en versi\u00f3n ingl\u00e9s */ saludo = \"Welcome %@\" ; ... En este caso, para \"montar\" el mensaje final tenemos que usar un inicializador de String que acepte cadenas de formato: 1 2 let nombre = \"John\" let mensaje = String(format: NSLocalizedString(\"saludo\", comment: \"\"), nombre) N\u00f3tese que estos placeholders ( %@ ) vienen \"heredados\" del lenguaje Objective-C, que utiliza unos caracteres de formato similares a los de C . Por ejemplo para mostrar un n\u00famero entero se usa %d , aunque para mostrar una cadena se usa el car\u00e1cter de formato gen\u00e9rico de \"objeto\", que como se ha visto es %@ .","title":"Internacionalizaci\u00f3n de aplicaciones iOS"},{"location":"s4/i18n/#internacionalizacion-de-aplicaciones-ios","text":"En un mercado global hay que tener previsto desde el principio la adaptaci\u00f3n de los mensajes y textos mostrados por la app al idioma local, y tambi\u00e9n de otras convenciones (unidades de medida, formatos de n\u00fameros y fechas,...). Al proceso de preparaci\u00f3n de la app para soportar distintos idiomas se le denomina internacionalizaci\u00f3n (o i18n, por el n\u00famero de letras existentes entre la \"i\" inicial y la \"n\" final de la palabra completa). A la adaptaci\u00f3n para un idioma concreto se la denomina localizaci\u00f3n . Vamos a ver aqu\u00ed una introducci\u00f3n a las funcionalidades b\u00e1sicas que nos da la plataforma iOS para internacionalizar y localizar nuestras aplicaciones.","title":"Internacionalizaci\u00f3n de aplicaciones iOS"},{"location":"s4/i18n/#anadir-soporte-para-i18n","text":"En la versi\u00f3n actual de Xcode los proyectos ya incluyen por defecto soporte para i18n . Si en un proyecto Xcode seleccionamos el icono del proyecto en el project navigator , al final de las propiedades podemos comprobar que aparece marcada una casilla denominada Use base internationalization . Si el proyecto ha sido desarrollado con una versi\u00f3n antigua de Xcode, la marcaremos. El idioma de desarrollo o development language es el que se va a usar por defecto para desarrollar la interfaz. Adem\u00e1s de este podemos a\u00f1adir otros idiomas. En la versi\u00f3n actual de Xcode solo est\u00e1 previsto el ingl\u00e9s como development language y no se puede cambiar desde el IDE. Podr\u00edamos cambiarlo editando manualmente el archivo .pbxproj del proyecto, aunque aqu\u00ed vamos a usar el ingl\u00e9s como idioma base.","title":"A\u00f1adir soporte para i18n"},{"location":"s4/i18n/#localizar-la-interfaz-grafica","text":"Al dise\u00f1ar la interfaz hay que recordar que debemos usar el development language en los textos de los componentes. Por tanto por defecto pondremos los textos de los botones, Label , etc en ingl\u00e9s . Para que sea m\u00e1s f\u00e1cil probar las funcionalidades se recomienda terminar primero la interfaz y luego seguir el proceso descrito. M\u00e1s tarde veremos qu\u00e9 sucede si se a\u00f1aden nuevos elementos a la interfaz.","title":"Localizar la interfaz gr\u00e1fica"},{"location":"s4/i18n/#anadir-idiomas","text":"Supongamos que ya hemos terminado de desarrollar la interfaz en ingl\u00e9s, que es el idioma base por defecto y queremos traducirla. Podemos a\u00f1adir idiomas a la app en la secci\u00f3n Localizations . Para a\u00f1adir un idioma basta pulsar + F\u00edjate en que cuando a\u00f1adimos un idioma aparece un cuadro de di\u00e1logo que nos dice qu\u00e9 archivos de la interfaz se van a internacionalizar, lo habitual ser\u00e1 seleccionarlos todos pero podemos escoger los que nos interesen. Adem\u00e1s podemos elegir el m\u00e9todo usado. Por defecto es Localizable strings , pero hay otro m\u00e9todo llamado Interface builder storyboard : Localizable strings : por cada idioma hay un archivo de texto Strings en el que se almacena la traducci\u00f3n de los textos de cada bot\u00f3n, label, etc. El storyboard es \u00fanico para todos los idiomas, y lo que se hace es cambiar solamente el texto. Interface builder storyboard : tenemos una copia del storyboard por cada idioma, y la editamos por separado. Aqu\u00ed vamos a describir c\u00f3mo usar los Localizable strings , ya que es el m\u00e9todo m\u00e1s com\u00fan.","title":"A\u00f1adir idiomas"},{"location":"s4/i18n/#los-archivos-strings","text":"Si hemos a\u00f1adido idiomas adicionales veremos que en el project navigator los iconos de storyboard aparecen con una flecha a la izquierda indicando que en realidad son varios archivos. Al desplegarlo veremos que es el storyboard en s\u00ed m\u00e1s un archivo .strings por cada idioma a\u00f1adido. Al abrir este archivo .strings veremos que es un archivo de texto en el que por cada componente de usuario que contenga texto hay una l\u00ednea en el formato 1 \"identificador-del-componente\" = \"Texto mostrado\" Lo \u00fanico que tenemos que hacer es cambiar el texto al idioma correspondiente . El identificador del componente es un tanto cr\u00edptico ya que es autogenerado por Xcode,y se corresponde con el Object Id que podemos ver en el Identity inspector , aunque casi siempre es f\u00e1cil saber de qu\u00e9 componente se trata simplemente por el texto mostrado.","title":"Los archivos .strings"},{"location":"s4/i18n/#probar-la-interfaz","text":"Podemos previsualizar c\u00f3mo quedar\u00e1 la interfaz en los distintos idiomas sin necesidad de ejecutar la app . En el assistant editor , clicamos en la barra superior del editor, seleccionamos Preview , y el storyboard que queremos ver. Se mostrar\u00e1 el storyboard en el idioma base. Este idioma aparecer\u00e1 en la esquina inferior derecha, pulsando sobre \u00e9l podemos cambiarlo. Tambi\u00e9n podemos probar la app en el simulador y cambiar aqu\u00ed el idioma del sistema. Habr\u00e1 que salir de la app , ir al icono de settings (o configuraci\u00f3n en la versi\u00f3n en espa\u00f1ol) y en el apartado General cambiar el Language & Region . El proceso es un poco m\u00e1s tedioso que la simple previsualizaci\u00f3n porque hay que salir y volver a entrar en la app y adem\u00e1s el simulador tarda unos segundos en aplicar el nuevo idioma.","title":"Probar la interfaz"},{"location":"s4/i18n/#anadir-elementos-a-la-interfaz-tras-internacionalizar","text":"Hay un problema con el proceso descrito en los apartados anteriores y es que cuando se a\u00f1aden nuevos elementos a la interfaz de usuario, Xcode no actualiza autom\u00e1ticamente los archivos .Strings . Una posible soluci\u00f3n ser\u00eda editar manualmente los .Strings pero es un proceso tedioso porque, como hemos visto, cada componente viene identificado con su Object id y tendr\u00edamos que consultarlo manualmente en Xcode y copiarlo al archivo de texto, repitiendo la operaci\u00f3n para cada nuevo elemento de la interfaz. Apple tiene algunas herramientas que permiten automatizar el proceso en cierta medida, pero son herramientas en l\u00ednea de comandos y su uso no es precisamente trivial. Por ejemplo podr\u00edamos usar la herramienta ibtool . Supongamos que hemos a\u00f1adido una etiqueta al Main.storyboard y queremos actualizar el Main.Strings de espa\u00f1ol. Tendr\u00edamos que abrir una terminal e ir hasta el directorio donde est\u00e9 este archivo. La estructura de de directorios y archivos relativa a la internacionalizaci\u00f3n ser\u00e1 como la siguiente: Como vemos, los archivos de espa\u00f1ol est\u00e1n en un subdirectorio llamado es.lproj . En el ejemplo solo hay un Main.Strings porque la launchscreen est\u00e1 vac\u00eda y por eso no ha generado ning\u00fan archivo. Los archivos del idioma base est\u00e1n en base.lproj , y este es el que contiene los storyboards . Con la opci\u00f3n --import-strings-file le decimos a ibtool cu\u00e1l es la versi\u00f3n actual del .Strings de la que queremos partir, y con --generate-strings-file en qu\u00e9 archivo queremos generar el resultado. Finalmente ponemos el nombre del archivo con el storyboard . Por ejemplo, suponiendo que abrimos la terminal y nos movemos al directorio es.lproj , el comando ser\u00eda algo como: 1 ibtool --generate-strings-file Main.Strings --import-strings-file Main.Strings ../Base.lproj/Main.storyboard Ponemos el mismo valor para el --generate-strings-file que para el --import-strings-file para actualizar el archivo, no queremos generar uno nuevo. Una vez hecho esto, ya podemos editar manualmente el .Strings para a\u00f1adir las traducciones de los nuevos elementos de la interfaz. Hay herramientas de terceros que automatizan bastante m\u00e1s el proceso, algunas comerciales y otras open source como por ejemplo BartyCrouch . Esta sigue siendo una herramienta de l\u00ednea de comandos pero con comandos mucho m\u00e1s sencillos, Por ejemplo podemos ejecutar simplemente bartycrouch -p trayectoria/hasta/el/proyecto para actualizar autom\u00e1ticamente todos los archivos Strings .","title":"A\u00f1adir elementos a la interfaz tras internacionalizar"},{"location":"s4/i18n/#localizar-los-mensajes-en-el-codigo","text":"Hay mensajes que no est\u00e1n fijos en la interfaz, sino que se generan desde el c\u00f3digo. Por ejemplo recordemos la app UAdivino que hicimos en el tema de \"Introducci\u00f3n a las aplicaciones iOS\". Lo que tenemos que hacer para internacionalizar este tipo de mensajes es usar localized strings . Este tipo de strings no se toman de manera literal sino que se consideran claves en un archivo .Strings . El sistema sustituir\u00e1 la clave por el valor asociado en el idioma actual. La representaci\u00f3n interna de los mensajes en el c\u00f3digo ser\u00eda parecida, aunque puede ser m\u00e1s breve, ya que no es el mensaje que va a ser el usuario final. 1 2 3 4 5 6 7 8 9 import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"si\" , \"no\" , \"ni_casualidad\" , \"claro\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } En el momento en que queremos asignar el mensaje a un elemento de usuario podemos usar la macro NSLocalizedString , que obtiene el mensaje asociado a la clave 1 2 3 4 @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = NSLocalizedString ( respuesta , comment : \"\" ) } El segundo par\u00e1metro de NSLocalizedString es un comentario que pueda ayudar a un traductor de la app a entender el contexto del mensaje. En este caso no tiene sentido y lo dejamos vac\u00edo. Para que esto funcione nos falta todav\u00eda crear el archivo .strings . Por defecto se debe llamar Localizable.strings . Para crearlo, en Xcode se elige File > New > File . De entre las plantillas disponibles hay que ir a la secci\u00f3n Resource y elegir all\u00ed Strings File . Teniendo seleccionado el archivo, en el File inspector del panel de la derecha de Xcode pulsamos el bot\u00f3n Localize... para que tenga versiones en distintos idiomas. Nos preguntar\u00e1 qu\u00e9 versi\u00f3n inicial queremos crear (por defecto English ). Una vez creada esta podemos marcar el resto de idiomas que hemos a\u00f1adido a nuestra app (en nuestro caso solo espa\u00f1ol) Esto habr\u00e1 creado dos archivos distintos para Localizable.strings , uno para ingl\u00e9s y otro para espa\u00f1ol. Ahora solo tenemos que editar las claves y los valores de cada uno de ellos. Para la versi\u00f3n inglesa ser\u00eda algo como: 1 2 3 4 \"si\" = \"Yes!\" ; \"no\" = \"No!\" ; \"ni_casualidad\" = \"No way!\" ; \"claro\" = \"Sure!\" ; Y para la espa\u00f1ola: 1 2 3 4 \"si\" = \"\u00a1Si!\" ; \"no\" = \"\u00a1No!\" ; \"ni_casualidad\" = \"\u00a1Ni de casualidad!\" ; \"claro\" = \"\u00a1Claro que s\u00ed!\" ; Para probar esta funcionalidad tendremos que ejecutar la app en el simulador y cambiar el idioma desde la aplicaci\u00f3n de settings/configuraci\u00f3n . Es posible que en algunos casos tengamos mensajes con una parte fija y una variable. Por ejemplo un saludo en el que queremos incluir el nombre del usuario. Por desgracia, en la versi\u00f3n actual de iOS la interpolaci\u00f3n de cadenas de Swift todav\u00eda no funciona para los mensajes internacionalizados. Tenemos que usar placeholders en el mensaje, que son caracteres que funcionan de modo similar a como lo hacen los caracteres de formato en el printf de C: 1 2 3 /* .strings en versi\u00f3n ingl\u00e9s */ saludo = \"Welcome %@\" ; ... En este caso, para \"montar\" el mensaje final tenemos que usar un inicializador de String que acepte cadenas de formato: 1 2 let nombre = \"John\" let mensaje = String(format: NSLocalizedString(\"saludo\", comment: \"\"), nombre) N\u00f3tese que estos placeholders ( %@ ) vienen \"heredados\" del lenguaje Objective-C, que utiliza unos caracteres de formato similares a los de C . Por ejemplo para mostrar un n\u00famero entero se usa %d , aunque para mostrar una cadena se usa el car\u00e1cter de formato gen\u00e9rico de \"objeto\", que como se ha visto es %@ .","title":"Localizar los mensajes en el c\u00f3digo"},{"location":"s5/testing/","text":"Testing en Xcode \u00b6 XCode incluye desde la versi\u00f3n 5 un framework de testing llamado XCTest . En el asistente de creaci\u00f3n de un proyecto, cuando elegimos el nombre del proyecto podemos marcar los correspondientes checkbox para crear los tests asociados al proyecto. Como veremos luego con m\u00e1s detalle tenemos dos tipos gen\u00e9ricos de tests: las pruebas unitarias ( unit tests ) y las pruebas de interfaz de usuario ( ui tests ). Si tenemos un proyecto ya creado sin test , podemos crearlos a posteriori con File > New > Target > iOS unit test bundle (o iOS UI test bundle ). El navegador de Tests \u00b6 Para moverse por los tests, lo m\u00e1s sencillo es usar el Test Navigator , que aparece en el \u00e1rea de Navegadores, a la izquierda de la pantalla. Su icono es el quinto por la izquierda, un rombo . En este navegador podemos ver todos los tests, ir al fuente clicando sobre el nombre del test y ejecutarlos pulsando sobre el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece a la derecha cuando pasamos el rat\u00f3n por encima. Pruebas unitarias \u00b6 En XCTest hay varios tipos distintos de pruebas unitarias: Tests de \u201cl\u00f3gica\u201d : lo que todo el mundo entiende habitualmente por pruebas unitarias, es decir pruebas en las que comprobamos si determinado m\u00e9todo funciona o no correctamente. Tests de tiempo de respuesta : en los que podemos ver estad\u00edsticas del tiempo que tarda en ejecutarse determinado bloque de c\u00f3digo. Podemos fijar un baseline de tiempo de modo que el test se considerar\u00e1 que no pasa si est\u00e1 por encima del baseline Tests as\u00edncronos : con c\u00f3digo as\u00edncrono podemos tener el problema de que Xcode no sepa cu\u00e1ndo ha acabado de ejecutarse nuestro c\u00f3digo y por tanto se puede dar por acabado el test. Por ejemplo si lanzamos una petici\u00f3n HTTP no podemos hacer las comprobaciones hasta que no llegue la respuesta. En este tipo de test podemos indicar a Xcode cu\u00e1ndo lo puede dar por terminado, o en caso de sobrepasar un timeout que lo de por fallido. Un ejemplo \u00b6 XCTest es muy similar a otros frameworks de pruebas unitarias como JUnit , as\u00ed que es sencillo de usar para alguien que ya haya usado este \u00faltimo Por ejemplo, supongamos que tenemos un juego de tres en raya y aqu\u00ed tenemos parte del modelo (se omite el c\u00f3digo interno de los m\u00e9todos, para mayor brevedad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 enum Casilla { case vacia , X , O } enum ErrorJuego : Error { case casillaNoExiste } class Juego { var tablero : [[ Casilla ]] func getCasilla ( fila : Int , col : Int ) throws -> Casilla { ... } func setCasilla ( fila : Int , col : Int , valor : Casilla ) throws { ... } init ( filas : Int , cols : Int ) { ... } } \u00bfC\u00f3mo estar razonablemente seguros de que el c\u00f3digo de los m\u00e9todos es correcto?. Podemos comprobar varias cosas, por ejemplo Que cuando se inicializa el tablero todas las casillas est\u00e1n vac\u00edas Que las casillas se pueden obtener/fijar correctamente a un valor dado Que cuando se intenta obtener/fijar una casilla que no existe se produce un error Vamos a ver c\u00f3mo podemos automatizar todas estas comprobaciones en una suite de pruebas. Estructura de una suite de pruebas \u00b6 Podemos ver la estructura que tiene un conjunto o suite de pruebas en la plantilla de tests que crea Xcode. En el caso de nuestro ejemplo podr\u00eda ser algo como lo siguiente (suponiendo que el proyecto se llama TresEnRaya ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import XCTest @ testable import TresEnRaya class TresEnRayaTests : XCTestCase { override func setUp () { super . setUp () // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown () { // Put teardown code here. This method is called after the invocation of each test method in the class. super . tearDown () } donde hay que destacar: El import XCTest incluye las librer\u00edas de testing Con el import TresEnRaya evidentemente importamos el c\u00f3digo del proyecto. El @testable de delante cambia impl\u00edcitamente los modificadores de acceso de las propiedades de las clases del m\u00f3dulo, para que sean accesibles a los test La clase que contiene la suite debe heredar de XCTestCase Al igual que en frameworks de testing como JUnit hay un setUp() y tearDown que se ejecutan al inicio y al final de cada test , respectivamente. En el primero podemos colocar c\u00f3digo que inicialice los valores necesarios antes de cada test y en el segundo \"limpiar\" lo que haya hecho el test si es necesario. Las pruebas unitarias se deben implementar en m\u00e9todos que no devuelvan nada y cuyo nombre debe comenzar por test . Aserciones \u00b6 Las aserciones son las cosas que queremos comprobar que son ciertas. Si lo son, entonces el c\u00f3digo debe estar funcionando correctamente (al menos en el aspecto que estamos comprobando). Para hacer una aserci\u00f3n se usa la familia de m\u00e9todos XCTAssert . Decimos familia porque podemos hacer diferentes tipos de comprobaciones, por ejemplo: Comprobar que algo es cierto con XCTAssert o XCTAssertTrue : por ejemplo comprobar que justo tras inicializar el tres en raya, la posici\u00f3n (0,0) del tablero contiene la casilla vac\u00eda. Comprobar que algo es falso con XCTAssertFalse . Una alternativa a la comprobaci\u00f3n que dec\u00edamos antes ser\u00eda comprobar que no es una X ni tampoco una O. Comprobar que algo es igual a algo con XCTAssertEqual , por ejemplo que tras fijar una casilla a un valor al obtener la casilla obtenemos ese valor. Comprobar que una operaci\u00f3n genera un error con XCTAssertThrowsError : por ejemplo si inicializamos un tablero de 3x3 y luego intentamos acceder a la casilla (5,5). Esto son algunas variantes de XCTAssert aplicables a nuestro ejemplo, pero hay bastantes m\u00e1s (comprobar que algo es menor, mayor que algo, o que una operaci\u00f3n no lanza un error, o que algo es nil ,...). En todas las aserciones podemos poner como par\u00e1metro final un mensaje (Un String ) que aparecer\u00e1 si falla el test 1 XCTAssertTrue ( 3 > 5 , \"Esta prueba va a fallar seguro\" ); Para m\u00e1s detalles sobre los distintos tipos de aserciones se recomienda consultar el apartado \"Test Assertions\" de la documentaci\u00f3n de XCTest Ejecutar las pruebas y ver el resultado \u00b6 En el Test navigator podemos pulsar el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece al pasar el rat\u00f3n por encima de cada test, para ejecutarlo individualmente o bien el que aparece en la suite completa para ejecutar todas sus pruebas. Se pondr\u00e1 en marcha el simulador de iOS con la aplicaci\u00f3n, ejecutar\u00e1 las pruebas y terminar\u00e1. En el test navigator y en el c\u00f3digo fuente de la suite aparecer\u00e1 un icono al lado de cada test indicando si ha pasado o no. Si no ha pasado aparecer\u00e1 adem\u00e1s un mensaje en el fuente indic\u00e1ndolo. Tambi\u00e9n podemos ver los mensajes de error en el Report Navigator .","title":"Testing b\u00e1sico en Xcode"},{"location":"s5/testing/#testing-en-xcode","text":"XCode incluye desde la versi\u00f3n 5 un framework de testing llamado XCTest . En el asistente de creaci\u00f3n de un proyecto, cuando elegimos el nombre del proyecto podemos marcar los correspondientes checkbox para crear los tests asociados al proyecto. Como veremos luego con m\u00e1s detalle tenemos dos tipos gen\u00e9ricos de tests: las pruebas unitarias ( unit tests ) y las pruebas de interfaz de usuario ( ui tests ). Si tenemos un proyecto ya creado sin test , podemos crearlos a posteriori con File > New > Target > iOS unit test bundle (o iOS UI test bundle ).","title":"Testing en Xcode"},{"location":"s5/testing/#el-navegador-de-tests","text":"Para moverse por los tests, lo m\u00e1s sencillo es usar el Test Navigator , que aparece en el \u00e1rea de Navegadores, a la izquierda de la pantalla. Su icono es el quinto por la izquierda, un rombo . En este navegador podemos ver todos los tests, ir al fuente clicando sobre el nombre del test y ejecutarlos pulsando sobre el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece a la derecha cuando pasamos el rat\u00f3n por encima.","title":"El navegador de Tests"},{"location":"s5/testing/#pruebas-unitarias","text":"En XCTest hay varios tipos distintos de pruebas unitarias: Tests de \u201cl\u00f3gica\u201d : lo que todo el mundo entiende habitualmente por pruebas unitarias, es decir pruebas en las que comprobamos si determinado m\u00e9todo funciona o no correctamente. Tests de tiempo de respuesta : en los que podemos ver estad\u00edsticas del tiempo que tarda en ejecutarse determinado bloque de c\u00f3digo. Podemos fijar un baseline de tiempo de modo que el test se considerar\u00e1 que no pasa si est\u00e1 por encima del baseline Tests as\u00edncronos : con c\u00f3digo as\u00edncrono podemos tener el problema de que Xcode no sepa cu\u00e1ndo ha acabado de ejecutarse nuestro c\u00f3digo y por tanto se puede dar por acabado el test. Por ejemplo si lanzamos una petici\u00f3n HTTP no podemos hacer las comprobaciones hasta que no llegue la respuesta. En este tipo de test podemos indicar a Xcode cu\u00e1ndo lo puede dar por terminado, o en caso de sobrepasar un timeout que lo de por fallido.","title":"Pruebas unitarias"},{"location":"s5/testing/#un-ejemplo","text":"XCTest es muy similar a otros frameworks de pruebas unitarias como JUnit , as\u00ed que es sencillo de usar para alguien que ya haya usado este \u00faltimo Por ejemplo, supongamos que tenemos un juego de tres en raya y aqu\u00ed tenemos parte del modelo (se omite el c\u00f3digo interno de los m\u00e9todos, para mayor brevedad) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 enum Casilla { case vacia , X , O } enum ErrorJuego : Error { case casillaNoExiste } class Juego { var tablero : [[ Casilla ]] func getCasilla ( fila : Int , col : Int ) throws -> Casilla { ... } func setCasilla ( fila : Int , col : Int , valor : Casilla ) throws { ... } init ( filas : Int , cols : Int ) { ... } } \u00bfC\u00f3mo estar razonablemente seguros de que el c\u00f3digo de los m\u00e9todos es correcto?. Podemos comprobar varias cosas, por ejemplo Que cuando se inicializa el tablero todas las casillas est\u00e1n vac\u00edas Que las casillas se pueden obtener/fijar correctamente a un valor dado Que cuando se intenta obtener/fijar una casilla que no existe se produce un error Vamos a ver c\u00f3mo podemos automatizar todas estas comprobaciones en una suite de pruebas.","title":"Un ejemplo"},{"location":"s5/testing/#estructura-de-una-suite-de-pruebas","text":"Podemos ver la estructura que tiene un conjunto o suite de pruebas en la plantilla de tests que crea Xcode. En el caso de nuestro ejemplo podr\u00eda ser algo como lo siguiente (suponiendo que el proyecto se llama TresEnRaya ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import XCTest @ testable import TresEnRaya class TresEnRayaTests : XCTestCase { override func setUp () { super . setUp () // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown () { // Put teardown code here. This method is called after the invocation of each test method in the class. super . tearDown () } donde hay que destacar: El import XCTest incluye las librer\u00edas de testing Con el import TresEnRaya evidentemente importamos el c\u00f3digo del proyecto. El @testable de delante cambia impl\u00edcitamente los modificadores de acceso de las propiedades de las clases del m\u00f3dulo, para que sean accesibles a los test La clase que contiene la suite debe heredar de XCTestCase Al igual que en frameworks de testing como JUnit hay un setUp() y tearDown que se ejecutan al inicio y al final de cada test , respectivamente. En el primero podemos colocar c\u00f3digo que inicialice los valores necesarios antes de cada test y en el segundo \"limpiar\" lo que haya hecho el test si es necesario. Las pruebas unitarias se deben implementar en m\u00e9todos que no devuelvan nada y cuyo nombre debe comenzar por test .","title":"Estructura de una suite de pruebas"},{"location":"s5/testing/#aserciones","text":"Las aserciones son las cosas que queremos comprobar que son ciertas. Si lo son, entonces el c\u00f3digo debe estar funcionando correctamente (al menos en el aspecto que estamos comprobando). Para hacer una aserci\u00f3n se usa la familia de m\u00e9todos XCTAssert . Decimos familia porque podemos hacer diferentes tipos de comprobaciones, por ejemplo: Comprobar que algo es cierto con XCTAssert o XCTAssertTrue : por ejemplo comprobar que justo tras inicializar el tres en raya, la posici\u00f3n (0,0) del tablero contiene la casilla vac\u00eda. Comprobar que algo es falso con XCTAssertFalse . Una alternativa a la comprobaci\u00f3n que dec\u00edamos antes ser\u00eda comprobar que no es una X ni tampoco una O. Comprobar que algo es igual a algo con XCTAssertEqual , por ejemplo que tras fijar una casilla a un valor al obtener la casilla obtenemos ese valor. Comprobar que una operaci\u00f3n genera un error con XCTAssertThrowsError : por ejemplo si inicializamos un tablero de 3x3 y luego intentamos acceder a la casilla (5,5). Esto son algunas variantes de XCTAssert aplicables a nuestro ejemplo, pero hay bastantes m\u00e1s (comprobar que algo es menor, mayor que algo, o que una operaci\u00f3n no lanza un error, o que algo es nil ,...). En todas las aserciones podemos poner como par\u00e1metro final un mensaje (Un String ) que aparecer\u00e1 si falla el test 1 XCTAssertTrue ( 3 > 5 , \"Esta prueba va a fallar seguro\" ); Para m\u00e1s detalles sobre los distintos tipos de aserciones se recomienda consultar el apartado \"Test Assertions\" de la documentaci\u00f3n de XCTest","title":"Aserciones"},{"location":"s5/testing/#ejecutar-las-pruebas-y-ver-el-resultado","text":"En el Test navigator podemos pulsar el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece al pasar el rat\u00f3n por encima de cada test, para ejecutarlo individualmente o bien el que aparece en la suite completa para ejecutar todas sus pruebas. Se pondr\u00e1 en marcha el simulador de iOS con la aplicaci\u00f3n, ejecutar\u00e1 las pruebas y terminar\u00e1. En el test navigator y en el c\u00f3digo fuente de la suite aparecer\u00e1 un icono al lado de cada test indicando si ha pasado o no. Si no ha pasado aparecer\u00e1 adem\u00e1s un mensaje en el fuente indic\u00e1ndolo. Tambi\u00e9n podemos ver los mensajes de error en el Report Navigator .","title":"Ejecutar las pruebas y ver el resultado"}]}