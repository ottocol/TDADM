{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tecnolog\u00edas para el Desarrollo de Aplicaciones en Dispositivos M\u00f3viles \u00b6 Bloque de iOS \u00b6 En este bloque de la asignatura veremos los conceptos b\u00e1sicos imprescindibles para empezar a desarrollar aplicaciones m\u00f3viles en iOS. Empezaremos con el lenguaje Swift, que es el lenguaje de desarrollo usado actualmente en la plataforma. Continuaremos explicando la arquitectura est\u00e1ndar de aplicaciones en iOS, que sigue el patr\u00f3n de dise\u00f1o MVC, y veremos los elementos de interfaz b\u00e1sicos de apps sencillas. Terminaremos el m\u00f3dulo con un miniproyecto a modo de recopilaci\u00f3n pr\u00e1ctica de todo lo visto anteriormente.","title":"Tecnolog\u00edas para el Desarrollo de Aplicaciones en Dispositivos M\u00f3viles"},{"location":"#tecnologias-para-el-desarrollo-de-aplicaciones-en-dispositivos-moviles","text":"","title":"Tecnolog\u00edas para el Desarrollo de Aplicaciones en Dispositivos M\u00f3viles"},{"location":"#bloque-de-ios","text":"En este bloque de la asignatura veremos los conceptos b\u00e1sicos imprescindibles para empezar a desarrollar aplicaciones m\u00f3viles en iOS. Empezaremos con el lenguaje Swift, que es el lenguaje de desarrollo usado actualmente en la plataforma. Continuaremos explicando la arquitectura est\u00e1ndar de aplicaciones en iOS, que sigue el patr\u00f3n de dise\u00f1o MVC, y veremos los elementos de interfaz b\u00e1sicos de apps sencillas. Terminaremos el m\u00f3dulo con un miniproyecto a modo de recopilaci\u00f3n pr\u00e1ctica de todo lo visto anteriormente.","title":"Bloque de iOS"},{"location":"SUMMARY/","text":"Contenidos \u00b6 Introducci\u00f3n a Swift Preliminares Variables y constantes Tipos de datos de la librer\u00eda est\u00e1ndar Colecciones Control de flujo Funciones Opcionales Clases Extensiones Enumerados Ejercicios Introducci\u00f3n a las aplicaciones iOS Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC Comenzando nuestra primera aplicaci\u00f3n iOS Estructura del c\u00f3digo de una aplicaci\u00f3n La plantilla creada por Xcode Creaci\u00f3n de la interfaz (la vista) Implementaci\u00f3n del modelo Implementaci\u00f3n del controlador Recibir eventos de la vista Llamar al modelo Modificar la vista Ejercicios Internacionalizaci\u00f3n de aplicaciones iOS A\u00f1adir soporte para i18n Localizar la interfaz gr\u00e1fica Localizar los mensajes en el c\u00f3digo M\u00e1s sobre Swift Clausuras Estructuras Gesti\u00f3n de errores Protocolos Delegaci\u00f3n Concurrencia b\u00e1sica en iOS APIs de concurrencia Colas de operaciones Comunicaci\u00f3n modelo-controlador Notificaciones locales Key-Value Observing Miniproyecto: Juego de las siete y media El modelo Pruebas unitarias Interfaz gr\u00e1fico simplificado Completar la interfaz Posibles mejoras Ap\u00e9ndice 1: control de versiones con Xcode Ap\u00e9ndice 2: Testing en Xcode El navegador de tests Pruebas unitarias","title":"Contenidos"},{"location":"SUMMARY/#contenidos","text":"Introducci\u00f3n a Swift Preliminares Variables y constantes Tipos de datos de la librer\u00eda est\u00e1ndar Colecciones Control de flujo Funciones Opcionales Clases Extensiones Enumerados Ejercicios Introducci\u00f3n a las aplicaciones iOS Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC Comenzando nuestra primera aplicaci\u00f3n iOS Estructura del c\u00f3digo de una aplicaci\u00f3n La plantilla creada por Xcode Creaci\u00f3n de la interfaz (la vista) Implementaci\u00f3n del modelo Implementaci\u00f3n del controlador Recibir eventos de la vista Llamar al modelo Modificar la vista Ejercicios Internacionalizaci\u00f3n de aplicaciones iOS A\u00f1adir soporte para i18n Localizar la interfaz gr\u00e1fica Localizar los mensajes en el c\u00f3digo M\u00e1s sobre Swift Clausuras Estructuras Gesti\u00f3n de errores Protocolos Delegaci\u00f3n Concurrencia b\u00e1sica en iOS APIs de concurrencia Colas de operaciones Comunicaci\u00f3n modelo-controlador Notificaciones locales Key-Value Observing Miniproyecto: Juego de las siete y media El modelo Pruebas unitarias Interfaz gr\u00e1fico simplificado Completar la interfaz Posibles mejoras Ap\u00e9ndice 1: control de versiones con Xcode Ap\u00e9ndice 2: Testing en Xcode El navegador de tests Pruebas unitarias","title":"Contenidos"},{"location":"apendices/control_versiones/","text":"Control de versiones con Xcode \u00b6 Crear un repositorio local para el proyecto \u00b6 En este apartado veremos c\u00f3mo trabajar con un repositorio git local . Tenemos dos opciones: crear el repositorio git local al crear el proyecto o a\u00f1adirlo con posterioridad. Para crear el repositorio git local al crear el proyecto : en la \u00faltima pantalla del asistente (la misma donde se selecciona en qu\u00e9 carpeta guardar f\u00edsicamente el proyecto) veremos una casilla de verificaci\u00f3n que podemos marcar para crear un repositorio Git local ( Create Git repository on my Mac ) Para crear el repositorio git local una vez creado el proyecto : en cualquier momento, vamos al men\u00fa de Source Control , opci\u00f3n Create git repositories... . Nos pedir\u00e1 que marquemos para qu\u00e9 proyectos de los que tenemos abiertos queremos crear un repositorio git. En los dos casos Xcode har\u00e1 autom\u00e1ticamente un commit inicial del proyecto con el mensaje \"initial commit\" (recordad que cuando Xcode crea un proyecto iOS no est\u00e1 vac\u00edo sino que tiene algunos archivos, dependiendo de la plantilla elegida). Podemos ver m\u00e1s informaci\u00f3n sobre el repositorio git con el Source Control Navigator , que es el segundo icono del panel de la izquierda de Xcode. Trabajar con un repositorio remoto \u00b6 Usaremos github en los ejemplos ya que es el servidor que empleamos en el curso, pero las instrucciones son pr\u00e1cticamente iguales para otros proveedores como Bitbucket o Gitlab. Configurar la cuenta de nuestro proveedor \u00b6 Lo m\u00e1s c\u00f3modo es guardar primero los datos de nuestra cuenta en Github, para no tener que introducirlos cada vez que hagamos una operaci\u00f3n con el repositorio remoto. Para ello nos vamos a las prerencias de Xcode (Men\u00fa Xcode > Preferences... , o bien pulsar la tecla Command-, - cmd y una coma) y en la barra de herramientas seleccionamos la opci\u00f3n Accounts Desde esta opci\u00f3n podemos gestionar nuestra cuenta de desarrollador de Apple y tambi\u00e9n cuentas de terceros como Github, Bitbucket, etc. En la esquina inferior izquierda pulsamos sobre el + para a\u00f1adir una cuenta y seleccionamos el tipo (en nuestro caso \"Github\"). Xcode nos pedir\u00e1 que introduzcamos el usuario de Github y un personal access token , que sustituye a la contrase\u00f1a de Github para autentificarse a trav\u00e9s del API (Xcode usa el API de Github para interactuar con los repositorios) Desde hace alg\u00fan tiempo la contrase\u00f1a de github solo se puede usar para autentificarse en el sitio web, pero no para el API de Github , lo que incluye el uso de la herramienta git directamente o a trav\u00e9s de un IDE. En su lugar hay que usar un token que se puede generar desde la p\u00e1gina de Github. Vincular con el repositorio remoto \u00b6 Repositorio remoto ya creado \u00b6 Si ya hemos creado el repositorio git remoto, solo necesitamos saber su URL. En Xcode, vamos al Source Control Navigator , (segundo icono del panel de la izquierda de Xcode), pulsamos con el bot\u00f3n derecho del rat\u00f3n y en el men\u00fa contextual seleccionamos Add Existing Remote... En el cuadro de di\u00e1logo que aparecer\u00e1 colocamos la URL del repositorio remoto en el campo Location Crear el repositorio remoto desde Xcode \u00b6 Esta opci\u00f3n solo est\u00e1 disponible desde la versi\u00f3n 10 de Xcode. En el Source Control Navigator , (segundo icono del panel de la izquierda de Xcode), pulsamos con el bot\u00f3n derecho del rat\u00f3n y en el men\u00fa contextual seleccionamos Create ( nombre del proyecto ) Remote... . En el cuadro de di\u00e1logo que aparecer\u00e1 podemos seleccionar la cuenta (en nuestro caso Github), el nombre que tendr\u00e1 el repositorio, si va a ser p\u00fablico o privado, etc... Xcode har\u00e1 un push autom\u00e1ticamente tras crear el repositorio remoto Trabajar con el control de versiones \u00b6 Cuando el proyecto actual est\u00e9 bajo el control de versiones ver\u00e1s que en el Project Navigator del panel de la izquierda (el modo por defecto de ver los archivos del proyecto) los archivos que se han a\u00f1adido desde el \u00faltimo commit tienen una A a la derecha y los modificados una M . Ten en cuenta que tras crear el proyecto, si has creado el repositorio local, Xcode hace autom\u00e1ticamente un commit inicial y por eso ning\u00fan archivo aparece inicialmente marcado con una A , solo lo ver\u00e1s cuando crees archivos nuevos o modifiques los de la plantilla. Las operaciones a realizar con el control de versiones est\u00e1n localizadas en el men\u00fa principal de Xcode, en la opci\u00f3n Source Control . Las operaciones m\u00e1s habituales son: commit : aparecer\u00e1 un cuadro de di\u00e1logo (bastante grande) con todos los archivos que han cambiado desde el \u00faltimo commit. Por defecto aparecer\u00e1n seleccionados todos pero puedes seleccionar solo los que te interesen. En la parte inferior del cuadro de di\u00e1logo tendr\u00e1s que escribir el mensaje asociado al commit . push : aparecer\u00e1 un peque\u00f1o cuadro de di\u00e1logo en el que puedes elegir el repositorio remoto al que subir los cambios. Normalmente solo tendremos un remoto vinculado, de modo que bastar\u00e1 con pulsar sobre Push pull : igual a lo anterior pero ser\u00e1 para traerse los cambios desde el repositorio remoto. Discard all changes : volver\u00e1 a la versi\u00f3n local que ten\u00edamos en el \u00faltimo commit .","title":"Control de versiones en Xcode"},{"location":"apendices/control_versiones/#control-de-versiones-con-xcode","text":"","title":"Control de versiones con Xcode"},{"location":"apendices/control_versiones/#crear-un-repositorio-local-para-el-proyecto","text":"En este apartado veremos c\u00f3mo trabajar con un repositorio git local . Tenemos dos opciones: crear el repositorio git local al crear el proyecto o a\u00f1adirlo con posterioridad. Para crear el repositorio git local al crear el proyecto : en la \u00faltima pantalla del asistente (la misma donde se selecciona en qu\u00e9 carpeta guardar f\u00edsicamente el proyecto) veremos una casilla de verificaci\u00f3n que podemos marcar para crear un repositorio Git local ( Create Git repository on my Mac ) Para crear el repositorio git local una vez creado el proyecto : en cualquier momento, vamos al men\u00fa de Source Control , opci\u00f3n Create git repositories... . Nos pedir\u00e1 que marquemos para qu\u00e9 proyectos de los que tenemos abiertos queremos crear un repositorio git. En los dos casos Xcode har\u00e1 autom\u00e1ticamente un commit inicial del proyecto con el mensaje \"initial commit\" (recordad que cuando Xcode crea un proyecto iOS no est\u00e1 vac\u00edo sino que tiene algunos archivos, dependiendo de la plantilla elegida). Podemos ver m\u00e1s informaci\u00f3n sobre el repositorio git con el Source Control Navigator , que es el segundo icono del panel de la izquierda de Xcode.","title":"Crear un repositorio local para el proyecto"},{"location":"apendices/control_versiones/#trabajar-con-un-repositorio-remoto","text":"Usaremos github en los ejemplos ya que es el servidor que empleamos en el curso, pero las instrucciones son pr\u00e1cticamente iguales para otros proveedores como Bitbucket o Gitlab.","title":"Trabajar con un repositorio remoto"},{"location":"apendices/control_versiones/#configurar-la-cuenta-de-nuestro-proveedor","text":"Lo m\u00e1s c\u00f3modo es guardar primero los datos de nuestra cuenta en Github, para no tener que introducirlos cada vez que hagamos una operaci\u00f3n con el repositorio remoto. Para ello nos vamos a las prerencias de Xcode (Men\u00fa Xcode > Preferences... , o bien pulsar la tecla Command-, - cmd y una coma) y en la barra de herramientas seleccionamos la opci\u00f3n Accounts Desde esta opci\u00f3n podemos gestionar nuestra cuenta de desarrollador de Apple y tambi\u00e9n cuentas de terceros como Github, Bitbucket, etc. En la esquina inferior izquierda pulsamos sobre el + para a\u00f1adir una cuenta y seleccionamos el tipo (en nuestro caso \"Github\"). Xcode nos pedir\u00e1 que introduzcamos el usuario de Github y un personal access token , que sustituye a la contrase\u00f1a de Github para autentificarse a trav\u00e9s del API (Xcode usa el API de Github para interactuar con los repositorios) Desde hace alg\u00fan tiempo la contrase\u00f1a de github solo se puede usar para autentificarse en el sitio web, pero no para el API de Github , lo que incluye el uso de la herramienta git directamente o a trav\u00e9s de un IDE. En su lugar hay que usar un token que se puede generar desde la p\u00e1gina de Github.","title":"Configurar la cuenta de nuestro proveedor"},{"location":"apendices/control_versiones/#vincular-con-el-repositorio-remoto","text":"","title":"Vincular con el repositorio remoto"},{"location":"apendices/control_versiones/#trabajar-con-el-control-de-versiones","text":"Cuando el proyecto actual est\u00e9 bajo el control de versiones ver\u00e1s que en el Project Navigator del panel de la izquierda (el modo por defecto de ver los archivos del proyecto) los archivos que se han a\u00f1adido desde el \u00faltimo commit tienen una A a la derecha y los modificados una M . Ten en cuenta que tras crear el proyecto, si has creado el repositorio local, Xcode hace autom\u00e1ticamente un commit inicial y por eso ning\u00fan archivo aparece inicialmente marcado con una A , solo lo ver\u00e1s cuando crees archivos nuevos o modifiques los de la plantilla. Las operaciones a realizar con el control de versiones est\u00e1n localizadas en el men\u00fa principal de Xcode, en la opci\u00f3n Source Control . Las operaciones m\u00e1s habituales son: commit : aparecer\u00e1 un cuadro de di\u00e1logo (bastante grande) con todos los archivos que han cambiado desde el \u00faltimo commit. Por defecto aparecer\u00e1n seleccionados todos pero puedes seleccionar solo los que te interesen. En la parte inferior del cuadro de di\u00e1logo tendr\u00e1s que escribir el mensaje asociado al commit . push : aparecer\u00e1 un peque\u00f1o cuadro de di\u00e1logo en el que puedes elegir el repositorio remoto al que subir los cambios. Normalmente solo tendremos un remoto vinculado, de modo que bastar\u00e1 con pulsar sobre Push pull : igual a lo anterior pero ser\u00e1 para traerse los cambios desde el repositorio remoto. Discard all changes : volver\u00e1 a la versi\u00f3n local que ten\u00edamos en el \u00faltimo commit .","title":"Trabajar con el control de versiones"},{"location":"miniproyecto/proyecto/","text":"MiniProyecto de iOS (6 puntos en total) \u00b6 Juego de las siete y media \u00b6 Se propone implementar el conocido juego de cartas de \" las 7 y media \". Para simplificar, solo habr\u00e1 dos jugadores: el usuario contra la m\u00e1quina que hace de banca. El usuario va pidiendo cartas una a una hasta que se pasa de 7 y medio o decide plantarse. La m\u00e1quina no va sacando cartas una a una sino que obtiene una puntuaci\u00f3n generada al azar. Para crear el proyecto, como siempre hacemos, elige la plantilla de App . En la segunda pantalla del asistente dale como nombre SieteyMedia y aseg\u00farate que en el interface pone Storyboard (como todas las apps que hemos hecho hasta ahora lo usan ya deber\u00eda salir por defecto). Estructura de clases del modelo (2 puntos) \u00b6 Necesit\u00e1is implementar primero el enum Palo y las clases Carta y Mano . Estos se propon\u00edan como ejercicio el primer d\u00eda de clase, aunque es posible que no os haya dado tiempo a hacerlos, pod\u00e9is hacerlos ahora. Adem\u00e1s hay que a\u00f1adir dos clases necesarias para poder jugar: la Baraja y el propio Juego Clase Baraja \u00b6 Todas las cartas de la baraja. Del 1 al 12 de los cuatro palos, menos 8 y 9 Propiedades: cartas , un array de Carta M\u00e9todos: El init() debe rellenar el array de cartas con todas las cartas de la baraja. Pod\u00e9is ir generando todos los n\u00fameros de todos los palos con un bucle doble de este estilo: for palo in [ Palo . bastos , Palo . espadas , Palo . copas , Palo . oros ] { for valor in 1. .. 12 { if valor != 8 && valor != 9 { //El 8 y el 9 no se suelen usar //Aqu\u00ed crear\u00edais la nueva carta y la a\u00f1adir\u00edais al array \"cartas\" } } } repartirCarta() : devuelve la \u00faltima carta de la baraja y la elimina de ella. Es lo que hace exactamente el m\u00e9todo de la clase Array popLast() , devolver el \u00faltimo valor de un array y eliminarlo de \u00e9l. barajar() : debe cambiar al azar el orden de las cartas en el Array . Esto lo hace directamente el m\u00e9todo shuffle() del Array . Clase Juego \u00b6 Es la clase que implementa las reglas del juego de las siete y media. Os dejo aqu\u00ed una implementaci\u00f3n que pod\u00e9is usar para no gastar demasiado tiempo haciendo la vuestra propia desde cero. No obstante no est\u00e1 completa, ten\u00e9is que implementar el m\u00e9todo acabarPartida() . Para simplificar el juego, en esta implementaci\u00f3n la m\u00e1quina no saca cartas de verdad, una a una. Se genera una puntuaci\u00f3n al azar entre 1 y 7.5 y se informa al usuario de la puntuaci\u00f3n que ha sacado. Para que el juego as\u00ed tenga sentido, primero juega el jugador humano y luego la m\u00e1quina. //Esto de momento no se usa, pero luego s\u00ed, ya que necesitaremos notificaciones import Foundation enum EstadoJuego { case turnoJugador , ganaJugador , pierdeJugador , empate , noIniciado } //Versi\u00f3n simplificada de las 7 y media en la que la m\u00e1quina no saca cartas una a una //sino que simula la jugada generando un valor al azar entre 1 y 7.5 (no se pasa nunca!) class Juego { var baraja : Baraja ! var manoJugador : Mano ! var estado : EstadoJuego var jugadaMaquina : Double = 0.0 init () { self . estado = EstadoJuego . noIniciado } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"comenzar partida\" func comenzarPartida () { self . baraja = Baraja () self . baraja . barajar () self . manoJugador = Mano () //generamos un valor al azar entre 1 y 7.5. La m\u00e1quina nunca se pasa //primero generamos un valor entre 1 y 7 jugadaMaquina = Double ( Int . random ( in : 1. .. 7 )) //y luego el 50% de las veces le sumamos 0.5 if ( Bool . random ()) { jugadaMaquina += 0.5 } } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"Pedir carta\" func jugadorPideCarta () { if let pedida = self . baraja . repartirCarta () { print ( \"Sacas \\( pedida . descripcion ()) \" ) self . manoJugador . addCarta ( pedida ) let valorMano = self . sumarManoJugador () print ( \"Llevas \\( valorMano ) puntos\" ) if ( valorMano > 7.5 ) { acabarPartida () } } } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"Plantarse\" func jugadorSePlanta () { acabarPartida () } //M\u00e9todos para uso interno de la clase, no es necesario llamarlos desde fuera //Calcula qui\u00e9n gana, cambia el estado del juego y lo muestra en la consola con print private func acabarPartida () { // TODO: sumar el valor de las cartas del jugador // TODO: calcular qui\u00e9n gana, en funci\u00f3n de esta suma y la jugada de la m\u00e1quina // TODO: cambiar el estado del juego al valor apropiado e imprimir un mensaje // TODO: en la interfaz completa, enviar notificaci\u00f3n al ViewController indicando que la partida ha terminado, // TODO: para que este habilite/deshabilite botones y muestre con un \"alert\" el resultado } } Interfaz simplificada (1 punto) \u00b6 El ViewController contendr\u00e1 una instancia de la clase Juego . class ViewController : UIViewController { let juego = Juego () ... } En esta versi\u00f3n muy simplificada de la interfaz solo aparecen en pantalla tres botones: \"pedir carta\", \"plantarse\" y \"nueva partida\", pero no se ven las cartas gr\u00e1ficamente. Eso s\u00ed, el juego deber\u00eda funcionar correctamente, imprimiendo los mensajes con print . Tendr\u00e1s que conectar con action (gr\u00e1ficamente) los botones del juego con funciones del view controller que a su vez llamen a los m\u00e9todos del objeto juego . Aunque al principio solo deber\u00eda poder pulsarse el bot\u00f3n \"nueva partida\" y una vez comenzada solo los otros dos, etc... de momento no nos preocuparemos de esto y dejaremos que se pueda pulsar cualquier bot\u00f3n, asumiendo que el usuario nunca pulsar\u00e1 un bot\u00f3n que no deber\u00eda \ud83d\ude44 Interfaz completa (1.5 puntos) \u00b6 En la interfaz completa deber\u00edan aparecer pintadas las cartas en pantalla conforme se van repartiendo. Adem\u00e1s los botones se deber\u00edan habilitar/deshabilitar adecuadamente (por ejemplo si la partida se ha terminado no se puede pedir carta). A\u00f1adir las im\u00e1genes de las cartas al proyecto \u00b6 Descomprime el .zip de Moodle con las im\u00e1genes de las cartas en png, selecciona todos los archivos y \"d\u00e9jalos caer\" dentro de la carpeta de recursos ( Assets.xcassets ). Por cada imagen en png crear\u00e1 un image set con el nombre del archivo ( al estilo 1oros , 3copas , ...). Por desgracia solo disponemos de las im\u00e1genes de las cartas en baja resoluci\u00f3n (@1x). C\u00f3mo dibujar las cartas \u00b6 Cada vez que dibujemos en pantalla una carta estamos a\u00f1adiendo a la pantalla actual un UIImageView . Tenemos que guardar referencias a todas las im\u00e1genes a\u00f1adidas para poder borrarlas cuando acabe la partida. Definiremos esta propiedad en el view controller para guardarlas //propiedad de ViewController.swift var vistasCartas : [ UIImageView ] = [] En lugar de dibujar las cartas directamente en su posici\u00f3n final, podemos hacerlo fuera de la pantalla (es decir, con el origen del frame en coordenadas negativas) y luego hacer una animaci\u00f3n hasta su posici\u00f3n definitiva. La siguiente funci\u00f3n dibujarCarta(carta: Carta, posicion : Int) dibuja una carta con el efecto descrito. La posicion es el orden de la carta, para que se vayan colocando una al lado de la otra: 1, 2... En el c\u00f3digo de ejemplo usamos un tama\u00f1o de carta fijo de 70x100 puntos, en el apartado siguiente se te propone adaptarlo al tama\u00f1o real de la pantalla. N\u00f3tese que hablamos de puntos y no de pixeles ya que en c\u00f3digo no se usa la resoluci\u00f3n f\u00edsica sino una resoluci\u00f3n \"l\u00f3gica\". Hay dispositivos que tienen distinta resoluci\u00f3n f\u00edsica pero usan la misma resoluci\u00f3n l\u00f3gica, lo que simplifica el desarrollo. Pod\u00e9is ver una tabla con resoluciones f\u00edsicas y l\u00f3gicas de distintos dispositivos iOS en https://www.ios-resolution.com/ IMPORTANTE: para que la segunda l\u00ednea de este c\u00f3digo funcione tu tipo enumerado Palo debe tener un valor \"interno\" de tipo String . Esto lo puedes conseguir simplemente poniendo enum Palo : String en la definici\u00f3n del tipo. func dibujarCarta ( carta : Carta , posicion : Int ) { let nombreImagen = String ( carta . valor ) + String ( carta . palo . rawValue ) //creamos un objeto imagen let imagenCarta = UIImage ( named : nombreImagen ) //para que la imagen sea un componente m\u00e1s del UI, //la encapsulamos en un UIImageView let cartaView = UIImageView ( image : imagenCarta ) //Inicialmente la colocamos fuera de la pantalla y m\u00e1s grande //para que parezca m\u00e1s cercana //\"frame\" son los l\u00edmites de la vista, definen pos y tama\u00f1o cartaView . frame = CGRect ( x : - 200 , y : - 200 , width : 200 , height : 300 ) //La rotamos, para que al \"repartirla\" haga un efecto de giro cartaView . transform = CGAffineTransform ( rotationAngle : CGFloat ( Double . pi )); //La a\u00f1adimos a la vista principal, si no no ser\u00eda visible self . view . addSubview ( cartaView ) //guardamos la vista en el array, para luego poder eliminarla self . vistasCartas . append ( cartaView ) //Animaci\u00f3n de repartir carta UIView . animate ( withDuration : 0.5 ){ //\"efecto caida\": la llevamos a la posici\u00f3n final cartaView . frame = CGRect ( x : 50 + 70 * ( posicion - 1 ), y : 100 , width : 70 , height : 100 ); //0 como \u00e1ngulo \"destino\", para que rote mientras \"cae\" cartaView . transform = CGAffineTransform ( rotationAngle : 0 ); } } Eliminar las cartas de la pantalla \u00b6 Una vez ha terminado la partida, o justo cuando comienza la siguiente, hay que borrar todas las cartas de la pantalla. Vamos recorriendo el array self.vistasCartas del view controller y vamos eliminando las cartas de la pantalla: //Quitamos las cartas de la pantalla for vistaCarta in self . vistasCartas { vistaCarta . removeFromSuperview () } //ya no tenemos im\u00e1genes de cartas en pantalla, ponemos el array a vac\u00edo self . vistasCartas =[] Adaptar los dibujos a la resoluci\u00f3n de la pantalla (0.5 puntos ADICIONALES) \u00b6 OPCIONALMENTE, en lugar de dibujar las cartas con un tama\u00f1o y unas posiciones \"fijas\", puedes usar un porcentaje o fracci\u00f3n del ancho y alto total de la pantalla. Puedes obtener el ancho y alto de la pantalla del siguiente modo: let limitesPantalla = UIScreen . main . bounds let anchoPantalla = limitesPantalla . width let altoPantalla = limitesPantalla . height C\u00f3mo manipular los botones \u00b6 Pod\u00e9is habilitar/deshabilitar los botones por c\u00f3digo poniendo su propiedad isEnabled a true o false respectivamente. Para que un bot\u00f3n aparezca inicialmente deshabilitado, en el \"attributes inspector\" de la parte derecha de Xcode desmarcar la casilla enabled dentro de state (est\u00e1 a mitad de panel). Un problema es c\u00f3mo enterarnos en el ViewController de que la partida ha acabado para habilitar y deshabilitar los correspondientes botones, y para mostrar el resultado con un cuadro de di\u00e1logo. Podemos hacerlo con notificaciones: A\u00f1adir c\u00f3digo Swift a la funci\u00f3n acabarPartida() de la clase Juego para que se env\u00ede una notificaci\u00f3n con el nombre y contenido que quer\u00e1is (como contenido deber\u00eda tener como m\u00ednimo una frase resumiendo el resultado del juego para que pod\u00e1is mostrarlo). A\u00f1adir c\u00f3digo Swift al ViewController para que si se recibe la notificaci\u00f3n se ejecute un m\u00e9todo de \u00e9ste que habilite/deshabilite botones y muestre el resultado C\u00f3mo mostrar mensajes al usuario \u00b6 Pod\u00e9is mostrar el resultado del juego (\"has ganado\", \"te has pasado\",...) con un UIAlertController , que har\u00e1 aparecer el t\u00edpico cuadro de di\u00e1logo modal. El siguiente c\u00f3digo muestra un cuadro que pone \"\u00a1\u00a1Has perdido!!\", con el t\u00edtulo \"Fin del juego\", y con un \u00fanico bot\u00f3n de \"OK\" que no hace nada especial, m\u00e1s que quitar el cuadro de di\u00e1logo. let alert = UIAlertController ( title : \"Fin del juego\" , message : \"\u00a1\u00a1Has perdido!!\" , preferredStyle : UIAlertControllerStyle . alert ) let action = UIAlertAction ( title : \"OK\" , style : UIAlertActionStyle . default ) alert . addAction ( action ) self . present ( alert , animated : true , completion : nil ) i18n (1.5 puntos) \u00b6 Internacionaliza la aplicaci\u00f3n para que est\u00e9 localizada al menos en dos idiomas, los que t\u00fa prefieras","title":"MiniProyecto de iOS (6 puntos en total)"},{"location":"miniproyecto/proyecto/#miniproyecto-de-ios-6-puntos-en-total","text":"","title":"MiniProyecto de iOS (6 puntos en total)"},{"location":"miniproyecto/proyecto/#juego-de-las-siete-y-media","text":"Se propone implementar el conocido juego de cartas de \" las 7 y media \". Para simplificar, solo habr\u00e1 dos jugadores: el usuario contra la m\u00e1quina que hace de banca. El usuario va pidiendo cartas una a una hasta que se pasa de 7 y medio o decide plantarse. La m\u00e1quina no va sacando cartas una a una sino que obtiene una puntuaci\u00f3n generada al azar. Para crear el proyecto, como siempre hacemos, elige la plantilla de App . En la segunda pantalla del asistente dale como nombre SieteyMedia y aseg\u00farate que en el interface pone Storyboard (como todas las apps que hemos hecho hasta ahora lo usan ya deber\u00eda salir por defecto).","title":"Juego de las siete y media"},{"location":"miniproyecto/proyecto/#estructura-de-clases-del-modelo-2-puntos","text":"Necesit\u00e1is implementar primero el enum Palo y las clases Carta y Mano . Estos se propon\u00edan como ejercicio el primer d\u00eda de clase, aunque es posible que no os haya dado tiempo a hacerlos, pod\u00e9is hacerlos ahora. Adem\u00e1s hay que a\u00f1adir dos clases necesarias para poder jugar: la Baraja y el propio Juego","title":"Estructura de clases del modelo (2 puntos)"},{"location":"miniproyecto/proyecto/#clase-baraja","text":"Todas las cartas de la baraja. Del 1 al 12 de los cuatro palos, menos 8 y 9 Propiedades: cartas , un array de Carta M\u00e9todos: El init() debe rellenar el array de cartas con todas las cartas de la baraja. Pod\u00e9is ir generando todos los n\u00fameros de todos los palos con un bucle doble de este estilo: for palo in [ Palo . bastos , Palo . espadas , Palo . copas , Palo . oros ] { for valor in 1. .. 12 { if valor != 8 && valor != 9 { //El 8 y el 9 no se suelen usar //Aqu\u00ed crear\u00edais la nueva carta y la a\u00f1adir\u00edais al array \"cartas\" } } } repartirCarta() : devuelve la \u00faltima carta de la baraja y la elimina de ella. Es lo que hace exactamente el m\u00e9todo de la clase Array popLast() , devolver el \u00faltimo valor de un array y eliminarlo de \u00e9l. barajar() : debe cambiar al azar el orden de las cartas en el Array . Esto lo hace directamente el m\u00e9todo shuffle() del Array .","title":"Clase Baraja"},{"location":"miniproyecto/proyecto/#clase-juego","text":"Es la clase que implementa las reglas del juego de las siete y media. Os dejo aqu\u00ed una implementaci\u00f3n que pod\u00e9is usar para no gastar demasiado tiempo haciendo la vuestra propia desde cero. No obstante no est\u00e1 completa, ten\u00e9is que implementar el m\u00e9todo acabarPartida() . Para simplificar el juego, en esta implementaci\u00f3n la m\u00e1quina no saca cartas de verdad, una a una. Se genera una puntuaci\u00f3n al azar entre 1 y 7.5 y se informa al usuario de la puntuaci\u00f3n que ha sacado. Para que el juego as\u00ed tenga sentido, primero juega el jugador humano y luego la m\u00e1quina. //Esto de momento no se usa, pero luego s\u00ed, ya que necesitaremos notificaciones import Foundation enum EstadoJuego { case turnoJugador , ganaJugador , pierdeJugador , empate , noIniciado } //Versi\u00f3n simplificada de las 7 y media en la que la m\u00e1quina no saca cartas una a una //sino que simula la jugada generando un valor al azar entre 1 y 7.5 (no se pasa nunca!) class Juego { var baraja : Baraja ! var manoJugador : Mano ! var estado : EstadoJuego var jugadaMaquina : Double = 0.0 init () { self . estado = EstadoJuego . noIniciado } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"comenzar partida\" func comenzarPartida () { self . baraja = Baraja () self . baraja . barajar () self . manoJugador = Mano () //generamos un valor al azar entre 1 y 7.5. La m\u00e1quina nunca se pasa //primero generamos un valor entre 1 y 7 jugadaMaquina = Double ( Int . random ( in : 1. .. 7 )) //y luego el 50% de las veces le sumamos 0.5 if ( Bool . random ()) { jugadaMaquina += 0.5 } } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"Pedir carta\" func jugadorPideCarta () { if let pedida = self . baraja . repartirCarta () { print ( \"Sacas \\( pedida . descripcion ()) \" ) self . manoJugador . addCarta ( pedida ) let valorMano = self . sumarManoJugador () print ( \"Llevas \\( valorMano ) puntos\" ) if ( valorMano > 7.5 ) { acabarPartida () } } } //LLamar a este m\u00e9todo cuando se pulse el bot\u00f3n de \"Plantarse\" func jugadorSePlanta () { acabarPartida () } //M\u00e9todos para uso interno de la clase, no es necesario llamarlos desde fuera //Calcula qui\u00e9n gana, cambia el estado del juego y lo muestra en la consola con print private func acabarPartida () { // TODO: sumar el valor de las cartas del jugador // TODO: calcular qui\u00e9n gana, en funci\u00f3n de esta suma y la jugada de la m\u00e1quina // TODO: cambiar el estado del juego al valor apropiado e imprimir un mensaje // TODO: en la interfaz completa, enviar notificaci\u00f3n al ViewController indicando que la partida ha terminado, // TODO: para que este habilite/deshabilite botones y muestre con un \"alert\" el resultado } }","title":"Clase Juego"},{"location":"miniproyecto/proyecto/#interfaz-simplificada-1-punto","text":"El ViewController contendr\u00e1 una instancia de la clase Juego . class ViewController : UIViewController { let juego = Juego () ... } En esta versi\u00f3n muy simplificada de la interfaz solo aparecen en pantalla tres botones: \"pedir carta\", \"plantarse\" y \"nueva partida\", pero no se ven las cartas gr\u00e1ficamente. Eso s\u00ed, el juego deber\u00eda funcionar correctamente, imprimiendo los mensajes con print . Tendr\u00e1s que conectar con action (gr\u00e1ficamente) los botones del juego con funciones del view controller que a su vez llamen a los m\u00e9todos del objeto juego . Aunque al principio solo deber\u00eda poder pulsarse el bot\u00f3n \"nueva partida\" y una vez comenzada solo los otros dos, etc... de momento no nos preocuparemos de esto y dejaremos que se pueda pulsar cualquier bot\u00f3n, asumiendo que el usuario nunca pulsar\u00e1 un bot\u00f3n que no deber\u00eda \ud83d\ude44","title":"Interfaz simplificada (1 punto)"},{"location":"miniproyecto/proyecto/#interfaz-completa-15-puntos","text":"En la interfaz completa deber\u00edan aparecer pintadas las cartas en pantalla conforme se van repartiendo. Adem\u00e1s los botones se deber\u00edan habilitar/deshabilitar adecuadamente (por ejemplo si la partida se ha terminado no se puede pedir carta).","title":"Interfaz completa (1.5 puntos)"},{"location":"miniproyecto/proyecto/#anadir-las-imagenes-de-las-cartas-al-proyecto","text":"Descomprime el .zip de Moodle con las im\u00e1genes de las cartas en png, selecciona todos los archivos y \"d\u00e9jalos caer\" dentro de la carpeta de recursos ( Assets.xcassets ). Por cada imagen en png crear\u00e1 un image set con el nombre del archivo ( al estilo 1oros , 3copas , ...). Por desgracia solo disponemos de las im\u00e1genes de las cartas en baja resoluci\u00f3n (@1x).","title":"A\u00f1adir las im\u00e1genes de las cartas al proyecto"},{"location":"miniproyecto/proyecto/#como-dibujar-las-cartas","text":"Cada vez que dibujemos en pantalla una carta estamos a\u00f1adiendo a la pantalla actual un UIImageView . Tenemos que guardar referencias a todas las im\u00e1genes a\u00f1adidas para poder borrarlas cuando acabe la partida. Definiremos esta propiedad en el view controller para guardarlas //propiedad de ViewController.swift var vistasCartas : [ UIImageView ] = [] En lugar de dibujar las cartas directamente en su posici\u00f3n final, podemos hacerlo fuera de la pantalla (es decir, con el origen del frame en coordenadas negativas) y luego hacer una animaci\u00f3n hasta su posici\u00f3n definitiva. La siguiente funci\u00f3n dibujarCarta(carta: Carta, posicion : Int) dibuja una carta con el efecto descrito. La posicion es el orden de la carta, para que se vayan colocando una al lado de la otra: 1, 2... En el c\u00f3digo de ejemplo usamos un tama\u00f1o de carta fijo de 70x100 puntos, en el apartado siguiente se te propone adaptarlo al tama\u00f1o real de la pantalla. N\u00f3tese que hablamos de puntos y no de pixeles ya que en c\u00f3digo no se usa la resoluci\u00f3n f\u00edsica sino una resoluci\u00f3n \"l\u00f3gica\". Hay dispositivos que tienen distinta resoluci\u00f3n f\u00edsica pero usan la misma resoluci\u00f3n l\u00f3gica, lo que simplifica el desarrollo. Pod\u00e9is ver una tabla con resoluciones f\u00edsicas y l\u00f3gicas de distintos dispositivos iOS en https://www.ios-resolution.com/ IMPORTANTE: para que la segunda l\u00ednea de este c\u00f3digo funcione tu tipo enumerado Palo debe tener un valor \"interno\" de tipo String . Esto lo puedes conseguir simplemente poniendo enum Palo : String en la definici\u00f3n del tipo. func dibujarCarta ( carta : Carta , posicion : Int ) { let nombreImagen = String ( carta . valor ) + String ( carta . palo . rawValue ) //creamos un objeto imagen let imagenCarta = UIImage ( named : nombreImagen ) //para que la imagen sea un componente m\u00e1s del UI, //la encapsulamos en un UIImageView let cartaView = UIImageView ( image : imagenCarta ) //Inicialmente la colocamos fuera de la pantalla y m\u00e1s grande //para que parezca m\u00e1s cercana //\"frame\" son los l\u00edmites de la vista, definen pos y tama\u00f1o cartaView . frame = CGRect ( x : - 200 , y : - 200 , width : 200 , height : 300 ) //La rotamos, para que al \"repartirla\" haga un efecto de giro cartaView . transform = CGAffineTransform ( rotationAngle : CGFloat ( Double . pi )); //La a\u00f1adimos a la vista principal, si no no ser\u00eda visible self . view . addSubview ( cartaView ) //guardamos la vista en el array, para luego poder eliminarla self . vistasCartas . append ( cartaView ) //Animaci\u00f3n de repartir carta UIView . animate ( withDuration : 0.5 ){ //\"efecto caida\": la llevamos a la posici\u00f3n final cartaView . frame = CGRect ( x : 50 + 70 * ( posicion - 1 ), y : 100 , width : 70 , height : 100 ); //0 como \u00e1ngulo \"destino\", para que rote mientras \"cae\" cartaView . transform = CGAffineTransform ( rotationAngle : 0 ); } }","title":"C\u00f3mo dibujar las cartas"},{"location":"miniproyecto/proyecto/#eliminar-las-cartas-de-la-pantalla","text":"Una vez ha terminado la partida, o justo cuando comienza la siguiente, hay que borrar todas las cartas de la pantalla. Vamos recorriendo el array self.vistasCartas del view controller y vamos eliminando las cartas de la pantalla: //Quitamos las cartas de la pantalla for vistaCarta in self . vistasCartas { vistaCarta . removeFromSuperview () } //ya no tenemos im\u00e1genes de cartas en pantalla, ponemos el array a vac\u00edo self . vistasCartas =[]","title":"Eliminar las cartas de la pantalla"},{"location":"miniproyecto/proyecto/#adaptar-los-dibujos-a-la-resolucion-de-la-pantalla-05-puntos-adicionales","text":"OPCIONALMENTE, en lugar de dibujar las cartas con un tama\u00f1o y unas posiciones \"fijas\", puedes usar un porcentaje o fracci\u00f3n del ancho y alto total de la pantalla. Puedes obtener el ancho y alto de la pantalla del siguiente modo: let limitesPantalla = UIScreen . main . bounds let anchoPantalla = limitesPantalla . width let altoPantalla = limitesPantalla . height","title":"Adaptar los dibujos a la resoluci\u00f3n de la pantalla (0.5 puntos ADICIONALES)"},{"location":"miniproyecto/proyecto/#como-manipular-los-botones","text":"Pod\u00e9is habilitar/deshabilitar los botones por c\u00f3digo poniendo su propiedad isEnabled a true o false respectivamente. Para que un bot\u00f3n aparezca inicialmente deshabilitado, en el \"attributes inspector\" de la parte derecha de Xcode desmarcar la casilla enabled dentro de state (est\u00e1 a mitad de panel). Un problema es c\u00f3mo enterarnos en el ViewController de que la partida ha acabado para habilitar y deshabilitar los correspondientes botones, y para mostrar el resultado con un cuadro de di\u00e1logo. Podemos hacerlo con notificaciones: A\u00f1adir c\u00f3digo Swift a la funci\u00f3n acabarPartida() de la clase Juego para que se env\u00ede una notificaci\u00f3n con el nombre y contenido que quer\u00e1is (como contenido deber\u00eda tener como m\u00ednimo una frase resumiendo el resultado del juego para que pod\u00e1is mostrarlo). A\u00f1adir c\u00f3digo Swift al ViewController para que si se recibe la notificaci\u00f3n se ejecute un m\u00e9todo de \u00e9ste que habilite/deshabilite botones y muestre el resultado","title":"C\u00f3mo manipular los botones"},{"location":"miniproyecto/proyecto/#como-mostrar-mensajes-al-usuario","text":"Pod\u00e9is mostrar el resultado del juego (\"has ganado\", \"te has pasado\",...) con un UIAlertController , que har\u00e1 aparecer el t\u00edpico cuadro de di\u00e1logo modal. El siguiente c\u00f3digo muestra un cuadro que pone \"\u00a1\u00a1Has perdido!!\", con el t\u00edtulo \"Fin del juego\", y con un \u00fanico bot\u00f3n de \"OK\" que no hace nada especial, m\u00e1s que quitar el cuadro de di\u00e1logo. let alert = UIAlertController ( title : \"Fin del juego\" , message : \"\u00a1\u00a1Has perdido!!\" , preferredStyle : UIAlertControllerStyle . alert ) let action = UIAlertAction ( title : \"OK\" , style : UIAlertActionStyle . default ) alert . addAction ( action ) self . present ( alert , animated : true , completion : nil )","title":"C\u00f3mo mostrar mensajes al usuario"},{"location":"miniproyecto/proyecto/#i18n-15-puntos","text":"Internacionaliza la aplicaci\u00f3n para que est\u00e9 localizada al menos en dos idiomas, los que t\u00fa prefieras","title":"i18n (1.5 puntos)"},{"location":"s1/ejercicios/","text":"Ejercicios adicionales de Swift B\u00e1sico (1.5 puntos) \u00b6 En esta sesi\u00f3n vamos a implementar las clases b\u00e1sicas necesarias para un juego de cartas, que terminaremos en las \u00faltimas sesiones de la asignatura. Por el momento no vamos a tener interfaz, solo la l\u00f3gica m\u00e1s b\u00e1sica y las estructuras de datos. A continuaci\u00f3n se da la lista de clases y enums a crear. Deb\u00e9is respetar lo m\u00e1ximo posible los nombres de propiedades y m\u00e9todos NOTA: el ejercicio est\u00e1 pensado para las cartas de la baraja espa\u00f1ola . Para los que no la conozc\u00e1is: hay 4 \"palos\": bastos, copas, espadas y oros, en lugar de los diamantes,corazones,tr\u00e9boles y picas de la baraja francesa. De cada palo hay 12 cartas, que son del 1 al 12, aunque el 8 y 9 no se suelen usar en la mayor\u00eda de juegos. El 1 tambi\u00e9n se llama \"as\" igual que en la baraja francesa, el 10 es la sota (en la baraja francesa es la J), el es 11 el caballo (Q o dama en la francesa) y el 12 el rey . Si quer\u00e9is m\u00e1s informaci\u00f3n pod\u00e9is ver las cartas aqu\u00ed . Enumerado Palo (0,25 puntos) \u00b6 Un enum para representar los cuatro palos de la baraja. Recuerda que son bastos, copas, espadas y oros. Haz que sea internamente un String ( : String ), as\u00ed su propiedad .rawValue ser\u00e1 una cadena y podr\u00e1s mostrar el nombre del palo clase Carta (0,5 puntos) \u00b6 Propiedades: valor entero y palo , de tipo Palo M\u00e9todos Inicializador: se le pasa un valor y un palo. Podr\u00eda fallar si el valor que se le pasa no es correcto (recordad que el 8 y el 9 no se usan y que evidentemente no valen cartas menores que 1 ni mayores que 12). Por tanto necesitamos un failable initializer . descripcion : debe devolver un String con el nombre de la carta: el 1 de oros , el 10 de bastos ,... Clase Mano (0,75 puntos) \u00b6 un conjunto de cartas Propiedades almacenadas: cartas , un array de Carta Propiedades computadas: tama\u00f1o , la longitud del array (su propiedad count ) M\u00e9todos: El inicializador de la clase debe inicializar cartas como un array vac\u00edo (tambi\u00e9n lo pod\u00e9is hacer al definir la propiedad) addCarta : se le pasa una carta y la a\u00f1ade a la mano getCarta : se le pasa una posici\u00f3n (empezando por 0) y devuelve la carta como un opcional. Si la posici\u00f3n es menor que 0 o mayor o igual que el tama\u00f1o, deber\u00eda devolver nil Programa principal \u00b6 Como \"programa principal\" para probar las clases anteriores puedes ejecutar este c\u00f3digo var mano = Mano () mano . addCarta ( Carta ( 1 , . oros ) ! ) mano . addCarta ( Carta ( 10 , . espadas ) ! ) mano . addCarta ( Carta ( 7 , . copas ) ! ) print ( \"Hay \\( mano . tama\u00f1o ) cartas\" ) for num in 0. .< mano . tama\u00f1o { if let carta = mano . getCarta ( pos : num ) { print ( carta . descripcion ()) } } Si todo es correcto deber\u00edan aparecer en pantalla las tres cartas a\u00f1adidas a la mano. Anexo: opciones para escribir y probar el c\u00f3digo de este ejercicio \u00b6 Opci\u00f3n 1 (Necesario tener un Mac con Xcode instalado, est\u00e1 disponible en la app Store de Mac): en un playground de Xcode: Abre el programa Xcode, y crea un nuevo playground con File > New >Playground . Escribe aqu\u00ed el c\u00f3digo de todas las clases juntas, y tambi\u00e9n del programa principal. Como ir\u00e1s viendo, el playground se est\u00e1 compilando y ejecutando constantemente a medida que vas escribiendo c\u00f3digo, pero si quieres forzar la ejecuci\u00f3n puedes ir a Editor > Execute playground . Lo puedes usar una vez terminado todo, para ejecutar varias veces el programa principal. Opci\u00f3n 2 (desde cualquier plataforma, online sin instalar nada): en alg\u00fan entorno online de programaci\u00f3n en Swift, como por ejemplo en Repl.it , o el que usamos en el video de introducci\u00f3n, Programiz . Esto te puede ser \u00fatil si no tienes un Mac disponible o no puedes instalar el compilador en l\u00ednea de comandos en tu sistema. Opci\u00f3n 3 (desde cualquier plataforma, en local, instalando el compilador de Swift): Como el n\u00facleo del lenguaje es open source el compilador/int\u00e9rprete se puede instalar en muchas plataformas. Puedes bajar el de la tuya desde la p\u00e1gina de descargas de Swift, aunque probablemente no te merezca la pena si es solo para el curso, ya que solo lo podr\u00e1s usar en unas pocas sesiones de esta asignatura: Usando el editor de texto que prefieras, escribe el c\u00f3digo del enumerado Palo las clases Carta , Baraja y Mano y la extensi\u00f3n de Array . Puedes guardar por ejemplo cada clase en un archivo .swift distinto, aunque en Swift no hay reglas sobre qu\u00e9 clases debe contener cada archivo. Guarda el programa principal en un archivo main.swift Para compilar, abre una terminal, ve al directorio donde est\u00e9n los archivos y escribe swiftc *.swift . Esto compilar\u00e1 todos los archivos Swift y generar\u00e1 un ejecutable main Puedes ejecutar el programa escribiendo en la terminal ./main NOTA: estas alternativas las podemos usar porque de momento todav\u00eda no estamos haciendo aplicaciones con interfaz de usuario. A partir de la siguiente sesi\u00f3n s\u00ed haremos aplicaciones iOS con lo que nuestra \u00fanica posibilidad va a ser trabajar en un Mac con un entorno tipo Xcode.","title":"Ejercicios de Swift b\u00e1sico"},{"location":"s1/ejercicios/#ejercicios-adicionales-de-swift-basico-15-puntos","text":"En esta sesi\u00f3n vamos a implementar las clases b\u00e1sicas necesarias para un juego de cartas, que terminaremos en las \u00faltimas sesiones de la asignatura. Por el momento no vamos a tener interfaz, solo la l\u00f3gica m\u00e1s b\u00e1sica y las estructuras de datos. A continuaci\u00f3n se da la lista de clases y enums a crear. Deb\u00e9is respetar lo m\u00e1ximo posible los nombres de propiedades y m\u00e9todos NOTA: el ejercicio est\u00e1 pensado para las cartas de la baraja espa\u00f1ola . Para los que no la conozc\u00e1is: hay 4 \"palos\": bastos, copas, espadas y oros, en lugar de los diamantes,corazones,tr\u00e9boles y picas de la baraja francesa. De cada palo hay 12 cartas, que son del 1 al 12, aunque el 8 y 9 no se suelen usar en la mayor\u00eda de juegos. El 1 tambi\u00e9n se llama \"as\" igual que en la baraja francesa, el 10 es la sota (en la baraja francesa es la J), el es 11 el caballo (Q o dama en la francesa) y el 12 el rey . Si quer\u00e9is m\u00e1s informaci\u00f3n pod\u00e9is ver las cartas aqu\u00ed .","title":"Ejercicios adicionales de Swift B\u00e1sico (1.5 puntos)"},{"location":"s1/ejercicios/#enumerado-palo-025-puntos","text":"Un enum para representar los cuatro palos de la baraja. Recuerda que son bastos, copas, espadas y oros. Haz que sea internamente un String ( : String ), as\u00ed su propiedad .rawValue ser\u00e1 una cadena y podr\u00e1s mostrar el nombre del palo","title":"Enumerado Palo (0,25 puntos)"},{"location":"s1/ejercicios/#clase-carta-05-puntos","text":"Propiedades: valor entero y palo , de tipo Palo M\u00e9todos Inicializador: se le pasa un valor y un palo. Podr\u00eda fallar si el valor que se le pasa no es correcto (recordad que el 8 y el 9 no se usan y que evidentemente no valen cartas menores que 1 ni mayores que 12). Por tanto necesitamos un failable initializer . descripcion : debe devolver un String con el nombre de la carta: el 1 de oros , el 10 de bastos ,...","title":"clase Carta (0,5 puntos)"},{"location":"s1/ejercicios/#clase-mano-075-puntos","text":"un conjunto de cartas Propiedades almacenadas: cartas , un array de Carta Propiedades computadas: tama\u00f1o , la longitud del array (su propiedad count ) M\u00e9todos: El inicializador de la clase debe inicializar cartas como un array vac\u00edo (tambi\u00e9n lo pod\u00e9is hacer al definir la propiedad) addCarta : se le pasa una carta y la a\u00f1ade a la mano getCarta : se le pasa una posici\u00f3n (empezando por 0) y devuelve la carta como un opcional. Si la posici\u00f3n es menor que 0 o mayor o igual que el tama\u00f1o, deber\u00eda devolver nil","title":"Clase Mano (0,75 puntos)"},{"location":"s1/ejercicios/#programa-principal","text":"Como \"programa principal\" para probar las clases anteriores puedes ejecutar este c\u00f3digo var mano = Mano () mano . addCarta ( Carta ( 1 , . oros ) ! ) mano . addCarta ( Carta ( 10 , . espadas ) ! ) mano . addCarta ( Carta ( 7 , . copas ) ! ) print ( \"Hay \\( mano . tama\u00f1o ) cartas\" ) for num in 0. .< mano . tama\u00f1o { if let carta = mano . getCarta ( pos : num ) { print ( carta . descripcion ()) } } Si todo es correcto deber\u00edan aparecer en pantalla las tres cartas a\u00f1adidas a la mano.","title":"Programa principal"},{"location":"s1/ejercicios/#anexo-opciones-para-escribir-y-probar-el-codigo-de-este-ejercicio","text":"Opci\u00f3n 1 (Necesario tener un Mac con Xcode instalado, est\u00e1 disponible en la app Store de Mac): en un playground de Xcode: Abre el programa Xcode, y crea un nuevo playground con File > New >Playground . Escribe aqu\u00ed el c\u00f3digo de todas las clases juntas, y tambi\u00e9n del programa principal. Como ir\u00e1s viendo, el playground se est\u00e1 compilando y ejecutando constantemente a medida que vas escribiendo c\u00f3digo, pero si quieres forzar la ejecuci\u00f3n puedes ir a Editor > Execute playground . Lo puedes usar una vez terminado todo, para ejecutar varias veces el programa principal. Opci\u00f3n 2 (desde cualquier plataforma, online sin instalar nada): en alg\u00fan entorno online de programaci\u00f3n en Swift, como por ejemplo en Repl.it , o el que usamos en el video de introducci\u00f3n, Programiz . Esto te puede ser \u00fatil si no tienes un Mac disponible o no puedes instalar el compilador en l\u00ednea de comandos en tu sistema. Opci\u00f3n 3 (desde cualquier plataforma, en local, instalando el compilador de Swift): Como el n\u00facleo del lenguaje es open source el compilador/int\u00e9rprete se puede instalar en muchas plataformas. Puedes bajar el de la tuya desde la p\u00e1gina de descargas de Swift, aunque probablemente no te merezca la pena si es solo para el curso, ya que solo lo podr\u00e1s usar en unas pocas sesiones de esta asignatura: Usando el editor de texto que prefieras, escribe el c\u00f3digo del enumerado Palo las clases Carta , Baraja y Mano y la extensi\u00f3n de Array . Puedes guardar por ejemplo cada clase en un archivo .swift distinto, aunque en Swift no hay reglas sobre qu\u00e9 clases debe contener cada archivo. Guarda el programa principal en un archivo main.swift Para compilar, abre una terminal, ve al directorio donde est\u00e9n los archivos y escribe swiftc *.swift . Esto compilar\u00e1 todos los archivos Swift y generar\u00e1 un ejecutable main Puedes ejecutar el programa escribiendo en la terminal ./main NOTA: estas alternativas las podemos usar porque de momento todav\u00eda no estamos haciendo aplicaciones con interfaz de usuario. A partir de la siguiente sesi\u00f3n s\u00ed haremos aplicaciones iOS con lo que nuestra \u00fanica posibilidad va a ser trabajar en un Mac con un entorno tipo Xcode.","title":"Anexo: opciones para escribir y probar el c\u00f3digo de este ejercicio"},{"location":"s1/intro/","text":"En este cap\u00edtulo vamos a ver una introducci\u00f3n a las caracter\u00edsticas m\u00e1s b\u00e1sicas del lenguaje Swift.","title":"Intro"},{"location":"s1/swift_basico/","text":"Introducci\u00f3n b\u00e1sica a Swift (Ejercicios: 1 punto) \u00b6 Swift es un lenguaje originalmente desarrollado por Apple para la programaci\u00f3n de aplicaciones en las plataformas iOS y OSX. Pese a haber sido desarrollado con esta intenci\u00f3n, el lenguaje en s\u00ed no est\u00e1 limitado a apps m\u00f3viles o de Mac sino que es un lenguaje de prop\u00f3sito general. Es un lenguaje bastante completo y con muchas funcionalidades, pero tambi\u00e9n pensado para que las funcionalidades b\u00e1sicas sean sencillas de usar. Como muchos lenguajes modernos incluye no solo elementos de programaci\u00f3n orientada a objetos sino tambi\u00e9n de programaci\u00f3n funcional. Ejercicios de Swift En estos apuntes de introducci\u00f3n a Swift ver\u00e1s ejercicios intercalados. La suma de todos ellos vale 1 punto de la nota total del m\u00f3dulo de iOS. Para escribir el c\u00f3digo de estos ejercicios tienes dos opciones: Si tienes un Mac, lo m\u00e1s recomendable es usar un playground de Xcode (aqui tienes un mini-tutorial de c\u00f3mo abrirlo y usarlo). Luego tendr\u00e1s que entregar el archivo .playground que hayas creado. Si no tienes Mac puedes probar el c\u00f3digo en alg\u00fan compilador online. Por ejemplo https://www.programiz.com/swift/online-compiler/ , https://swiftfiddle.com o https://replit.com/new/swift Preliminares \u00b6 En un programa Swift no hay un \"main\" como en C sino que el c\u00f3digo se empieza a ejecutar por la primera instrucci\u00f3n de \"nivel superior\", es decir las sentencias que no est\u00e1n dentro de funciones. Los \";\" al final de las sentencias son opcionales. Variables y constantes \u00b6 Swift tiene una serie de tipos b\u00e1sicos : Int , Double , Float , Bool Las variables se definen con var y las constantes con let . Si inicializamos su valor no es necesario especificar el tipo, ya que el compilador de Swift lo induce a partir del valor inicial. var i = 1 //i es un Int var d = 1.5 //d es un Double //Tambi\u00e9n podemos declarar el tipo, si no la inicializamos var f : Float f = 1.5 //O incluso declarar e inicializar var f2 : Float = 1.5 type(of:) nos devuelve el tipo var i = 1 print ( type ( of : i )) //Int type ( of : i )== Int . self //true. Para representar un tipo en el c\u00f3digo se pone con .self Por supuesto a una constante no le podemos cambiar el valor una vez asignado: let c = 1 c = 2 //Error! El lenguaje es fuertemente tipado y no hay conversi\u00f3n autom\u00e1tica, no podemos asignar por ejemplo un valor 1.5 a una variable Int , el compilador no va a truncar el valor, pero s\u00ed podemos hacer un cast var i : Int = Int ( 1.5 ) //1 Ejercicio 1 Al igual que Int() convierte al tipo entero, Bool() puede convertir a booleano, por ejemplo a partir de las cadenas \"true\" y \"false\". Supongamos que tienes una constante let valor=\"true\" . Declara una variable b como de tipo booleano y as\u00edgnale valor pero convertida a booleano. Opcionales \u00b6 Los opcionales son pr\u00e1cticamente el mismo concepto que los nullables en Kotlin, compartiendo algunos elementos de sintaxis, aunque tambi\u00e9n con algunas diferencias pr\u00e1cticas En Swift, nil es como el null de Java, pero es aplicable tambi\u00e9n a Int , Float , ... No obstante, una variable \"normal\" no puede valer nil . var valor : Int = nil //esto no va a compilar Para indicar que una variable puede valer nil , debemos declararla como opcional , con un ? en la declaraci\u00f3n, despu\u00e9s del tipo, por ejemplo Int? var valor : Int ? = nil //esto s\u00ed es OK Muchos m\u00e9todos de la librer\u00eda de Swift devuelven un valor opcional, con nil si fallan. Por ejemplo los m\u00e9todos que hacen conversi\u00f3n de tipos. //como es l\u00f3gico esta conversi\u00f3n falla, y por tanto devuelve nil let num = Int ( \"hola\" ) \"Desenvolver\" opcionales \u00b6 En una variable opcional el valor no est\u00e1 accesible directamente sino que est\u00e1 \"envuelto\" ( wrapped ). No se puede operar con \u00e9l directamente, antes hay que desenvolverlo , ahora veremos c\u00f3mo. let valor = Int ( \"1\" ) //esta conversi\u00f3n es OK, pero devuelve un 1 \"envuelto\" print ( valor ) //no es 1, sino que pone Optional(1) print ( valor + 1 ) //CRASH! esto no es v\u00e1lido Podemos desenvolver el opcional con ! , pero hay que llevar cuidado, ya que intentar desenvolver nil es un error let valor = Int ( \"1\" ) print ( valor ! + 1 ) El patr\u00f3n t\u00edpico para desenvolver opcionales de forma segura es usar if let , que es una especie de condicional que solo se cumple si el valor desenvuelto es distinto de nil , y \"de paso\" le asigna el valor desenvuelto a la variable que ponemos en el let let valor = Int ( \"1\" ) if let valorDesenvuelto = valor { print ( \"\u00a1Es un n\u00famero!: \\( valorDesenvuelto ) \" ) } Aunque en muchos ejemplos de if..let se usa una nueva variable para el valor desenvuelto podemos usar la misma del valor original, as\u00ed evitamos tener que crear una variable nueva solo para desenvolver let valor = Int ( \"1\" ) if let valor = valor { print ( \"\u00a1Es un n\u00famero!: \\( valor ) \" ) } Otra forma de desenvolver valores es con el operador de coalescencia ( nil-coalescing ). Este operador, ?? , nos permite desenvolver autom\u00e1ticamente un valor o devolver un valor por defecto si el opcional era nil . var opcional : Int ? ... var v = opcional ?? 0 En el ejemplo anterior, si \"opcional\" contiene un valor se desenvolver\u00e1 autom\u00e1ticamente y asignar\u00e1 a v y si no, a v se le asignar\u00e1 0. Ejercicio 2 Declara una variable \"mensaje\" como un String opcional. Usando el if let escribe c\u00f3digo que haga que si es distinta a nil la imprima, pero si es nil imprima \"est\u00e1 vac\u00eda\". Ten en cuenta que en Swift las llaves son obligatorias siempre en los condicionales aunque solo haya una instrucci\u00f3n. Opcionales \"desenvueltos impl\u00edcitamente\" \u00b6 Tambi\u00e9n tenemos la posibilidad de definir opcionales pero tratarlos como si no lo fueran, ya que no hace falta desenvolverlos: son los denominados Implicitly unwrapped optionals , declarados con tipo! , por ejemplo: let valor : Int ! valor = Int ( \"1\" ) print ( valor ) Esto es \u00fatil para variables que la mayor parte del tiempo sabemos que van a tener un valor no nil pero puede haber cierto momento en el flujo de ejecuci\u00f3n del programa en que sean nil . Por ejemplo, en iOS cuando se ejecuta nuestro c\u00f3digo en respuesta a eventos de usuario (pe.j tap ), los componentes de UI ya est\u00e1n inicializados, pero hay ciertos puntos de la aplicaci\u00f3n donde todav\u00eda no se han creado. Instrucciones de control de flujo \u00b6 Hay algunas instrucciones que son muy similares a C/Java, como el if o el while con ciertas diferencias: Las condiciones no es necesario ponerlas entre par\u00e9ntesis Aunque un bloque de sentencias tenga una \u00fanica instrucci\u00f3n siempre hay que poner llaves, por ejemplo: if edad < 18 { print ( \"Lo siento, no puedes entrar a este sitio\" ) } else { print ( \"Bienvenido\" ) } El bucle for m\u00e1s b\u00e1sico es distinto al de C/Java, se usa la sintaxis for _variable_ in _rango_ .: for i in 1. .. 5 { //desde el 1 hasta el 5, incluidos ambos print ( i ) // 1 2 3 4 5 } for i in 1. .< 3 { //rango semiabierto, llega solo hasta el 2 print ( i ) // 1 2 3 4 } //Si no queremos ir de 1 en 1 podemos usar stride(from:lim_inf,to:lim_sup,by:incremento) //\"to\" no incluye el l\u00edmite superior, para incluirlo usar \"through\" en su lugar for i in stride ( from : 1 , to : 5 , by : 2 ) { print ( i ) //1 3 } Si solo nos interesa realizar un determinado n\u00famero de iteraciones y no en cu\u00e1l estamos, podemos usar la variable an\u00f3nima , _ for _ in 1. .. 3 { print ( \"RA \" ) } Existe una instrucci\u00f3n equivalente al do...while que es el repeat ... while ( do es una palabra clave del lenguaje pero en lugar de en bucles se usa en el manejo de errores) switch es similar a C/Java, pero No hace falta break despu\u00e9s de cada case . Por defecto cuando salimos de un case se sale del switch En los case se puede poner cualquier tipo de datos (Int, Float, String,...), varios valores, rangos, o condiciones. Los case deben ser exhaustivos . Es decir deben cubrir todos los posibles valores de la variable (o si son infinitos, como en variables num\u00e9ricas, al menos debe haber un default ) let valorCarta = - 1 switch valorCarta { case 1. .. 7 : print ( \"Es un \\( valorCarta ) \" ) case 8 , 9 : print ( \"Normalmente no se usan 8 y 9\" ) case 10 : print ( \"Sota\" ) case 11 : print ( \"Caballo\" ) case 12 : print ( \"Rey\" ) case let x where x < 0 : print ( \"WTF! \u00bfUna carta negativa?\" ) default : print ( \"Carta no v\u00e1lida\" ) } Tipos de datos b\u00e1sicos (de la librer\u00eda est\u00e1ndar) \u00b6 String \u00b6 Se aplican la mayor\u00eda de convenciones habituales: delimitadas por dobles comillas, concatenadas con + ,... Se puede hacer interpolaci\u00f3n de cadenas (expresiones dentro de cadenas) usando \\() var nombre = Pepe var edad = 33 print ( \" \\( nombre ) tiene \\( edad ) a\u00f1os\" ) Se pueden definir cadenas multil\u00ednea delimitadas con tres \" var mensaje = \"\"\" Esto es una cadena multil\u00ednea. Se ignora el sangrado, se coloca todo al nivel del que tenga la primera l\u00ednea. Los delimitadores del final deben venir en su propia l\u00ednea \"\"\" Colecciones: arrays, conjuntos y diccionarios \u00b6 Arrays \u00b6 Se pueden declarar con [tipo] o Array<tipo> var lista_enteros : [ Int ] var lista_cadenas : Array < String > Se pueden inicializar con una lista de valores literales [ ] . La notaci\u00f3n para acceder a un elemento es la misma que en C var bizcocho = [ \"huevos\" , \"leche\" , \"harina\" ] bizcocho [ 2 ] = \"harina con levadura\" Si lo inicializamos con [tipo]() tendremos un array vac\u00edo. Pero los arrays pueden cambiar de tama\u00f1o din\u00e1micamente a diferencia de lenguajes m\u00e1s tradicionales como C++/Java var nums = [ Int ]() nums . append ( 3 ) //nums == [3] nums . insert ( 1 , at : 0 ) //nums == [1,3] nums . remove ( at : 0 ) //nums == [3] Podemos concatenar arrays con + Podemos iterar sobre un array (en general sobre una colecci\u00f3n) con for ... in sin necesidad de usar los \u00edndices, iterando directamente por los elementos. var bizcocho = [ \"huevos\" , \"leche\" , \"harina\" ] for ingrediente in bizcocho { print ( ingrediente ) } Ejercicio 3 Cambia este ejemplo por un bucle for en el que se itere usando una variable i con la posici\u00f3n del elemento en la lista, lista[i] . El n\u00famero de elementos de la lista lo puedes obtener en su propiedad count Conjuntos \u00b6 Son listas de valores que no se pueden repetir. Si lo inicializamos con un valor literal, hay que especificar como tipo Set , si no Swift lo tomar\u00eda como un array var generos : Set = [ \"Rock\" , \"Pop\" ] Algunas operaciones: insert(_) , remove(_) , operaciones de conjuntos: set1.union(set2) ,... Se puede iterar con for ... in como en los arrays Diccionarios \u00b6 Son listas de pares clave/valor. Lo que en Java ser\u00edan HashMaps o Maps en Javascript Inicializaci\u00f3n con valores literales: var horasTrabajadas = [ \"Lunes\" : 7 , \"Martes\" : 8 , \"Mi\u00e9rcoles\" : 7 ] horasTrabajadas [ \"Lunes\" ]== 7 //true horasTrabajadas [ \"Jueves\" ]= 5 Se pueden declarar sin inicializar especificando el tipo de la clave y el tipo del valor var horas = [ String : Int ] var masHoras = Dictionary < String : Int > Se puede iterar por ellos con for (clave,valor) in var grupo = [ \"Billy\" : \"guitar\" , \"James\" : \"guitar\" , \"Darcy\" : \"bass\" , \"Jimmy\" : \"drums\" ] for ( nombre , instrumento ) in grupo { print ( \" \\( nombre ) on the \\( instrumento ) \" ) } Funciones \u00b6 Para definir una funci\u00f3n se usa la sintaxis func nombre(par1:tipo1, par2:tipo2)->TipoRetorno . Si una funci\u00f3n no devuelve nada se omite el ->TipoRetorno func generarSaludo ( nombre : String )-> String { return \"Hola \\( nombre ) \" } func imprimirSaludo ( nombre : String ) { print ( \"Hola \\( nombre ) \" ) } Los nombres de los par\u00e1metros no solo se usan dentro del c\u00f3digo de la funci\u00f3n, sino tambi\u00e9n como etiquetas al llamarla. Continuando con los ejemplos anteriores generarSaludo ( nombre : \"Pepe\" ) Hay casos en los que quedar\u00eda m\u00e1s \"natural\" darle un nombre a la etiqueta diferente al que se usa dentro de la funci\u00f3n. En ese caso ponemos primero la etiqueta y luego el nombre \"interno\". Si no queremos usar etiqueta ponemos la variable an\u00f3nima: _ func saludarA ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saludarA ( \"Pepe\" , el : \"Martes\" ) Los par\u00e1metros no son modificables dentro del cuerpo de la funci\u00f3n, es decir, dentro del cuerpo se tratan como si fueran constantes definidas con let . Podemos cambiar esto marcando el par\u00e1metro con inout . Las funciones son \"ciudadanos de primera clase\", al igual que cualquier objeto se pueden pasar como par\u00e1metro y una funci\u00f3n puede devolver otra funci\u00f3n Ejercicio 4 Implementa una funci\u00f3n filtrar a la que le pases una lista de valores Int y un valor m\u00e1ximo y devuelva una nueva lista con todos los valores que no superan este m\u00e1ximo. El primer par\u00e1metro no debe tener etiqueta y el segundo max . Por ejemplo esto devolver\u00eda la lista [4 5] (cuidado, swift tiene una funci\u00f3n filter que hace esto, pero evidentemente no puedes usarla para este ejercicio) var lista = [ 10 , 4 , 5 , 7 ] var f = filtrar ( lista , max : 5 ) print ( f ) //[4,5] Clases \u00b6 Sintaxis b\u00e1sica \u00b6 La sintaxis es similar a Java con algunas diferencias: No se pone new para instanciar un nuevo objeto, sino solo el nombre del constructor En lugar de this , se pone self Los constructores, aqu\u00ed llamados inicializadores se definen en el c\u00f3digo de la clase con el nombre init por ejemplo: class Figura { var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } func descripcion () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ()) Propiedades computadas \u00b6 Son getters / setters , desde \"fuera\" parecen propiedades pero en realidad son m\u00e9todos class Figura { private var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } var descripcion : String { get { return \"Una figura con \\( numeroDeLados ) lados.\" } } var lados : Int { get { return numeroDeLados } set ( lados ) { self . numeroDeLados = lados } } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ) Los objetos se pasan por referencia igual que en Java let h1 = Figura ( lados : 6 ) let h2 = h1 //no es copia, sino referencia. h1 y h2 \"apuntan\" al mismo objeto h2 . lados = 5 print ( h1 . descripcion ) //Una figura con 5 lados (!!) Las struct se parecen mucho a las clases, mucho m\u00e1s que en C, las veremos en siguientes sesiones. Ejercicio 5 Crea una clase Persona con un nombre , una edad y una propiedad computable booleana adulto que indique si tiene 18 a\u00f1os o m\u00e1s. Comprueba que el siguiente c\u00f3digo funciona con tu clase: var p = Persona ( nombre : \"Pepe\" , edad : 20 ) //deber\u00eda imprimir ADULTO! ya que la edad de la persona es >= 18 if p . adulto { print ( \"ADULTO!\" ) } Herencia \u00b6 Para la herencia se usa la notaci\u00f3n class ClaseHeredada : ClaseBase , y para sobreescribir un m\u00e9todo, override ` Failable initializers \u00b6 Cualquier m\u00e9todo, incluyendo un inicializador, puede devolver un valor opcional. En este \u00faltimo caso, estamos indicando que si algo no es correcto no vamos a devolver una nueva instancia, sino nil . Estos inicializadores se denominan failable initializers y se denotan con init? . Por ejemplo supongamos que nos damos cuenta que no tienen sentido las figuras con n\u00famero de lados <=2: class Figura { private var numeroDeLados : Int init ?( lados : Int ) { if lados > 2 { self . numeroDeLados = lados } else { return nil } } ... } Como vemos, el failable initializer devuelve nil cuando no queremos devolver una instancia de la clase. Casting de clases \u00b6 Algunas veces ciertos APIs devuelven resultados \"sin tipo\" (en Swift se pone como Any ), pero es posible que nosotros sepamos que una variable es de una determinada clase. Podemos forzar esa conversi\u00f3n con as : dato as Clase . Tambi\u00e9n podemos hacer esto si tenemos una variable de una clase base pero nosotros sabemos que en realidad es una instancia de una clase derivada. var t = miFigura as Triangulo Extensiones \u00b6 Nos permiten a\u00f1adir nueva funcionalidad a clases ya existentes, incluso aun sin acceso al c\u00f3digo fuente o en clases del sistema. Se pueden a\u00f1adir por ejemplo nuevos m\u00e9todos, inicializadores y propiedades computadas. Lo que no se puede hacer es sobreescribir los m\u00e9todos o propiedades ya existentes. extension String { func reggaetonizar () -> String { return self + \" ya t\u00fa sabes\" } } Podemos usar los m\u00e9todos y propiedades de la extensi\u00f3n como us\u00e1bamos los originales: print ( \"mami\" . reggaetonizar ()) //mami ya t\u00fa sabes Enumerados \u00b6 Se definen de forma similar a C pero no tienen nada que ver, son tipos \"por derecho propio\", no enteros enum Direccion { case norte , sur , este , oeste } var d = Direccion . norte //si el compilador ya \"sabe\" el tipo no hace falta poner el \"prefijo\" del enumerado (Direccion) var d2 : Direccion = . norte Los enumerados pueden tener un valor \"interno\" ( raw ), cuyo tipo se indica como si el enumerado heredara de \u00e9l. Cuando se pone Int , Swift asigna valores comenzando por 0. Accedemos a este valor con rawValue . enum Direccion : Int { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //0 Si indicamos String como tipo del rawValue Swift hace una \"conversi\u00f3n autom\u00e1tica\" de los nombres a Strings enum Direccion : String { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //\"norte\" Los enum pueden tener m\u00e9todos y ser conforme a protocolos (estos \u00faltimos son similares a los interfaces de Java). enum Direccion : String { case norte , sur , este , oeste func inicial ()-> String { let cadena = self . rawValue let inicial = cadena [ cadena . startIndex ] return String ( inicial ). uppercased () } } print ( Direccion . norte . inicial ()) //\"N\" Ejercicio 6 Crea un tipo enumerado DiaSemana para los d\u00edas de la semana (lunes, martes,...). Su rawValue ser\u00e1 Int . A\u00f1\u00e1dele un m\u00e9todo cuantoFalta que devuelva el n\u00famero de d\u00edas que faltan para el fin de semana o bien 0 si es s\u00e1bado o domingo. Al probarlo deber\u00eda ser algo de este estilo: var dia = DiaSemana . lunes print ( dia . rawValue ) //0 dia = . viernes print ( dia . cuantoFalta ()) //1","title":"Introducci\u00f3n b\u00e1sica a Swift"},{"location":"s1/swift_basico/#introduccion-basica-a-swift-ejercicios-1-punto","text":"Swift es un lenguaje originalmente desarrollado por Apple para la programaci\u00f3n de aplicaciones en las plataformas iOS y OSX. Pese a haber sido desarrollado con esta intenci\u00f3n, el lenguaje en s\u00ed no est\u00e1 limitado a apps m\u00f3viles o de Mac sino que es un lenguaje de prop\u00f3sito general. Es un lenguaje bastante completo y con muchas funcionalidades, pero tambi\u00e9n pensado para que las funcionalidades b\u00e1sicas sean sencillas de usar. Como muchos lenguajes modernos incluye no solo elementos de programaci\u00f3n orientada a objetos sino tambi\u00e9n de programaci\u00f3n funcional. Ejercicios de Swift En estos apuntes de introducci\u00f3n a Swift ver\u00e1s ejercicios intercalados. La suma de todos ellos vale 1 punto de la nota total del m\u00f3dulo de iOS. Para escribir el c\u00f3digo de estos ejercicios tienes dos opciones: Si tienes un Mac, lo m\u00e1s recomendable es usar un playground de Xcode (aqui tienes un mini-tutorial de c\u00f3mo abrirlo y usarlo). Luego tendr\u00e1s que entregar el archivo .playground que hayas creado. Si no tienes Mac puedes probar el c\u00f3digo en alg\u00fan compilador online. Por ejemplo https://www.programiz.com/swift/online-compiler/ , https://swiftfiddle.com o https://replit.com/new/swift","title":"Introducci\u00f3n b\u00e1sica a Swift (Ejercicios: 1 punto)"},{"location":"s1/swift_basico/#preliminares","text":"En un programa Swift no hay un \"main\" como en C sino que el c\u00f3digo se empieza a ejecutar por la primera instrucci\u00f3n de \"nivel superior\", es decir las sentencias que no est\u00e1n dentro de funciones. Los \";\" al final de las sentencias son opcionales.","title":"Preliminares"},{"location":"s1/swift_basico/#variables-y-constantes","text":"Swift tiene una serie de tipos b\u00e1sicos : Int , Double , Float , Bool Las variables se definen con var y las constantes con let . Si inicializamos su valor no es necesario especificar el tipo, ya que el compilador de Swift lo induce a partir del valor inicial. var i = 1 //i es un Int var d = 1.5 //d es un Double //Tambi\u00e9n podemos declarar el tipo, si no la inicializamos var f : Float f = 1.5 //O incluso declarar e inicializar var f2 : Float = 1.5 type(of:) nos devuelve el tipo var i = 1 print ( type ( of : i )) //Int type ( of : i )== Int . self //true. Para representar un tipo en el c\u00f3digo se pone con .self Por supuesto a una constante no le podemos cambiar el valor una vez asignado: let c = 1 c = 2 //Error! El lenguaje es fuertemente tipado y no hay conversi\u00f3n autom\u00e1tica, no podemos asignar por ejemplo un valor 1.5 a una variable Int , el compilador no va a truncar el valor, pero s\u00ed podemos hacer un cast var i : Int = Int ( 1.5 ) //1 Ejercicio 1 Al igual que Int() convierte al tipo entero, Bool() puede convertir a booleano, por ejemplo a partir de las cadenas \"true\" y \"false\". Supongamos que tienes una constante let valor=\"true\" . Declara una variable b como de tipo booleano y as\u00edgnale valor pero convertida a booleano.","title":"Variables y constantes"},{"location":"s1/swift_basico/#opcionales","text":"Los opcionales son pr\u00e1cticamente el mismo concepto que los nullables en Kotlin, compartiendo algunos elementos de sintaxis, aunque tambi\u00e9n con algunas diferencias pr\u00e1cticas En Swift, nil es como el null de Java, pero es aplicable tambi\u00e9n a Int , Float , ... No obstante, una variable \"normal\" no puede valer nil . var valor : Int = nil //esto no va a compilar Para indicar que una variable puede valer nil , debemos declararla como opcional , con un ? en la declaraci\u00f3n, despu\u00e9s del tipo, por ejemplo Int? var valor : Int ? = nil //esto s\u00ed es OK Muchos m\u00e9todos de la librer\u00eda de Swift devuelven un valor opcional, con nil si fallan. Por ejemplo los m\u00e9todos que hacen conversi\u00f3n de tipos. //como es l\u00f3gico esta conversi\u00f3n falla, y por tanto devuelve nil let num = Int ( \"hola\" )","title":"Opcionales"},{"location":"s1/swift_basico/#desenvolver-opcionales","text":"En una variable opcional el valor no est\u00e1 accesible directamente sino que est\u00e1 \"envuelto\" ( wrapped ). No se puede operar con \u00e9l directamente, antes hay que desenvolverlo , ahora veremos c\u00f3mo. let valor = Int ( \"1\" ) //esta conversi\u00f3n es OK, pero devuelve un 1 \"envuelto\" print ( valor ) //no es 1, sino que pone Optional(1) print ( valor + 1 ) //CRASH! esto no es v\u00e1lido Podemos desenvolver el opcional con ! , pero hay que llevar cuidado, ya que intentar desenvolver nil es un error let valor = Int ( \"1\" ) print ( valor ! + 1 ) El patr\u00f3n t\u00edpico para desenvolver opcionales de forma segura es usar if let , que es una especie de condicional que solo se cumple si el valor desenvuelto es distinto de nil , y \"de paso\" le asigna el valor desenvuelto a la variable que ponemos en el let let valor = Int ( \"1\" ) if let valorDesenvuelto = valor { print ( \"\u00a1Es un n\u00famero!: \\( valorDesenvuelto ) \" ) } Aunque en muchos ejemplos de if..let se usa una nueva variable para el valor desenvuelto podemos usar la misma del valor original, as\u00ed evitamos tener que crear una variable nueva solo para desenvolver let valor = Int ( \"1\" ) if let valor = valor { print ( \"\u00a1Es un n\u00famero!: \\( valor ) \" ) } Otra forma de desenvolver valores es con el operador de coalescencia ( nil-coalescing ). Este operador, ?? , nos permite desenvolver autom\u00e1ticamente un valor o devolver un valor por defecto si el opcional era nil . var opcional : Int ? ... var v = opcional ?? 0 En el ejemplo anterior, si \"opcional\" contiene un valor se desenvolver\u00e1 autom\u00e1ticamente y asignar\u00e1 a v y si no, a v se le asignar\u00e1 0. Ejercicio 2 Declara una variable \"mensaje\" como un String opcional. Usando el if let escribe c\u00f3digo que haga que si es distinta a nil la imprima, pero si es nil imprima \"est\u00e1 vac\u00eda\". Ten en cuenta que en Swift las llaves son obligatorias siempre en los condicionales aunque solo haya una instrucci\u00f3n.","title":"\"Desenvolver\" opcionales"},{"location":"s1/swift_basico/#opcionales-desenvueltos-implicitamente","text":"Tambi\u00e9n tenemos la posibilidad de definir opcionales pero tratarlos como si no lo fueran, ya que no hace falta desenvolverlos: son los denominados Implicitly unwrapped optionals , declarados con tipo! , por ejemplo: let valor : Int ! valor = Int ( \"1\" ) print ( valor ) Esto es \u00fatil para variables que la mayor parte del tiempo sabemos que van a tener un valor no nil pero puede haber cierto momento en el flujo de ejecuci\u00f3n del programa en que sean nil . Por ejemplo, en iOS cuando se ejecuta nuestro c\u00f3digo en respuesta a eventos de usuario (pe.j tap ), los componentes de UI ya est\u00e1n inicializados, pero hay ciertos puntos de la aplicaci\u00f3n donde todav\u00eda no se han creado.","title":"Opcionales \"desenvueltos impl\u00edcitamente\""},{"location":"s1/swift_basico/#instrucciones-de-control-de-flujo","text":"Hay algunas instrucciones que son muy similares a C/Java, como el if o el while con ciertas diferencias: Las condiciones no es necesario ponerlas entre par\u00e9ntesis Aunque un bloque de sentencias tenga una \u00fanica instrucci\u00f3n siempre hay que poner llaves, por ejemplo: if edad < 18 { print ( \"Lo siento, no puedes entrar a este sitio\" ) } else { print ( \"Bienvenido\" ) } El bucle for m\u00e1s b\u00e1sico es distinto al de C/Java, se usa la sintaxis for _variable_ in _rango_ .: for i in 1. .. 5 { //desde el 1 hasta el 5, incluidos ambos print ( i ) // 1 2 3 4 5 } for i in 1. .< 3 { //rango semiabierto, llega solo hasta el 2 print ( i ) // 1 2 3 4 } //Si no queremos ir de 1 en 1 podemos usar stride(from:lim_inf,to:lim_sup,by:incremento) //\"to\" no incluye el l\u00edmite superior, para incluirlo usar \"through\" en su lugar for i in stride ( from : 1 , to : 5 , by : 2 ) { print ( i ) //1 3 } Si solo nos interesa realizar un determinado n\u00famero de iteraciones y no en cu\u00e1l estamos, podemos usar la variable an\u00f3nima , _ for _ in 1. .. 3 { print ( \"RA \" ) } Existe una instrucci\u00f3n equivalente al do...while que es el repeat ... while ( do es una palabra clave del lenguaje pero en lugar de en bucles se usa en el manejo de errores) switch es similar a C/Java, pero No hace falta break despu\u00e9s de cada case . Por defecto cuando salimos de un case se sale del switch En los case se puede poner cualquier tipo de datos (Int, Float, String,...), varios valores, rangos, o condiciones. Los case deben ser exhaustivos . Es decir deben cubrir todos los posibles valores de la variable (o si son infinitos, como en variables num\u00e9ricas, al menos debe haber un default ) let valorCarta = - 1 switch valorCarta { case 1. .. 7 : print ( \"Es un \\( valorCarta ) \" ) case 8 , 9 : print ( \"Normalmente no se usan 8 y 9\" ) case 10 : print ( \"Sota\" ) case 11 : print ( \"Caballo\" ) case 12 : print ( \"Rey\" ) case let x where x < 0 : print ( \"WTF! \u00bfUna carta negativa?\" ) default : print ( \"Carta no v\u00e1lida\" ) }","title":"Instrucciones de control de flujo"},{"location":"s1/swift_basico/#tipos-de-datos-basicos-de-la-libreria-estandar","text":"","title":"Tipos de datos b\u00e1sicos (de la librer\u00eda est\u00e1ndar)"},{"location":"s1/swift_basico/#string","text":"Se aplican la mayor\u00eda de convenciones habituales: delimitadas por dobles comillas, concatenadas con + ,... Se puede hacer interpolaci\u00f3n de cadenas (expresiones dentro de cadenas) usando \\() var nombre = Pepe var edad = 33 print ( \" \\( nombre ) tiene \\( edad ) a\u00f1os\" ) Se pueden definir cadenas multil\u00ednea delimitadas con tres \" var mensaje = \"\"\" Esto es una cadena multil\u00ednea. Se ignora el sangrado, se coloca todo al nivel del que tenga la primera l\u00ednea. Los delimitadores del final deben venir en su propia l\u00ednea \"\"\"","title":"String"},{"location":"s1/swift_basico/#colecciones-arrays-conjuntos-y-diccionarios","text":"","title":"Colecciones: arrays, conjuntos y diccionarios"},{"location":"s1/swift_basico/#diccionarios","text":"Son listas de pares clave/valor. Lo que en Java ser\u00edan HashMaps o Maps en Javascript Inicializaci\u00f3n con valores literales: var horasTrabajadas = [ \"Lunes\" : 7 , \"Martes\" : 8 , \"Mi\u00e9rcoles\" : 7 ] horasTrabajadas [ \"Lunes\" ]== 7 //true horasTrabajadas [ \"Jueves\" ]= 5 Se pueden declarar sin inicializar especificando el tipo de la clave y el tipo del valor var horas = [ String : Int ] var masHoras = Dictionary < String : Int > Se puede iterar por ellos con for (clave,valor) in var grupo = [ \"Billy\" : \"guitar\" , \"James\" : \"guitar\" , \"Darcy\" : \"bass\" , \"Jimmy\" : \"drums\" ] for ( nombre , instrumento ) in grupo { print ( \" \\( nombre ) on the \\( instrumento ) \" ) }","title":"Diccionarios"},{"location":"s1/swift_basico/#funciones","text":"Para definir una funci\u00f3n se usa la sintaxis func nombre(par1:tipo1, par2:tipo2)->TipoRetorno . Si una funci\u00f3n no devuelve nada se omite el ->TipoRetorno func generarSaludo ( nombre : String )-> String { return \"Hola \\( nombre ) \" } func imprimirSaludo ( nombre : String ) { print ( \"Hola \\( nombre ) \" ) } Los nombres de los par\u00e1metros no solo se usan dentro del c\u00f3digo de la funci\u00f3n, sino tambi\u00e9n como etiquetas al llamarla. Continuando con los ejemplos anteriores generarSaludo ( nombre : \"Pepe\" ) Hay casos en los que quedar\u00eda m\u00e1s \"natural\" darle un nombre a la etiqueta diferente al que se usa dentro de la funci\u00f3n. En ese caso ponemos primero la etiqueta y luego el nombre \"interno\". Si no queremos usar etiqueta ponemos la variable an\u00f3nima: _ func saludarA ( _ nombre : String , el dia : String ) -> String { return \"Hola \\( nombre ) , hoy es \\( dia ) .\" } saludarA ( \"Pepe\" , el : \"Martes\" ) Los par\u00e1metros no son modificables dentro del cuerpo de la funci\u00f3n, es decir, dentro del cuerpo se tratan como si fueran constantes definidas con let . Podemos cambiar esto marcando el par\u00e1metro con inout . Las funciones son \"ciudadanos de primera clase\", al igual que cualquier objeto se pueden pasar como par\u00e1metro y una funci\u00f3n puede devolver otra funci\u00f3n Ejercicio 4 Implementa una funci\u00f3n filtrar a la que le pases una lista de valores Int y un valor m\u00e1ximo y devuelva una nueva lista con todos los valores que no superan este m\u00e1ximo. El primer par\u00e1metro no debe tener etiqueta y el segundo max . Por ejemplo esto devolver\u00eda la lista [4 5] (cuidado, swift tiene una funci\u00f3n filter que hace esto, pero evidentemente no puedes usarla para este ejercicio) var lista = [ 10 , 4 , 5 , 7 ] var f = filtrar ( lista , max : 5 ) print ( f ) //[4,5]","title":"Funciones"},{"location":"s1/swift_basico/#clases","text":"","title":"Clases"},{"location":"s1/swift_basico/#sintaxis-basica","text":"La sintaxis es similar a Java con algunas diferencias: No se pone new para instanciar un nuevo objeto, sino solo el nombre del constructor En lugar de this , se pone self Los constructores, aqu\u00ed llamados inicializadores se definen en el c\u00f3digo de la clase con el nombre init por ejemplo: class Figura { var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } func descripcion () -> String { return \"Una figura con \\( numeroDeLados ) lados.\" } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ())","title":"Sintaxis b\u00e1sica"},{"location":"s1/swift_basico/#propiedades-computadas","text":"Son getters / setters , desde \"fuera\" parecen propiedades pero en realidad son m\u00e9todos class Figura { private var numeroDeLados = 0 init ( lados : Int ) { self . numeroDeLados = lados } var descripcion : String { get { return \"Una figura con \\( numeroDeLados ) lados.\" } } var lados : Int { get { return numeroDeLados } set ( lados ) { self . numeroDeLados = lados } } } let hexagono = Figura ( lados : 6 ); print ( hexagono . descripcion ) Los objetos se pasan por referencia igual que en Java let h1 = Figura ( lados : 6 ) let h2 = h1 //no es copia, sino referencia. h1 y h2 \"apuntan\" al mismo objeto h2 . lados = 5 print ( h1 . descripcion ) //Una figura con 5 lados (!!) Las struct se parecen mucho a las clases, mucho m\u00e1s que en C, las veremos en siguientes sesiones. Ejercicio 5 Crea una clase Persona con un nombre , una edad y una propiedad computable booleana adulto que indique si tiene 18 a\u00f1os o m\u00e1s. Comprueba que el siguiente c\u00f3digo funciona con tu clase: var p = Persona ( nombre : \"Pepe\" , edad : 20 ) //deber\u00eda imprimir ADULTO! ya que la edad de la persona es >= 18 if p . adulto { print ( \"ADULTO!\" ) }","title":"Propiedades computadas"},{"location":"s1/swift_basico/#herencia","text":"Para la herencia se usa la notaci\u00f3n class ClaseHeredada : ClaseBase , y para sobreescribir un m\u00e9todo, override `","title":"Herencia"},{"location":"s1/swift_basico/#failable-initializers","text":"Cualquier m\u00e9todo, incluyendo un inicializador, puede devolver un valor opcional. En este \u00faltimo caso, estamos indicando que si algo no es correcto no vamos a devolver una nueva instancia, sino nil . Estos inicializadores se denominan failable initializers y se denotan con init? . Por ejemplo supongamos que nos damos cuenta que no tienen sentido las figuras con n\u00famero de lados <=2: class Figura { private var numeroDeLados : Int init ?( lados : Int ) { if lados > 2 { self . numeroDeLados = lados } else { return nil } } ... } Como vemos, el failable initializer devuelve nil cuando no queremos devolver una instancia de la clase.","title":"Failable initializers"},{"location":"s1/swift_basico/#casting-de-clases","text":"Algunas veces ciertos APIs devuelven resultados \"sin tipo\" (en Swift se pone como Any ), pero es posible que nosotros sepamos que una variable es de una determinada clase. Podemos forzar esa conversi\u00f3n con as : dato as Clase . Tambi\u00e9n podemos hacer esto si tenemos una variable de una clase base pero nosotros sabemos que en realidad es una instancia de una clase derivada. var t = miFigura as Triangulo","title":"Casting de clases"},{"location":"s1/swift_basico/#extensiones","text":"Nos permiten a\u00f1adir nueva funcionalidad a clases ya existentes, incluso aun sin acceso al c\u00f3digo fuente o en clases del sistema. Se pueden a\u00f1adir por ejemplo nuevos m\u00e9todos, inicializadores y propiedades computadas. Lo que no se puede hacer es sobreescribir los m\u00e9todos o propiedades ya existentes. extension String { func reggaetonizar () -> String { return self + \" ya t\u00fa sabes\" } } Podemos usar los m\u00e9todos y propiedades de la extensi\u00f3n como us\u00e1bamos los originales: print ( \"mami\" . reggaetonizar ()) //mami ya t\u00fa sabes","title":"Extensiones"},{"location":"s1/swift_basico/#enumerados","text":"Se definen de forma similar a C pero no tienen nada que ver, son tipos \"por derecho propio\", no enteros enum Direccion { case norte , sur , este , oeste } var d = Direccion . norte //si el compilador ya \"sabe\" el tipo no hace falta poner el \"prefijo\" del enumerado (Direccion) var d2 : Direccion = . norte Los enumerados pueden tener un valor \"interno\" ( raw ), cuyo tipo se indica como si el enumerado heredara de \u00e9l. Cuando se pone Int , Swift asigna valores comenzando por 0. Accedemos a este valor con rawValue . enum Direccion : Int { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //0 Si indicamos String como tipo del rawValue Swift hace una \"conversi\u00f3n autom\u00e1tica\" de los nombres a Strings enum Direccion : String { case norte , sur , este , oeste } print ( Direccion . norte . rawValue ) //\"norte\" Los enum pueden tener m\u00e9todos y ser conforme a protocolos (estos \u00faltimos son similares a los interfaces de Java). enum Direccion : String { case norte , sur , este , oeste func inicial ()-> String { let cadena = self . rawValue let inicial = cadena [ cadena . startIndex ] return String ( inicial ). uppercased () } } print ( Direccion . norte . inicial ()) //\"N\" Ejercicio 6 Crea un tipo enumerado DiaSemana para los d\u00edas de la semana (lunes, martes,...). Su rawValue ser\u00e1 Int . A\u00f1\u00e1dele un m\u00e9todo cuantoFalta que devuelva el n\u00famero de d\u00edas que faltan para el fin de semana o bien 0 si es s\u00e1bado o domingo. Al probarlo deber\u00eda ser algo de este estilo: var dia = DiaSemana . lunes print ( dia . rawValue ) //0 dia = . viernes print ( dia . cuantoFalta ()) //1","title":"Enumerados"},{"location":"s2/aplicaciones_ios/","text":"Introducci\u00f3n a las aplicaciones iOS \u00b6 Una vez vistos los conceptos b\u00e1sicos del lenguaje de programaci\u00f3n que vamos a usar, que es Swift, vamos a ver qu\u00e9 estructura tienen las aplicaciones en iOS. Como ahora mismo veremos, Apple utiliza mucho los patrones de dise\u00f1o software en iOS. De hecho todas las apps de esta plataforma siguen el conocido patr\u00f3n Modelo/Vista/Controlador. Por ello veremos primero en qu\u00e9 consiste, c\u00f3mo se implementa en iOS y qu\u00e9 clases b\u00e1sicas forman la estructura de toda aplicaci\u00f3n. Implementaremos nuestra primera aplicaci\u00f3n iOS para poder entender mejor todos estos conceptos. Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC \u00b6 Como acabamos de comentar, las aplicaciones iOS siguen el archiconocido patr\u00f3n de dise\u00f1o \"Modelo/Vista/Controlador\", abreviado com\u00fanmente como MVC. Aunque hay muchas variantes de este patr\u00f3n y los detalles var\u00edan mucho entre ellas, en general en todas: El modelo es el \"coraz\u00f3n\" de la aplicaci\u00f3n y la parte que no se ve , es decir, la estructura de clases que modelan la llamada l\u00f3gica de negocio . Una de las ideas b\u00e1sicas de MVC es que el modelo deber\u00eda ser independiente de la interfaz (la vista) y por tanto reutilizable aunque cambie la interfaz de la aplicaci\u00f3n. En general, los frameworks de desarrollo de aplicaciones MVC es en lo que menos suelen intervenir, e iOS no es una excepci\u00f3n. Es decir, el modelo estar\u00e1 constituido generalmente por clases propias, y no necesariamente de ninguna biblioteca del sistema. La vista es la interfaz de la aplicaci\u00f3n. Generalmente todas las plataformas de desarrollo para m\u00f3viles tienen una biblioteca de componentes de interfaz de usuario: botones, campos de texto, sliders , ... que podemos usar para componer la vista. Como veremos, en iOS podemos crear la interfaz \"arrastrando\" componentes en un editor gr\u00e1fico integrado en Xcode. O tambi\u00e9n podemos crear la interfaz por c\u00f3digo. El controlador es el elemento que presenta m\u00e1s diferencias de una variante a otra de MVC. responde a eventos (generalmente acciones del usuario - por ejemplo un tap sobre un bot\u00f3n) y realiza peticiones al modelo. Al contrario, tambi\u00e9n puede detectar un cambio en el modelo y solicitarle a la vista que lo muestre. Como veremos, en iOS el controlador es una clase que hereda de una propia del sistema. Aunque en MVC el papel de estos elementos est\u00e1 m\u00e1s o menos claro en t\u00e9rminos generales, no suele estar tan clara la relaci\u00f3n entre ellos (qui\u00e9n comunica con qui\u00e9n y c\u00f3mo). En la variante concreta de MVC que se usa en iOS, la relaci\u00f3n entre estos tres elementos se muestra en la siguiente figura: Como vemos, el controlador est\u00e1 \"enmedio\" de la vista y el modelo, aislando ambos entre s\u00ed, de modo que vista y modelo no tienen comunicaci\u00f3n directa. Esto nos permite modificar uno sin afectar al otro. En cuanto a la comunicaci\u00f3n entre vista y controlador: Cuando la vista genera un evento, el controlador lo recibe a trav\u00e9s de lo que en iOS se llama un action . B\u00e1sicamente es un m\u00e9todo del controlador que hace de callback del evento. El controlador guarda referencias a los elementos de la vista que nos interesa en lo que se denominan outlets . As\u00ed puede cambiar la vista (por ejemplo cambiar el texto de un campo o desactivar un bot\u00f3n) Y entre modelo y controlador: El controlador guarda una referencia al modelo y a trav\u00e9s de ella puede llamar a sus m\u00e9todos. Cuando se produce un cambio en el modelo, este \"avisa\" al controlador mediante m\u00e9todos est\u00e1ndar en iOS para comunicaci\u00f3n entre objetos, como son el KVO y las notificaciones locales. Comenzando nuestra primera aplicaci\u00f3n iOS \u00b6 Vamos a implementar una aplicaci\u00f3n muy sencilla a la que llamaremos \"UAdivino\". Es una versi\u00f3n del cl\u00e1sico juguete \" la bola 8 m\u00e1gica \", a la que se le formula una pregunta y que supuestamente responde, dando en realidad respuestas gen\u00e9ricas: \"s\u00ed\", \"\u00a1claro que no!\", \"es muy posible\",... Para crear la aplicaci\u00f3n arrancamos Xcode, aparecer\u00e1 el asistente inicial, que es un cuadro de di\u00e1logo titulado \"Welcome to Xcode\" En las opciones de la izquierda seleccionamos \"Create a new Xcode project\". En el siguiente paso elegimos la plantilla \"App\" asegur\u00e1ndonos que en el men\u00fa de opciones est\u00e1 marcado \"iOS\" y no \"multiplatform\" como aparece por defecto la primera vez Tras darle a Next , escribimos el nombre del proyecto o \"product name\", en nuestro caso UAdivino . Hay que asegurarse que en el desplegable de Interface se selecciona Storyboard (SwiftUI no lo usaremos de momento). Tambi\u00e9n podemos desmarcar la casilla \"Include Tests\" ya que tampoco los usaremos todav\u00eda. En la \u00faltima pantalla del asistente podemos seleccionar la carpeta donde guardar el proyecto. Elegimos la que queramos. Adem\u00e1s marcad \"Create git repository on my Mac\" para crear un repositorio git para el proyecto Finalmente pulsad el bot\u00f3n \"Create\" y aparecer\u00e1 la plantilla b\u00e1sica creada por Xcode, cuya estructura veremos a continuaci\u00f3n. Si es el primer proyecto Xcode que creas con repositorio git asociado aparecer\u00e1 un cuadro de di\u00e1logo diciendo que no hay informaci\u00f3n de autor para el control de versiones. D\u00e1ndole a Fix... aparecer\u00e1 un di\u00e1logo donde podremos poner el nombre y email del usuario que aparecer\u00e1 como autor de los commits. Estructura del c\u00f3digo de una aplicaci\u00f3n \u00b6 La siguiente figura, tomada de la \" App programming guide for iOS \" de Apple, muestra los elementos b\u00e1sicos de cualquier aplicaci\u00f3n iOS. Podemos distinguir la parte del modelo, la del controlador y la de la vista. N\u00f3tese que no hay un \u00fanico controlador ni una \u00fanica vista. En general, podr\u00edamos decir que por cada \"pantalla\" de nuestra aplicaci\u00f3n tendremos un controlador \"principal\" que controla una vista. Esa vista a su vez est\u00e1 formada por una jerarqu\u00eda de subvistas (paneles, botones, sliders ,...). Esto no hay que tomarlo literalmente, ya que en una \"pantalla\" puede haber m\u00e1s de un controlador, pero es \u00fatil para hacerse una idea aproximada. La plantilla creada por Xcode \u00b6 Para no tener que partir de cero, Xcode nos ha creado una plantilla con varias clases y archivos adicionales, que se corresponden con la estructura gen\u00e9rica de una aplicaci\u00f3n que acabamos de ver: Clases: AppDelegate : es la clase que gestiona lo que hacer ante los diferentes eventos del ciclo de vida de la aplicaci\u00f3n: cuando acaba de arrancar, cuando va a pasar a segundo plano, ... ViewController es el controlador \"inicial\" de la aplicaci\u00f3n, el que \"entra en acci\u00f3n\" cuando esta arranca. En nuestro caso adem\u00e1s es el \u00fanico controlador ya que nuestra aplicaci\u00f3n solo tiene una pantalla. SceneDelegate : podr\u00edamos tener una aplicaci\u00f3n \"multiescena\" que ser\u00eda algo as\u00ed como \"multiventana\" (aunque no exactamente). Nosotros no usaremos estas funcionalidades as\u00ed que ignoraremos esta clase por el momento. Archivos de interfaz de usuario: los .storyboard , que constituyen el interfaz gr\u00e1fico de la aplicaci\u00f3n Main.storyboard : el interfaz en s\u00ed de la app , que luego editaremos LaunchScreen.storyboard : la pantalla que aparece mientras la aplicaci\u00f3n se est\u00e1 cargando Archivos de configuraci\u00f3n info.plist : propiedades de configuraci\u00f3n de la aplicaci\u00f3n, en un formato especial denominado plist que ya veremos con detalle en la asignatura de persistencia de datos. Por ahora nos basta con saber que es una lista de nombres y valores de propiedades y que los valores pueden ser num\u00e9ricos, cadenas o listas. Recursos: la carpeta Assets.xcassets , que es donde se colocan las im\u00e1genes y otros recursos de la aplicaci\u00f3n Creaci\u00f3n de la interfaz (la vista) \u00b6 La interfaz de la aplicaci\u00f3n va a tener el siguiente aspecto, con un \"cartel\" explicando qu\u00e9 hace la app , un bot\u00f3n para solicitar la respuesta, y un campo en el que aparecer\u00e1 dicha respuesta. Como hemos comentado, la interfaz est\u00e1 definida en el archivo Main.storyboard . \u00c1brelo y ver\u00e1s que en el editor aparece una pantalla de iPhone vac\u00eda. La flecha que apunta desde la izquierda indica que es la pantalla inicial de la app . En la parte inferior del editor aparece un mensaje de View as: iPhone ... y el modelo que tengas seleccionado en ese momento. Pulsando sobre \u00e9l puedes cambiar el dispositivo y/o la orientaci\u00f3n. Debido a la distinta resoluci\u00f3n de cada dispositivo, el dise\u00f1o de pantalla que hagas aqu\u00ed en principio solo se va a ver bien en un dispositivo y una orientaci\u00f3n concretas . Para hacer interfaces que se adapten al dispositivo necesitas autolayout y traits que se ver\u00e1n con posterioridad en el curso. Vamos a a\u00f1adir los componentes de la interfaz. En la parte superior derecha de la barra de botones ver\u00e1s un bot\u00f3n con un s\u00edmbolo de un '+'. Al pulsar en \u00e9l se mostrar\u00e1 una ventana flotante con los componentes de interfaz de usuario. Este bot\u00f3n ha cambiado en las \u00faltimas versiones de Xcode. En la 10 ten\u00eda un s\u00edmbolo de un cuadrado dentro de un c\u00edrculo. En la 9 e inferiores no exist\u00eda, el panel de componentes se ve\u00eda en la parte inferior derecha de la ventana, sin necesidad de pulsar ning\u00fan bot\u00f3n. Primero vamos a hacer el \"cartel\" con el mensaje de \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\". En iOS este tipo de componente es un Label . B\u00fascalo en el panel de componentes y arr\u00e1stralo a la pantalla que estamos dise\u00f1ando. Una vez colocada puedes hacer las operaciones habituales: moverla con el rat\u00f3n, cambiar su tama\u00f1o arrastrando los puntos de las esquinas o editar el contenido con doble clic. Cambia el texto del Label por un mensaje como \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\" Las propiedades de cualquier componente tambi\u00e9n se pueden cambiar en el panel de la derecha estando seleccionado el componente. Este panel est\u00e1 dividido en varias secciones, por las que se navega con los iconos de la parte superior. La que m\u00e1s nos interesa por el momento es la cuarta, denominada \"property inspector\". Cambia el n\u00famero de l\u00edneas a 2 para que el texto quepa en la pantalla. Cambia tambi\u00e9n la alineaci\u00f3n del texto a centrado para que quede mejor. Arrastra los dos componentes que faltan: un bot\u00f3n ( Button ) y otro Label que debes dejar con el texto vac\u00edo y donde aparecer\u00e1 el mensaje del adivino. Implementaci\u00f3n del modelo \u00b6 En esta app el modelo lo \u00fanico que debe hacer es generar respuestas al azar a demanda. Lo podemos implementar en una clase Adivino que tenga un m\u00e9todo obtenerRespuesta Para colocar el c\u00f3digo de la clase debemos crear un archivo Swift: en Xcode, File > New > File... y en el asistente seleccionamos la plantilla \"Swift File\". Lo guardamos en la misma carpeta UAdivino class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"Si\" , \"No\" , \"Ni de casualidad\" , \"\u00a1Por supuesto!\" ] let indice = Int . random ( in : 0. .< respuestas . count ) return respuestas [ indice ] } } Podemos comprobar provisionalmente que el modelo funciona instanciando un Adivino cuando la app arranque y generando varias respuestas. Algo como: let adivino = Adivino () for _ in 1. .. 5 { print ( adivino . obtenerRespuesta ()) } Podemos insertar el c\u00f3digo anterior en la clase AppDelegate , dentro del primero de sus m\u00e9todos : application(_ application:, didFinishLaunchingWithOptions:) , que es el que se ejecuta al terminar de arrancar la aplicaci\u00f3n. Para ejecutar el proyecto pulsa al bot\u00f3n con el s\u00edmbolo de \"Play\" de la barra superior de Xcode, o bien selecciona la opci\u00f3n de men\u00fa Product > Run . Aparecer\u00e1 el simulador de iOS con la pantalla del iPhone, y en la consola de Xcode deber\u00edan aparecer los mensajes generados por el \"adivino\". Implementaci\u00f3n del controlador \u00b6 En el controlador es donde vamos a hacer la comunicaci\u00f3n entre la vista y el modelo. Cada vez que se pulse el bot\u00f3n, el modelo debe generar una respuesta Esta respuesta se debe mostrar como texto del Label que ahora tenemos provisionalmente vac\u00edo. Recibir eventos de la vista \u00b6 Para recibir eventos de la vista, necesitamos crear un action . Esto es lo que en otros entornos de programaci\u00f3n se conoce como listener , event handler , callback ,... Es simplemente un m\u00e9todo del controller al que el sistema llama cuando se produce un determinado evento sobre un componente de la interfaz. Para crear un action que vincule el bot\u00f3n y el controlador hay que seguir estos pasos en Xcode: Tener abierto el storyboard con la pantalla donde est\u00e1 el componente a vincular (en nuestro caso el bot\u00f3n) Pasar a editar en modo asistente , en el que se ve tanto la interfaz como el c\u00f3digo. En la esquina superior derecha hay un icono de unas l\u00edneas. Si lo pulsamos aparecer\u00e1 un men\u00fa desplegable con varias opciones, hay que elegir la segunda, \"Assistant\". El editor se dividir\u00e1 para mostrar no solo la interfaz sino tambi\u00e9n el c\u00f3digo fuente del controller asociado. En el c\u00f3digo fuente del ViewController buscamos un \"hueco\" donde se pueda crear un m\u00e9todo que ser\u00e1 el llamado cuando se genere el evento. Finalmente, para vincular, hacer clic con el rat\u00f3n sobre el Button pero manteniendo pulsada tambi\u00e9n la tecla Ctrl . Sin soltar el rat\u00f3n, \"conectamos\" con el c\u00f3digo fuente del controller al punto del c\u00f3digo del ViewController que hemos decidido antes. Al soltar el bot\u00f3n del rat\u00f3n nos dar\u00e1 a elegir el tipo de conexi\u00f3n ( Connection ). Seleccionamos Action , escribimos el nombre que tendr\u00e1 el m\u00e9todo (por ejemplo botonPulsado ) y pulsamos el bot\u00f3n Connect . N\u00f3tese que el m\u00e9todo que se ha creado lleva una anotaci\u00f3n especial, @IBAction que indica que es un action . Adem\u00e1s a la izquierda del nombre sale un c\u00edrculo \"relleno\" que indica que est\u00e1 conectado a un componente de la interfaz. Si pasamos el rat\u00f3n por encima aparecer\u00e1 destacado el componente en fondo azul. Llamar al modelo \u00b6 Ahora en el m\u00e9todo del action botonPulsado tenemos que llamar al modelo. En nuestro caso es tan simple como llamar a obtenerRespuesta() pero para eso necesitamos declarar una instancia del modelo en el controlador. Por ello le a\u00f1adimos una nueva propiedad: //En el ViewController.swift class ViewController : UIViewController { let miAdivino = Adivino () ... Ahora tenemos que obtener una respuesta cuando se pulse el bot\u00f3n: @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () } pero todav\u00eda nos falta mostrarla en la interfaz. Para eso necesitamos conectar el controller con la vista Modificar la vista \u00b6 Por cada componente de la interfaz de usuario que queramos modificar desde el controller necesitamos definir un outlet , que no es m\u00e1s que una variable que referencia al componente. Pero la variable no la declaramos nosotros sino que se crea de forma parecida a como se crean los action : gr\u00e1ficamente, con el rat\u00f3n. Queremos conectar el controller con el Label que por ahora tiene texto vac\u00edo: De nuevo ponemos el editor en modo asistente, y buscamos un \"hueco\" apropiado en el c\u00f3digo fuente del controller donde se pueda definir la variable. Arrastramos con Ctrl + clic desde el bot\u00f3n al c\u00f3digo del controller pero ahora cuando soltemos el bot\u00f3n del rat\u00f3n y nos pregunte el tipo de conexi\u00f3n dejamos Outlet . Escribimos un nombre apropiado para la variable (por ejemplo labelRespuesta ) y pulsamos sobre Connect . Vemos que la variable reci\u00e9n creada es del tipo UILabel y lleva la anotaci\u00f3n @IBOutlet para indicar que es un outlet . Si miramos la documentaci\u00f3n de iOS veremos que a trav\u00e9s de la propiedad text tenemos acceso al texto del componente. Por lo que finalmente el m\u00e9todo del action que hemos hecho antes quedar\u00e1: @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = respuesta } Ya deber\u00eda funcionar todo correctamente, as\u00ed que ya podemos probar la app .","title":"Introducci\u00f3n a las aplicaciones iOS"},{"location":"s2/aplicaciones_ios/#introduccion-a-las-aplicaciones-ios","text":"Una vez vistos los conceptos b\u00e1sicos del lenguaje de programaci\u00f3n que vamos a usar, que es Swift, vamos a ver qu\u00e9 estructura tienen las aplicaciones en iOS. Como ahora mismo veremos, Apple utiliza mucho los patrones de dise\u00f1o software en iOS. De hecho todas las apps de esta plataforma siguen el conocido patr\u00f3n Modelo/Vista/Controlador. Por ello veremos primero en qu\u00e9 consiste, c\u00f3mo se implementa en iOS y qu\u00e9 clases b\u00e1sicas forman la estructura de toda aplicaci\u00f3n. Implementaremos nuestra primera aplicaci\u00f3n iOS para poder entender mejor todos estos conceptos.","title":"Introducci\u00f3n a las aplicaciones iOS"},{"location":"s2/aplicaciones_ios/#patron-general-para-una-aplicacion-ios-mvc","text":"Como acabamos de comentar, las aplicaciones iOS siguen el archiconocido patr\u00f3n de dise\u00f1o \"Modelo/Vista/Controlador\", abreviado com\u00fanmente como MVC. Aunque hay muchas variantes de este patr\u00f3n y los detalles var\u00edan mucho entre ellas, en general en todas: El modelo es el \"coraz\u00f3n\" de la aplicaci\u00f3n y la parte que no se ve , es decir, la estructura de clases que modelan la llamada l\u00f3gica de negocio . Una de las ideas b\u00e1sicas de MVC es que el modelo deber\u00eda ser independiente de la interfaz (la vista) y por tanto reutilizable aunque cambie la interfaz de la aplicaci\u00f3n. En general, los frameworks de desarrollo de aplicaciones MVC es en lo que menos suelen intervenir, e iOS no es una excepci\u00f3n. Es decir, el modelo estar\u00e1 constituido generalmente por clases propias, y no necesariamente de ninguna biblioteca del sistema. La vista es la interfaz de la aplicaci\u00f3n. Generalmente todas las plataformas de desarrollo para m\u00f3viles tienen una biblioteca de componentes de interfaz de usuario: botones, campos de texto, sliders , ... que podemos usar para componer la vista. Como veremos, en iOS podemos crear la interfaz \"arrastrando\" componentes en un editor gr\u00e1fico integrado en Xcode. O tambi\u00e9n podemos crear la interfaz por c\u00f3digo. El controlador es el elemento que presenta m\u00e1s diferencias de una variante a otra de MVC. responde a eventos (generalmente acciones del usuario - por ejemplo un tap sobre un bot\u00f3n) y realiza peticiones al modelo. Al contrario, tambi\u00e9n puede detectar un cambio en el modelo y solicitarle a la vista que lo muestre. Como veremos, en iOS el controlador es una clase que hereda de una propia del sistema. Aunque en MVC el papel de estos elementos est\u00e1 m\u00e1s o menos claro en t\u00e9rminos generales, no suele estar tan clara la relaci\u00f3n entre ellos (qui\u00e9n comunica con qui\u00e9n y c\u00f3mo). En la variante concreta de MVC que se usa en iOS, la relaci\u00f3n entre estos tres elementos se muestra en la siguiente figura: Como vemos, el controlador est\u00e1 \"enmedio\" de la vista y el modelo, aislando ambos entre s\u00ed, de modo que vista y modelo no tienen comunicaci\u00f3n directa. Esto nos permite modificar uno sin afectar al otro. En cuanto a la comunicaci\u00f3n entre vista y controlador: Cuando la vista genera un evento, el controlador lo recibe a trav\u00e9s de lo que en iOS se llama un action . B\u00e1sicamente es un m\u00e9todo del controlador que hace de callback del evento. El controlador guarda referencias a los elementos de la vista que nos interesa en lo que se denominan outlets . As\u00ed puede cambiar la vista (por ejemplo cambiar el texto de un campo o desactivar un bot\u00f3n) Y entre modelo y controlador: El controlador guarda una referencia al modelo y a trav\u00e9s de ella puede llamar a sus m\u00e9todos. Cuando se produce un cambio en el modelo, este \"avisa\" al controlador mediante m\u00e9todos est\u00e1ndar en iOS para comunicaci\u00f3n entre objetos, como son el KVO y las notificaciones locales.","title":"Patr\u00f3n general para una aplicaci\u00f3n iOS: MVC"},{"location":"s2/aplicaciones_ios/#comenzando-nuestra-primera-aplicacion-ios","text":"Vamos a implementar una aplicaci\u00f3n muy sencilla a la que llamaremos \"UAdivino\". Es una versi\u00f3n del cl\u00e1sico juguete \" la bola 8 m\u00e1gica \", a la que se le formula una pregunta y que supuestamente responde, dando en realidad respuestas gen\u00e9ricas: \"s\u00ed\", \"\u00a1claro que no!\", \"es muy posible\",... Para crear la aplicaci\u00f3n arrancamos Xcode, aparecer\u00e1 el asistente inicial, que es un cuadro de di\u00e1logo titulado \"Welcome to Xcode\" En las opciones de la izquierda seleccionamos \"Create a new Xcode project\". En el siguiente paso elegimos la plantilla \"App\" asegur\u00e1ndonos que en el men\u00fa de opciones est\u00e1 marcado \"iOS\" y no \"multiplatform\" como aparece por defecto la primera vez Tras darle a Next , escribimos el nombre del proyecto o \"product name\", en nuestro caso UAdivino . Hay que asegurarse que en el desplegable de Interface se selecciona Storyboard (SwiftUI no lo usaremos de momento). Tambi\u00e9n podemos desmarcar la casilla \"Include Tests\" ya que tampoco los usaremos todav\u00eda. En la \u00faltima pantalla del asistente podemos seleccionar la carpeta donde guardar el proyecto. Elegimos la que queramos. Adem\u00e1s marcad \"Create git repository on my Mac\" para crear un repositorio git para el proyecto Finalmente pulsad el bot\u00f3n \"Create\" y aparecer\u00e1 la plantilla b\u00e1sica creada por Xcode, cuya estructura veremos a continuaci\u00f3n. Si es el primer proyecto Xcode que creas con repositorio git asociado aparecer\u00e1 un cuadro de di\u00e1logo diciendo que no hay informaci\u00f3n de autor para el control de versiones. D\u00e1ndole a Fix... aparecer\u00e1 un di\u00e1logo donde podremos poner el nombre y email del usuario que aparecer\u00e1 como autor de los commits.","title":"Comenzando nuestra primera aplicaci\u00f3n iOS"},{"location":"s2/aplicaciones_ios/#estructura-del-codigo-de-una-aplicacion","text":"La siguiente figura, tomada de la \" App programming guide for iOS \" de Apple, muestra los elementos b\u00e1sicos de cualquier aplicaci\u00f3n iOS. Podemos distinguir la parte del modelo, la del controlador y la de la vista. N\u00f3tese que no hay un \u00fanico controlador ni una \u00fanica vista. En general, podr\u00edamos decir que por cada \"pantalla\" de nuestra aplicaci\u00f3n tendremos un controlador \"principal\" que controla una vista. Esa vista a su vez est\u00e1 formada por una jerarqu\u00eda de subvistas (paneles, botones, sliders ,...). Esto no hay que tomarlo literalmente, ya que en una \"pantalla\" puede haber m\u00e1s de un controlador, pero es \u00fatil para hacerse una idea aproximada.","title":"Estructura del c\u00f3digo de una aplicaci\u00f3n"},{"location":"s2/aplicaciones_ios/#la-plantilla-creada-por-xcode","text":"Para no tener que partir de cero, Xcode nos ha creado una plantilla con varias clases y archivos adicionales, que se corresponden con la estructura gen\u00e9rica de una aplicaci\u00f3n que acabamos de ver: Clases: AppDelegate : es la clase que gestiona lo que hacer ante los diferentes eventos del ciclo de vida de la aplicaci\u00f3n: cuando acaba de arrancar, cuando va a pasar a segundo plano, ... ViewController es el controlador \"inicial\" de la aplicaci\u00f3n, el que \"entra en acci\u00f3n\" cuando esta arranca. En nuestro caso adem\u00e1s es el \u00fanico controlador ya que nuestra aplicaci\u00f3n solo tiene una pantalla. SceneDelegate : podr\u00edamos tener una aplicaci\u00f3n \"multiescena\" que ser\u00eda algo as\u00ed como \"multiventana\" (aunque no exactamente). Nosotros no usaremos estas funcionalidades as\u00ed que ignoraremos esta clase por el momento. Archivos de interfaz de usuario: los .storyboard , que constituyen el interfaz gr\u00e1fico de la aplicaci\u00f3n Main.storyboard : el interfaz en s\u00ed de la app , que luego editaremos LaunchScreen.storyboard : la pantalla que aparece mientras la aplicaci\u00f3n se est\u00e1 cargando Archivos de configuraci\u00f3n info.plist : propiedades de configuraci\u00f3n de la aplicaci\u00f3n, en un formato especial denominado plist que ya veremos con detalle en la asignatura de persistencia de datos. Por ahora nos basta con saber que es una lista de nombres y valores de propiedades y que los valores pueden ser num\u00e9ricos, cadenas o listas. Recursos: la carpeta Assets.xcassets , que es donde se colocan las im\u00e1genes y otros recursos de la aplicaci\u00f3n","title":"La plantilla creada por Xcode"},{"location":"s2/aplicaciones_ios/#creacion-de-la-interfaz-la-vista","text":"La interfaz de la aplicaci\u00f3n va a tener el siguiente aspecto, con un \"cartel\" explicando qu\u00e9 hace la app , un bot\u00f3n para solicitar la respuesta, y un campo en el que aparecer\u00e1 dicha respuesta. Como hemos comentado, la interfaz est\u00e1 definida en el archivo Main.storyboard . \u00c1brelo y ver\u00e1s que en el editor aparece una pantalla de iPhone vac\u00eda. La flecha que apunta desde la izquierda indica que es la pantalla inicial de la app . En la parte inferior del editor aparece un mensaje de View as: iPhone ... y el modelo que tengas seleccionado en ese momento. Pulsando sobre \u00e9l puedes cambiar el dispositivo y/o la orientaci\u00f3n. Debido a la distinta resoluci\u00f3n de cada dispositivo, el dise\u00f1o de pantalla que hagas aqu\u00ed en principio solo se va a ver bien en un dispositivo y una orientaci\u00f3n concretas . Para hacer interfaces que se adapten al dispositivo necesitas autolayout y traits que se ver\u00e1n con posterioridad en el curso. Vamos a a\u00f1adir los componentes de la interfaz. En la parte superior derecha de la barra de botones ver\u00e1s un bot\u00f3n con un s\u00edmbolo de un '+'. Al pulsar en \u00e9l se mostrar\u00e1 una ventana flotante con los componentes de interfaz de usuario. Este bot\u00f3n ha cambiado en las \u00faltimas versiones de Xcode. En la 10 ten\u00eda un s\u00edmbolo de un cuadrado dentro de un c\u00edrculo. En la 9 e inferiores no exist\u00eda, el panel de componentes se ve\u00eda en la parte inferior derecha de la ventana, sin necesidad de pulsar ning\u00fan bot\u00f3n. Primero vamos a hacer el \"cartel\" con el mensaje de \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\". En iOS este tipo de componente es un Label . B\u00fascalo en el panel de componentes y arr\u00e1stralo a la pantalla que estamos dise\u00f1ando. Una vez colocada puedes hacer las operaciones habituales: moverla con el rat\u00f3n, cambiar su tama\u00f1o arrastrando los puntos de las esquinas o editar el contenido con doble clic. Cambia el texto del Label por un mensaje como \"Formula una pregunta en voz alta y UAdivino te dar\u00e1 la respuesta\" Las propiedades de cualquier componente tambi\u00e9n se pueden cambiar en el panel de la derecha estando seleccionado el componente. Este panel est\u00e1 dividido en varias secciones, por las que se navega con los iconos de la parte superior. La que m\u00e1s nos interesa por el momento es la cuarta, denominada \"property inspector\". Cambia el n\u00famero de l\u00edneas a 2 para que el texto quepa en la pantalla. Cambia tambi\u00e9n la alineaci\u00f3n del texto a centrado para que quede mejor. Arrastra los dos componentes que faltan: un bot\u00f3n ( Button ) y otro Label que debes dejar con el texto vac\u00edo y donde aparecer\u00e1 el mensaje del adivino.","title":"Creaci\u00f3n de la interfaz (la vista)"},{"location":"s2/aplicaciones_ios/#implementacion-del-modelo","text":"En esta app el modelo lo \u00fanico que debe hacer es generar respuestas al azar a demanda. Lo podemos implementar en una clase Adivino que tenga un m\u00e9todo obtenerRespuesta Para colocar el c\u00f3digo de la clase debemos crear un archivo Swift: en Xcode, File > New > File... y en el asistente seleccionamos la plantilla \"Swift File\". Lo guardamos en la misma carpeta UAdivino class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"Si\" , \"No\" , \"Ni de casualidad\" , \"\u00a1Por supuesto!\" ] let indice = Int . random ( in : 0. .< respuestas . count ) return respuestas [ indice ] } } Podemos comprobar provisionalmente que el modelo funciona instanciando un Adivino cuando la app arranque y generando varias respuestas. Algo como: let adivino = Adivino () for _ in 1. .. 5 { print ( adivino . obtenerRespuesta ()) } Podemos insertar el c\u00f3digo anterior en la clase AppDelegate , dentro del primero de sus m\u00e9todos : application(_ application:, didFinishLaunchingWithOptions:) , que es el que se ejecuta al terminar de arrancar la aplicaci\u00f3n. Para ejecutar el proyecto pulsa al bot\u00f3n con el s\u00edmbolo de \"Play\" de la barra superior de Xcode, o bien selecciona la opci\u00f3n de men\u00fa Product > Run . Aparecer\u00e1 el simulador de iOS con la pantalla del iPhone, y en la consola de Xcode deber\u00edan aparecer los mensajes generados por el \"adivino\".","title":"Implementaci\u00f3n del modelo"},{"location":"s2/aplicaciones_ios/#implementacion-del-controlador","text":"En el controlador es donde vamos a hacer la comunicaci\u00f3n entre la vista y el modelo. Cada vez que se pulse el bot\u00f3n, el modelo debe generar una respuesta Esta respuesta se debe mostrar como texto del Label que ahora tenemos provisionalmente vac\u00edo.","title":"Implementaci\u00f3n del controlador"},{"location":"s2/aplicaciones_ios/#recibir-eventos-de-la-vista","text":"Para recibir eventos de la vista, necesitamos crear un action . Esto es lo que en otros entornos de programaci\u00f3n se conoce como listener , event handler , callback ,... Es simplemente un m\u00e9todo del controller al que el sistema llama cuando se produce un determinado evento sobre un componente de la interfaz. Para crear un action que vincule el bot\u00f3n y el controlador hay que seguir estos pasos en Xcode: Tener abierto el storyboard con la pantalla donde est\u00e1 el componente a vincular (en nuestro caso el bot\u00f3n) Pasar a editar en modo asistente , en el que se ve tanto la interfaz como el c\u00f3digo. En la esquina superior derecha hay un icono de unas l\u00edneas. Si lo pulsamos aparecer\u00e1 un men\u00fa desplegable con varias opciones, hay que elegir la segunda, \"Assistant\". El editor se dividir\u00e1 para mostrar no solo la interfaz sino tambi\u00e9n el c\u00f3digo fuente del controller asociado. En el c\u00f3digo fuente del ViewController buscamos un \"hueco\" donde se pueda crear un m\u00e9todo que ser\u00e1 el llamado cuando se genere el evento. Finalmente, para vincular, hacer clic con el rat\u00f3n sobre el Button pero manteniendo pulsada tambi\u00e9n la tecla Ctrl . Sin soltar el rat\u00f3n, \"conectamos\" con el c\u00f3digo fuente del controller al punto del c\u00f3digo del ViewController que hemos decidido antes. Al soltar el bot\u00f3n del rat\u00f3n nos dar\u00e1 a elegir el tipo de conexi\u00f3n ( Connection ). Seleccionamos Action , escribimos el nombre que tendr\u00e1 el m\u00e9todo (por ejemplo botonPulsado ) y pulsamos el bot\u00f3n Connect . N\u00f3tese que el m\u00e9todo que se ha creado lleva una anotaci\u00f3n especial, @IBAction que indica que es un action . Adem\u00e1s a la izquierda del nombre sale un c\u00edrculo \"relleno\" que indica que est\u00e1 conectado a un componente de la interfaz. Si pasamos el rat\u00f3n por encima aparecer\u00e1 destacado el componente en fondo azul.","title":"Recibir eventos de la vista"},{"location":"s2/aplicaciones_ios/#llamar-al-modelo","text":"Ahora en el m\u00e9todo del action botonPulsado tenemos que llamar al modelo. En nuestro caso es tan simple como llamar a obtenerRespuesta() pero para eso necesitamos declarar una instancia del modelo en el controlador. Por ello le a\u00f1adimos una nueva propiedad: //En el ViewController.swift class ViewController : UIViewController { let miAdivino = Adivino () ... Ahora tenemos que obtener una respuesta cuando se pulse el bot\u00f3n: @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () } pero todav\u00eda nos falta mostrarla en la interfaz. Para eso necesitamos conectar el controller con la vista","title":"Llamar al modelo"},{"location":"s2/aplicaciones_ios/#modificar-la-vista","text":"Por cada componente de la interfaz de usuario que queramos modificar desde el controller necesitamos definir un outlet , que no es m\u00e1s que una variable que referencia al componente. Pero la variable no la declaramos nosotros sino que se crea de forma parecida a como se crean los action : gr\u00e1ficamente, con el rat\u00f3n. Queremos conectar el controller con el Label que por ahora tiene texto vac\u00edo: De nuevo ponemos el editor en modo asistente, y buscamos un \"hueco\" apropiado en el c\u00f3digo fuente del controller donde se pueda definir la variable. Arrastramos con Ctrl + clic desde el bot\u00f3n al c\u00f3digo del controller pero ahora cuando soltemos el bot\u00f3n del rat\u00f3n y nos pregunte el tipo de conexi\u00f3n dejamos Outlet . Escribimos un nombre apropiado para la variable (por ejemplo labelRespuesta ) y pulsamos sobre Connect . Vemos que la variable reci\u00e9n creada es del tipo UILabel y lleva la anotaci\u00f3n @IBOutlet para indicar que es un outlet . Si miramos la documentaci\u00f3n de iOS veremos que a trav\u00e9s de la propiedad text tenemos acceso al texto del componente. Por lo que finalmente el m\u00e9todo del action que hemos hecho antes quedar\u00e1: @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = respuesta } Ya deber\u00eda funcionar todo correctamente, as\u00ed que ya podemos probar la app .","title":"Modificar la vista"},{"location":"s2/ejercicios/","text":"Ejercicios de introducci\u00f3n a las aplicaciones iOS (2 puntos) \u00b6 Desarrolla una app llamada iMoneda con la que se pueda \"lanzar\" una \"moneda virtual\" a ver si sale cara o cruz. La interfaz de la app ser\u00e1 muy sencilla y constar\u00e1 de: Un Button que al ser pulsado \"lanzar\u00e1\" la moneda. Un UIImageView para mostrar la imagen de la cara o de la cruz Un Label para mostrar el resultado en modo texto (\"cara\" o \"cruz\") La vista (0,5 puntos): Crea la interfaz arrastrando los componentes y coloc\u00e1ndolos donde creas conveniente. A\u00f1\u00e1dele al proyecto las im\u00e1genes de la cara y cruz de la moneda. Crea un image set en la carpeta Assets.xcassets llamado cara y otro llamado cruz y deja all\u00ed las im\u00e1genes correspondientes. Ver\u00e1s que est\u00e1n a @2x y @3x. El modelo (0,5 puntos): Crea: Un enumerado Tirada con los valores de cara y cruz Una clase Moneda con un \u00fanico m\u00e9todo lanzar() que devuelva una Tirada al azar El controlador (0,75 punto): Define en \u00e9l una propiedad del tipo Moneda Crea dos outlet , uno para acceder al componente UIImageView y otro para el Label Crea un action que vincule el bot\u00f3n con alg\u00fan m\u00e9todo del ViewController En el c\u00f3digo del action : Usa el m\u00e9todo lanzar() de la Moneda para obtener una tirada Muestra el resultado en modo texto en el Label , (\"cara\", \"cruz\") Muestra la imagen apropiada Aclaraci\u00f3n: C\u00f3mo trabajar con im\u00e1genes Las im\u00e1genes se representan en iOS con objetos UIImage . Podemos obtener la imagen correspondiente a un recurso de los assets con su nombre: let imagenCara = UIImage ( named : \"cara\" ) El UIImageView es un componente de interfaz que contiene una UIImage . Podemos cambiar la imagen asign\u00e1ndola a la propiedad image del UIImageView . let imagenCara = UIImage ( named : \"cara\" ) //SUPONIENDO que el outlet que representa al UIImageView es imageView self . imageView . image = imagenCara (0,25 puntos) Finalmente a\u00f1\u00e1dele un icono a la app y una launch screen con los elementos que consideres. Puedes descargar iconos por ejemplo de icons8.com/icons Puedes cambiar el tama\u00f1o del icono con Vista Previa del Mac (Herramientas>Ajustar Tama\u00f1o...) o bien puedes generar autom\u00e1ticamente los tama\u00f1os necesarios con la ayuda de una web como por ejemplo appicon.co","title":"Ejercicios sobre aplicaciones iOS"},{"location":"s2/ejercicios/#ejercicios-de-introduccion-a-las-aplicaciones-ios-2-puntos","text":"Desarrolla una app llamada iMoneda con la que se pueda \"lanzar\" una \"moneda virtual\" a ver si sale cara o cruz. La interfaz de la app ser\u00e1 muy sencilla y constar\u00e1 de: Un Button que al ser pulsado \"lanzar\u00e1\" la moneda. Un UIImageView para mostrar la imagen de la cara o de la cruz Un Label para mostrar el resultado en modo texto (\"cara\" o \"cruz\") La vista (0,5 puntos): Crea la interfaz arrastrando los componentes y coloc\u00e1ndolos donde creas conveniente. A\u00f1\u00e1dele al proyecto las im\u00e1genes de la cara y cruz de la moneda. Crea un image set en la carpeta Assets.xcassets llamado cara y otro llamado cruz y deja all\u00ed las im\u00e1genes correspondientes. Ver\u00e1s que est\u00e1n a @2x y @3x. El modelo (0,5 puntos): Crea: Un enumerado Tirada con los valores de cara y cruz Una clase Moneda con un \u00fanico m\u00e9todo lanzar() que devuelva una Tirada al azar El controlador (0,75 punto): Define en \u00e9l una propiedad del tipo Moneda Crea dos outlet , uno para acceder al componente UIImageView y otro para el Label Crea un action que vincule el bot\u00f3n con alg\u00fan m\u00e9todo del ViewController En el c\u00f3digo del action : Usa el m\u00e9todo lanzar() de la Moneda para obtener una tirada Muestra el resultado en modo texto en el Label , (\"cara\", \"cruz\") Muestra la imagen apropiada Aclaraci\u00f3n: C\u00f3mo trabajar con im\u00e1genes Las im\u00e1genes se representan en iOS con objetos UIImage . Podemos obtener la imagen correspondiente a un recurso de los assets con su nombre: let imagenCara = UIImage ( named : \"cara\" ) El UIImageView es un componente de interfaz que contiene una UIImage . Podemos cambiar la imagen asign\u00e1ndola a la propiedad image del UIImageView . let imagenCara = UIImage ( named : \"cara\" ) //SUPONIENDO que el outlet que representa al UIImageView es imageView self . imageView . image = imagenCara (0,25 puntos) Finalmente a\u00f1\u00e1dele un icono a la app y una launch screen con los elementos que consideres. Puedes descargar iconos por ejemplo de icons8.com/icons Puedes cambiar el tama\u00f1o del icono con Vista Previa del Mac (Herramientas>Ajustar Tama\u00f1o...) o bien puedes generar autom\u00e1ticamente los tama\u00f1os necesarios con la ayuda de una web como por ejemplo appicon.co","title":"Ejercicios de introducci\u00f3n a las aplicaciones iOS (2 puntos)"},{"location":"s2/recursos/","text":"Recursos en aplicaciones iOS \u00b6 Una app es m\u00e1s que c\u00f3digo, normalmente incluir\u00e1 el propio icono de la app , iconos adicionales para botones/ tab bars , im\u00e1genes, audios, videos o incluso texturas, stickers u otros muchos elementos dependiendo del tipo de app . Todos estos elementos reciben el nombre gen\u00e9rico de recursos . En el proyecto de Xcode podemos ver una carpeta llamada Assets.xcassets que es el asset catalog de la app. Sirve para almacenar los recursos que necesitemos usar en la app. En la documentaci\u00f3n de Apple podemos consultar el uso del editor del asset catalog , aqu\u00ed de momento nos vamos a limitar a ver c\u00f3mo a\u00f1adir un icono para la app y una serie de im\u00e1genes. Resoluciones en dispositivos iOS \u00b6 Antes de ver c\u00f3mo a\u00f1adir im\u00e1genes o iconos necesitamos discutir un poco el tema de la resoluci\u00f3n. El \"parque\" de dispositivos iOS en funcionamiento tiene resoluciones de pantalla muy distintas entre s\u00ed, bien por la diferencia de antig\u00fcedad o bien por tener la pantalla de un tama\u00f1o muy distinto. En dispositivos m\u00e1s o menos actuales van desde los 640x1136 del iPhone SE hasta los 2048x2732 pixeles del iPad Pro de 12.9 pulgadas (pod\u00e9is consultarlo por ejemplo en iOS Resolution ). Si nuestra aplicaci\u00f3n usa im\u00e1genes es normal que las que en un dispositivo de resoluci\u00f3n \"baja\" se ven bien se vean demasiado peque\u00f1as en uno de \"alta\" o bien que si iOS las escala para que ocupen el mismo porcentaje de pantalla se vean pixeladas en dispositivos de alta resoluci\u00f3n. Por eso deber\u00edamos a\u00f1adir cada imagen que use nuestra app a distintas resoluciones. Para simplificar el desarrollo, en iOS se consideran solo 3 resoluciones distintas, llamadas en la documentaci\u00f3n @1x , @2x y @3x . Como su propio nombre indica las dos \u00faltimas son m\u00faltiplos de la primera. Es decir que si tenemos una imagen de 100x100 pixeles como base, deber\u00edamos tener la misma a 200x200 para @2x y 300x300 para @3x . Evidentemente no se trata de que cojamos la misma imagen de 100x100 y la escalemos al doble o triple, ya que se ver\u00edan pixeladas, sino al contrario, que partamos de una imagen en alta resoluci\u00f3n y vayamos generando versiones m\u00e1s peque\u00f1as de la misma. En las \"Human Interface Guidelines\" de Apple tenemos m\u00e1s informaci\u00f3n sobre la resoluci\u00f3n de im\u00e1genes e iconos , adem\u00e1s de consejos de dise\u00f1o y usabilidad. En el mercado ya no quedan pr\u00e1cticamente dispositivos de resoluci\u00f3n @1x y de hecho no la necesitaremos salvo que queramos hacer compatible nuestra app con iOS9 o inferior. Icono de la aplicaci\u00f3n \u00b6 En el asset catalog hay un elemento denominado appIcon donde colocar el icono de la aplicaci\u00f3n. Debido a la diferente resoluci\u00f3n de los dispositivos iOS, como ya hemos visto, los iconos vienen en distintos tama\u00f1os, desde 120x120 para los iPhone a @2x hasta 180x180 a @3x. Otros tama\u00f1os adicionales se usan cuando nuestra app sale en los resultados de Spotlight (la b\u00fasqueda integrada en el dispositivo), si tiene su propio apartado de ajustes en los ajustes del sistema, cuando aparece en las notificaciones, etc. En total en la actualidad pueden hacer falta hasta 9 tama\u00f1os distintos de iconos. Afortunadamente desde la versi\u00f3n 14 de Xcode no es necesario que creemos nosotros todos los tama\u00f1os. Los proyectos est\u00e1n por defecto en modo \"Single size\", lo que quiere decir que si colocamos un icono a 1024x1024 Xcode generar\u00e1 todos los tama\u00f1os autom\u00e1ticamente. Si queremos crear los distintos tama\u00f1os de manera manual, en la parte derecha de la pantalla seleccionar\u00edamos el modo \"All sizes\". En modo manual, si no disponemos de alguno de los tama\u00f1os Xcode lo generar\u00e1 escalando los que haya. Si tenemos un Xcode<14, o queremos desplegar en iOS<12 no podremos usar la opc\u00edon de \"Single size\". Hay p\u00e1ginas web como https://appicon.co/ que pueden generar autom\u00e1ticamente todos los tama\u00f1os a partir de un icono dado. Si seleccionamos el appIcon veremos una plantilla donde \"dejar caer\" el icono 1024x1024 (en modo \"Single size\" o los iconos de cada tama\u00f1o necesario (en modo \"All sizes\"). Hay que tener en cuenta que deben estar en formato PNG sin transparencia. Para m\u00e1s informaci\u00f3n consultad el apartado correspondiente de las Human Interface Guidelines. Im\u00e1genes \u00b6 Como cada imagen deber\u00eda estar al menos en tama\u00f1o @2x y @3x , al a\u00f1adir una imagen a los recursos en realidad estamos a\u00f1adiendo un conjunto de im\u00e1genes o image set . Para crear un image set se puede pulsar el bot\u00f3n de + que aparece en la esquina inferior izquierda del editor del asset catalog y seleccionar New Image set . Por defecto se llamar\u00e1 simplemente Image pero podemos cambiarlo de nombre haciendo doble clic sobre el nombre actual. En el c\u00f3digo de la app podemos usar el nombre dado en el asset catalog para cargar la imagen: let imagenLibro = UIImage ( named : \"libro\" ) \"Truco\" : si las im\u00e1genes tienen un nombre que acaba en @2x o @3x (algo como libro@2x.png ), xCode las usar\u00e1 autom\u00e1ticamente para la resoluci\u00f3n deseada. Xcode tomar\u00e1 la de @1x simplemente como la que no tenga nada especial en el nombre. En el Finder (el administrador de archivos ) podemos seleccionar entonces tres im\u00e1genes juntas (haciendo clic + Cmd para que al seleccionar una no se pierda la anterior) y \"dejarlas caer\" juntas en el image set para que cada una se coloque en su hueco. Launch screen \u00b6 Es una pantalla que iOS mostrar\u00e1 al inicio de la carga de la app . En otros sistemas como Android o el mismo MacOS muchas aplicaciones tienen una splash screen , que aparece al comienzo con un logo, una imagen, los cr\u00e9ditos de la app , etc. Sin embargo seg\u00fan las Human Interface Guidelines de Apple una launch screen no es nada de eso, sino que debe ser lo m\u00e1s parecida posible a la primera pantalla de la app . De este modo se le dar\u00e1 la impresi\u00f3n al usuario de que la aplicaci\u00f3n se carga r\u00e1pidamente. Es decir, la launch screen es una especie de versi\u00f3n \"est\u00e1tica\" o \"de cart\u00f3n piedra\" (\ud83d\ude09) de la primera pantalla de la app . Evidentemente si la app muestra contenido din\u00e1mico este contenido no puede formar parte de la launch screen pero s\u00ed podemos por ejemplo colocar ciertos elementos est\u00e1ticos como botones, cuadros de b\u00fasqueda, tab bars , etc, como puede verse en este ejemplo incluido en la documentaci\u00f3n de Apple: En xCode la launch screen se dise\u00f1a como una pantalla m\u00e1s de la aplicaci\u00f3n, en el LaunchScreen.storyboard , arrastrando componentes de interfaz como en cualquier otra pantalla, aunque los elementos que se incluyan no van a ser interactivos. No se recomienda incluir textos ya que no van a poder adaptarse al idioma del dispositivo.","title":"Recursos en aplicaciones iOS"},{"location":"s2/recursos/#recursos-en-aplicaciones-ios","text":"Una app es m\u00e1s que c\u00f3digo, normalmente incluir\u00e1 el propio icono de la app , iconos adicionales para botones/ tab bars , im\u00e1genes, audios, videos o incluso texturas, stickers u otros muchos elementos dependiendo del tipo de app . Todos estos elementos reciben el nombre gen\u00e9rico de recursos . En el proyecto de Xcode podemos ver una carpeta llamada Assets.xcassets que es el asset catalog de la app. Sirve para almacenar los recursos que necesitemos usar en la app. En la documentaci\u00f3n de Apple podemos consultar el uso del editor del asset catalog , aqu\u00ed de momento nos vamos a limitar a ver c\u00f3mo a\u00f1adir un icono para la app y una serie de im\u00e1genes.","title":"Recursos en aplicaciones iOS"},{"location":"s2/recursos/#resoluciones-en-dispositivos-ios","text":"Antes de ver c\u00f3mo a\u00f1adir im\u00e1genes o iconos necesitamos discutir un poco el tema de la resoluci\u00f3n. El \"parque\" de dispositivos iOS en funcionamiento tiene resoluciones de pantalla muy distintas entre s\u00ed, bien por la diferencia de antig\u00fcedad o bien por tener la pantalla de un tama\u00f1o muy distinto. En dispositivos m\u00e1s o menos actuales van desde los 640x1136 del iPhone SE hasta los 2048x2732 pixeles del iPad Pro de 12.9 pulgadas (pod\u00e9is consultarlo por ejemplo en iOS Resolution ). Si nuestra aplicaci\u00f3n usa im\u00e1genes es normal que las que en un dispositivo de resoluci\u00f3n \"baja\" se ven bien se vean demasiado peque\u00f1as en uno de \"alta\" o bien que si iOS las escala para que ocupen el mismo porcentaje de pantalla se vean pixeladas en dispositivos de alta resoluci\u00f3n. Por eso deber\u00edamos a\u00f1adir cada imagen que use nuestra app a distintas resoluciones. Para simplificar el desarrollo, en iOS se consideran solo 3 resoluciones distintas, llamadas en la documentaci\u00f3n @1x , @2x y @3x . Como su propio nombre indica las dos \u00faltimas son m\u00faltiplos de la primera. Es decir que si tenemos una imagen de 100x100 pixeles como base, deber\u00edamos tener la misma a 200x200 para @2x y 300x300 para @3x . Evidentemente no se trata de que cojamos la misma imagen de 100x100 y la escalemos al doble o triple, ya que se ver\u00edan pixeladas, sino al contrario, que partamos de una imagen en alta resoluci\u00f3n y vayamos generando versiones m\u00e1s peque\u00f1as de la misma. En las \"Human Interface Guidelines\" de Apple tenemos m\u00e1s informaci\u00f3n sobre la resoluci\u00f3n de im\u00e1genes e iconos , adem\u00e1s de consejos de dise\u00f1o y usabilidad. En el mercado ya no quedan pr\u00e1cticamente dispositivos de resoluci\u00f3n @1x y de hecho no la necesitaremos salvo que queramos hacer compatible nuestra app con iOS9 o inferior.","title":"Resoluciones en dispositivos iOS"},{"location":"s2/recursos/#icono-de-la-aplicacion","text":"En el asset catalog hay un elemento denominado appIcon donde colocar el icono de la aplicaci\u00f3n. Debido a la diferente resoluci\u00f3n de los dispositivos iOS, como ya hemos visto, los iconos vienen en distintos tama\u00f1os, desde 120x120 para los iPhone a @2x hasta 180x180 a @3x. Otros tama\u00f1os adicionales se usan cuando nuestra app sale en los resultados de Spotlight (la b\u00fasqueda integrada en el dispositivo), si tiene su propio apartado de ajustes en los ajustes del sistema, cuando aparece en las notificaciones, etc. En total en la actualidad pueden hacer falta hasta 9 tama\u00f1os distintos de iconos. Afortunadamente desde la versi\u00f3n 14 de Xcode no es necesario que creemos nosotros todos los tama\u00f1os. Los proyectos est\u00e1n por defecto en modo \"Single size\", lo que quiere decir que si colocamos un icono a 1024x1024 Xcode generar\u00e1 todos los tama\u00f1os autom\u00e1ticamente. Si queremos crear los distintos tama\u00f1os de manera manual, en la parte derecha de la pantalla seleccionar\u00edamos el modo \"All sizes\". En modo manual, si no disponemos de alguno de los tama\u00f1os Xcode lo generar\u00e1 escalando los que haya. Si tenemos un Xcode<14, o queremos desplegar en iOS<12 no podremos usar la opc\u00edon de \"Single size\". Hay p\u00e1ginas web como https://appicon.co/ que pueden generar autom\u00e1ticamente todos los tama\u00f1os a partir de un icono dado. Si seleccionamos el appIcon veremos una plantilla donde \"dejar caer\" el icono 1024x1024 (en modo \"Single size\" o los iconos de cada tama\u00f1o necesario (en modo \"All sizes\"). Hay que tener en cuenta que deben estar en formato PNG sin transparencia. Para m\u00e1s informaci\u00f3n consultad el apartado correspondiente de las Human Interface Guidelines.","title":"Icono de la aplicaci\u00f3n"},{"location":"s2/recursos/#imagenes","text":"Como cada imagen deber\u00eda estar al menos en tama\u00f1o @2x y @3x , al a\u00f1adir una imagen a los recursos en realidad estamos a\u00f1adiendo un conjunto de im\u00e1genes o image set . Para crear un image set se puede pulsar el bot\u00f3n de + que aparece en la esquina inferior izquierda del editor del asset catalog y seleccionar New Image set . Por defecto se llamar\u00e1 simplemente Image pero podemos cambiarlo de nombre haciendo doble clic sobre el nombre actual. En el c\u00f3digo de la app podemos usar el nombre dado en el asset catalog para cargar la imagen: let imagenLibro = UIImage ( named : \"libro\" ) \"Truco\" : si las im\u00e1genes tienen un nombre que acaba en @2x o @3x (algo como libro@2x.png ), xCode las usar\u00e1 autom\u00e1ticamente para la resoluci\u00f3n deseada. Xcode tomar\u00e1 la de @1x simplemente como la que no tenga nada especial en el nombre. En el Finder (el administrador de archivos ) podemos seleccionar entonces tres im\u00e1genes juntas (haciendo clic + Cmd para que al seleccionar una no se pierda la anterior) y \"dejarlas caer\" juntas en el image set para que cada una se coloque en su hueco.","title":"Im\u00e1genes"},{"location":"s2/recursos/#launch-screen","text":"Es una pantalla que iOS mostrar\u00e1 al inicio de la carga de la app . En otros sistemas como Android o el mismo MacOS muchas aplicaciones tienen una splash screen , que aparece al comienzo con un logo, una imagen, los cr\u00e9ditos de la app , etc. Sin embargo seg\u00fan las Human Interface Guidelines de Apple una launch screen no es nada de eso, sino que debe ser lo m\u00e1s parecida posible a la primera pantalla de la app . De este modo se le dar\u00e1 la impresi\u00f3n al usuario de que la aplicaci\u00f3n se carga r\u00e1pidamente. Es decir, la launch screen es una especie de versi\u00f3n \"est\u00e1tica\" o \"de cart\u00f3n piedra\" (\ud83d\ude09) de la primera pantalla de la app . Evidentemente si la app muestra contenido din\u00e1mico este contenido no puede formar parte de la launch screen pero s\u00ed podemos por ejemplo colocar ciertos elementos est\u00e1ticos como botones, cuadros de b\u00fasqueda, tab bars , etc, como puede verse en este ejemplo incluido en la documentaci\u00f3n de Apple: En xCode la launch screen se dise\u00f1a como una pantalla m\u00e1s de la aplicaci\u00f3n, en el LaunchScreen.storyboard , arrastrando componentes de interfaz como en cualquier otra pantalla, aunque los elementos que se incluyan no van a ser interactivos. No se recomienda incluir textos ya que no van a poder adaptarse al idioma del dispositivo.","title":"Launch screen"},{"location":"s3/concurrencia/","text":"Concurrencia en iOS \u00b6 En muchas aplicaciones iOS necesitaremos efectuar varias operaciones de modo concurrente. El caso m\u00e1s t\u00edpico es cuando queremos hacer una operaci\u00f3n costosa en tiempo pero no queremos que se paralice la interfaz de usuario hasta que termine la operaci\u00f3n. APIs de concurrencia \u00b6 Tanto iOS como OSX tienen varios APIs con distinto nivel de abstracci\u00f3n para trabajar con operaciones concurrentes: En el nivel m\u00e1s bajo estar\u00eda trabajar directamente con threads , representados por la clase del sistema NSThread . La mayor\u00eda de aplicaciones no necesitan la flexibilidad que nos proporciona trabajar a este nivel, o no merece la pena teniendo en cuenta lo complicado del c\u00f3digo con respecto a las otras alternativas. En un nivel intermedio tenemos un framework de Apple llamado grand central dispatch o GCD. Tiene un nivel de abstracci\u00f3n razonable para la mayor\u00eda de aplicaciones, de hecho en Internet pod\u00e9is encontrar multitud de tutoriales y ejemplos que lo usan (pod\u00e9is verlo por la llamada a una funci\u00f3n llamada dispatch_async , que pone en marcha c\u00f3digo concurrente). En el nivel m\u00e1s alto de abstracci\u00f3n est\u00e1n las colas de operaciones (aunque no es mucho mayor que GCD). Es el API que vamos a usar aqu\u00ed ya que es el m\u00e1s sencillo de usar. Cada API usa internamente los otros de m\u00e1s bajo nivel. Es decir, GCD usa internamente threads y las colas de operaciones usan internamente GCD. Colas de operaciones \u00b6 En una cola de operaciones podemos a\u00f1adir trabajos concurrentes. Manejarlas a nivel b\u00e1sico es muy sencillo. Son instancias de OperationQueue y para a\u00f1adir un trabajo a una solo hay que llamar a addOperation() . Hay diversas formas de pasar el c\u00f3digo a ejecutar. La m\u00e1s c\u00f3moda es en forma de clausura . Por ejemplo: let cola = OperationQueue (); cola . addOperation () { print ( \"comienza operaci\u00f3n 1...\" ); sleep ( 5 ) print ( \"...hecho 1\" ); } cola . addOperation () { print ( \"comienza operacion 2...\" ) sleep ( 3 ) print ( \"...hecho 2\" ); }; NOTA: podemos ver el resultado del c\u00f3digo anterior a\u00f1adi\u00e9ndolo por ejemplo a una aplicaci\u00f3n iOS. Si usamos una aplicaci\u00f3n de l\u00ednea de comandos tendremos que a\u00f1adir algo al c\u00f3digo ya que si no el programa principal terminar\u00eda inmediatamente despu\u00e9s del segundo addOperation y no se ver\u00edan los mensajes en pantalla. Por ejemplo podemos llamar a cola.waitUntilAllOperationsAreFinished() que como su propio nombre indica se espera hasta que todas las operaciones a\u00f1adidas a la cola han terminado. Si ejecutamos el c\u00f3digo anterior veremos que aunque el c\u00f3digo de la primera clausura comienza a ejecutarse primero, aun as\u00ed termina despu\u00e9s, es decir, ambas \"tareas\" se est\u00e1n ejecutando en paralelo y no secuencialmente. Por defecto este es el comportamiento de las colas de operaciones, aunque podemos definir dependencias entre tareas, de modo que se ejecute una solo cuando ha acabado otra determinada. Incluso podemos limitar el n\u00famero de operaciones concurrentes que se pueden ejecutar en una cola. La cola de operaciones principal de una app \u00b6 En aplicaciones iOS est\u00e1 predefinida lo que se llama la \"cola de operaciones principal\", que es la que ejecuta el c\u00f3digo que actualiza la interfaz de usuario. Podemos acceder a ella con OperationQueue.main . Esta cola de operaciones no puede ejecutar operaciones concurrentes para evitar inconsistencias, que se podr\u00edan dar si dos tareas estuvieran modificando simult\u00e1neamente el mismo elemento de la interfaz. Podemos comprobar esto imprimiendo el valor de OperationQueue.main.maxConcurrentOperationCount , que veremos que vale 1, es decir, no hay operaciones concurrentes en esta cola. Cuando necesitamos ejecutar una operaci\u00f3n especialmente costosa en tiempo no es recomendable bloquear la interfaz de usuario, por lo que se suele crear una cola de operaciones aparte de la principal y ejecutar la operaci\u00f3n en esta. Un problema adicional es que normalmente esta operaci\u00f3n costosa debe actualizar la interfaz de usuario al finalizar, pero ning\u00fan hilo de ejecuci\u00f3n que no sea el principal debe actualizar la interfaz de usuario, ya que lo contrario podr\u00eda producir resultados inconsistentes. Esto lo podemos resolver accediendo a la cola de operaciones principal con OperationQueue.main . Por ejemplo: let background = OperationQueue (); background . addOperation () { print ( \"Comienzo mi duro trabajo...\" ) sleep ( 4 ) print ( \"...terminado!\" ) print ( \"pero yo NO DEBO tocar la interfaz\" ) OperationQueue . main . addOperation () { print ( \"Soy main. Desde aqu\u00ed s\u00ed se puede actualizar la interfaz\" ) } }","title":"Concurrencia"},{"location":"s3/concurrencia/#concurrencia-en-ios","text":"En muchas aplicaciones iOS necesitaremos efectuar varias operaciones de modo concurrente. El caso m\u00e1s t\u00edpico es cuando queremos hacer una operaci\u00f3n costosa en tiempo pero no queremos que se paralice la interfaz de usuario hasta que termine la operaci\u00f3n.","title":"Concurrencia en iOS"},{"location":"s3/concurrencia/#apis-de-concurrencia","text":"Tanto iOS como OSX tienen varios APIs con distinto nivel de abstracci\u00f3n para trabajar con operaciones concurrentes: En el nivel m\u00e1s bajo estar\u00eda trabajar directamente con threads , representados por la clase del sistema NSThread . La mayor\u00eda de aplicaciones no necesitan la flexibilidad que nos proporciona trabajar a este nivel, o no merece la pena teniendo en cuenta lo complicado del c\u00f3digo con respecto a las otras alternativas. En un nivel intermedio tenemos un framework de Apple llamado grand central dispatch o GCD. Tiene un nivel de abstracci\u00f3n razonable para la mayor\u00eda de aplicaciones, de hecho en Internet pod\u00e9is encontrar multitud de tutoriales y ejemplos que lo usan (pod\u00e9is verlo por la llamada a una funci\u00f3n llamada dispatch_async , que pone en marcha c\u00f3digo concurrente). En el nivel m\u00e1s alto de abstracci\u00f3n est\u00e1n las colas de operaciones (aunque no es mucho mayor que GCD). Es el API que vamos a usar aqu\u00ed ya que es el m\u00e1s sencillo de usar. Cada API usa internamente los otros de m\u00e1s bajo nivel. Es decir, GCD usa internamente threads y las colas de operaciones usan internamente GCD.","title":"APIs de concurrencia"},{"location":"s3/concurrencia/#colas-de-operaciones","text":"En una cola de operaciones podemos a\u00f1adir trabajos concurrentes. Manejarlas a nivel b\u00e1sico es muy sencillo. Son instancias de OperationQueue y para a\u00f1adir un trabajo a una solo hay que llamar a addOperation() . Hay diversas formas de pasar el c\u00f3digo a ejecutar. La m\u00e1s c\u00f3moda es en forma de clausura . Por ejemplo: let cola = OperationQueue (); cola . addOperation () { print ( \"comienza operaci\u00f3n 1...\" ); sleep ( 5 ) print ( \"...hecho 1\" ); } cola . addOperation () { print ( \"comienza operacion 2...\" ) sleep ( 3 ) print ( \"...hecho 2\" ); }; NOTA: podemos ver el resultado del c\u00f3digo anterior a\u00f1adi\u00e9ndolo por ejemplo a una aplicaci\u00f3n iOS. Si usamos una aplicaci\u00f3n de l\u00ednea de comandos tendremos que a\u00f1adir algo al c\u00f3digo ya que si no el programa principal terminar\u00eda inmediatamente despu\u00e9s del segundo addOperation y no se ver\u00edan los mensajes en pantalla. Por ejemplo podemos llamar a cola.waitUntilAllOperationsAreFinished() que como su propio nombre indica se espera hasta que todas las operaciones a\u00f1adidas a la cola han terminado. Si ejecutamos el c\u00f3digo anterior veremos que aunque el c\u00f3digo de la primera clausura comienza a ejecutarse primero, aun as\u00ed termina despu\u00e9s, es decir, ambas \"tareas\" se est\u00e1n ejecutando en paralelo y no secuencialmente. Por defecto este es el comportamiento de las colas de operaciones, aunque podemos definir dependencias entre tareas, de modo que se ejecute una solo cuando ha acabado otra determinada. Incluso podemos limitar el n\u00famero de operaciones concurrentes que se pueden ejecutar en una cola.","title":"Colas de operaciones"},{"location":"s3/concurrencia/#la-cola-de-operaciones-principal-de-una-app","text":"En aplicaciones iOS est\u00e1 predefinida lo que se llama la \"cola de operaciones principal\", que es la que ejecuta el c\u00f3digo que actualiza la interfaz de usuario. Podemos acceder a ella con OperationQueue.main . Esta cola de operaciones no puede ejecutar operaciones concurrentes para evitar inconsistencias, que se podr\u00edan dar si dos tareas estuvieran modificando simult\u00e1neamente el mismo elemento de la interfaz. Podemos comprobar esto imprimiendo el valor de OperationQueue.main.maxConcurrentOperationCount , que veremos que vale 1, es decir, no hay operaciones concurrentes en esta cola. Cuando necesitamos ejecutar una operaci\u00f3n especialmente costosa en tiempo no es recomendable bloquear la interfaz de usuario, por lo que se suele crear una cola de operaciones aparte de la principal y ejecutar la operaci\u00f3n en esta. Un problema adicional es que normalmente esta operaci\u00f3n costosa debe actualizar la interfaz de usuario al finalizar, pero ning\u00fan hilo de ejecuci\u00f3n que no sea el principal debe actualizar la interfaz de usuario, ya que lo contrario podr\u00eda producir resultados inconsistentes. Esto lo podemos resolver accediendo a la cola de operaciones principal con OperationQueue.main . Por ejemplo: let background = OperationQueue (); background . addOperation () { print ( \"Comienzo mi duro trabajo...\" ) sleep ( 4 ) print ( \"...terminado!\" ) print ( \"pero yo NO DEBO tocar la interfaz\" ) OperationQueue . main . addOperation () { print ( \"Soy main. Desde aqu\u00ed s\u00ed se puede actualizar la interfaz\" ) } }","title":"La cola de operaciones principal de una app"},{"location":"s3/intro_swift_2/","text":"M\u00e1s sobre Swift \u00b6 Clausuras \u00b6 Una clausura es un bloque de c\u00f3digo que puede ser tratado como un objeto . Es algo as\u00ed como una funci\u00f3n an\u00f3nima con una sintaxis simplificada. A muchos m\u00e9todos de las bibliotecas del sistema se les pasa una funci\u00f3n para hacer su tarea. En lugar de eso se puede usar una clausura, lo que simplifica la sintaxis. Veamos un ejemplo. El m\u00e9todo sorted ordena un array. Debemos pasarle una funci\u00f3n que, dados dos datos, devuelva true si est\u00e1n ya \"en el orden correcto\". Podemos hacerlo as\u00ed: func ascendente ( a : String , b : String )-> Bool { return a < b ; } let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : ascendente ) La funci\u00f3n ascendente se puede definir en forma de clausura como: {( a : String , b : String )-> Bool in return a < b } Con clausuras definimos el c\u00f3digo donde lo necesitamos , no aparte, quedando m\u00e1s legible let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : {( a : String , b : String )-> Bool in return a < b }) ord Simplificando la definici\u00f3n \u00b6 Podemos acortar todav\u00eda m\u00e1s la sintaxis de definici\u00f3n de las clausuras: Inferencia de tipos : en ocasiones el compilador puede inferir la signatura (tipos de par\u00e1metros y tipo de retorno), como en nuestro ejemplo, ya que a sorted se le debe pasar una funci\u00f3n con dos par\u00e1metros String y que debe devolver un Bool . Tambi\u00e9n podemos omitir los par\u00e9ntesis y la flecha let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in return a < b })) return impl\u00edcito : si la clausura solo contiene una expresi\u00f3n se asume que devuelve su resultado let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in a < b })) Par\u00e1metros por defecto por defecto los par\u00e1metros reciben como nombre $i donde i es el n\u00famero (empieza en 0) let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted ( by : { $0 < $1 }) Trailing closures : si una clausura es el \u00faltimo par\u00e1metro de un m\u00e9todo, se puede omitir su nombre y poner fuera de los par\u00e9ntesis. Esto de por s\u00ed no acorta la sintaxis, pero facilita la legibilidad si el c\u00f3digo de la clausura ocupa varias l\u00edneas let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted () { a , b in return a < b } Estructuras \u00b6 En Swift tambi\u00e9n existen struct s. En lenguajes como C++, clases y structs son completamente diferentes. En swift se parecen mucho: Ambas pueden contener propiedades y m\u00e9todos Definen inicializadores (== constructores ) Se instancian de forma muy parecida Se pueden definir como conformes a protocolos (parecidos a interfaces de Java) struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) print ( p1 . descripcion ) Como vemos, en el c\u00f3digo anterior no hemos definido ning\u00fan inicializador y sin embargo lo hemos llamado para construir un Libro . En structs el compilador define autom\u00e1ticamente un inicializador (llamado memberwise initializer ) que acepta las variables miembro como par\u00e1metros. Sin embargo, hay funcionalidades que tienen las clases pero no las estructuras: Herencia Deinicializadores (== destructores) Varias variables pueden referenciar a la misma instancia. Es decir, como ahora veremos, los objetos se pasan por referencia y las estructuras por valor. Valor vs. referencia \u00b6 Las estructuras se pasan por valor y los objetos por referencia. Eso quiere decir que si asignamos una estructura a otra variable o la pasamos como par\u00e1metro de una funci\u00f3n estamos haciendo una copia , pero si asignamos objetos, son punteros que apuntan en realidad al mismo objeto . Por ejemplo con estructuras struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) var p2 = p1 p1 . x = - 1.0 ; print ( p2 . descripcion ) //cambiar p1 no cambia el valor de p2 Si Punto2D pasara de ser una estructura a una clase, pasar\u00edan dos cosas: Ya no tendr\u00edamos autom\u00e1ticamente definido el memberwise initializer Al asignar o pasar como par\u00e1metro estar\u00edamos referenciando la misma instancia . class Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D () p1 . x = 1 p1 . y = 0 var p2 = p1 //ahora p1 y p2 apuntan A LA MISMA INSTANCIA p1 . x = - 1.0 ; print ( p2 . descripcion ) //(-1.0, 0.0) Escoger estructuras vs. clases \u00b6 Se recomienda usar estructuras cuando se cumplan estas condiciones: La finalidad principal es simplemente encapsular unos cuantos datos La copia por valor no va a causar problemas Las propiedades de la estructura son tambi\u00e9n valores y no referencias (o sea, la estructura no contiene objetos) No necesitamos herencia En Swift, muchos tipos de la librer\u00eda est\u00e1ndar como los String , los arrays y los diccionarios se implementan como estructuras , de modo que se pasan por valor y no por referencia. Gesti\u00f3n de errores \u00b6 En Swift representamos un error con cualquier elemento que sea conforme al protocolo Error . Los enums son especialmente apropiados para representar errores enum ErrorImpresora : Error { case sinPapel case sinTinta ( color : String ) case enLLamas } NOTA: ya veremos qu\u00e9 son los protocolos, por el momento basta con saber que son como los interfaces en Java Para se\u00f1alar que se ha producido un error, lo lanzamos con throw throw ErrorImpresora . sinTinta ( color : \"Rojo\" ) Ante un error tenemos cuatro opciones: Propagarlo \"hacia arriba\" Capturarlo con un do..catch Manejarlo como un opcional Suponer que todo va a ir bien Propagar errores \u00b6 Podemos indicar que una funci\u00f3n/m\u00e9todo lanza errores marc\u00e1ndola con throws . El error llegar\u00e1 a la funci\u00f3n/m\u00e9todo que haya llamado a esta, que a su vez podr\u00eda propagarlo hacia arriba. N\u00f3tese que si llamamos a un m\u00e9todo marcado con throws debemos preceder la llamada de la palabra clave try Veamos un ejemplo, suponiendo el enum ErrorImpresora definido antes class Impresora { var temperatura = 0.0 //Marcado con \"throws\" porque lanza un error \"hacia arriba\" func verificarEstado () throws -> String { if self . temperatura > 80 { throw ErrorImpresora . enLlamas } else return \"OK\" } } //Lanza un error \"hacia arriba\" func miFuncion () throws { var miImpresora = Impresora () miImpresora . temperatura = 100 //Para llamar a un m\u00e9todo marcado con \"throws\" tenemos que usar \"try\" try miImpresora . verificarEstado () } try miFuncion () En el ejemplo anterior, el error acaba subiendo hasta el nivel superior y el programa abortar\u00eda. Capturar errores \u00b6 Podemos capturar un error envolviendo la llamada a los m\u00e9todos que los lanzan en un bloque do...catch , que es muy similar al try...catch de Java o de otros lenguajes do { var miImpresora = Impresora () miImpresora . temperatura = 100 try miImpresora . verificarEstado () } catch ErrorImpresora . enLlamas { print ( \"SOCORROOOOOOOO!!!\" ) } Manejar un error como opcional \u00b6 En lugar de usar try en la llamada a un m\u00e9todo que puede generar un error podemos emplear la \"variante\" try? . Lo que hace esta forma es capturar el error y transformar el resultado del m\u00e9todo en un opcional, que podemos tratar con el patr\u00f3n habitual if let ... . Si ha habido un error el m\u00e9todo nos devolver\u00e1 nil var miImpresora = Impresora () miImpresora . temperatura = 100 if let estado = try ? miImpresora . verificarEstado () { print ( \"Perfecto. El estado es \\( estado ) \" ) } else { print ( \"Ha habido un error\" ) } Ignorar los errores \u00b6 Podemos usar la \"variante\" try! cuando no queremos gestionar el error porque es cr\u00edtico y si se da no tiene sentido continuar con el programa. Si el error se produjera se lanzar\u00eda inmediatamente una excepci\u00f3n en tiempo de ejecuci\u00f3n y el programa abortar\u00eda. Protocolos \u00b6 El concepto de protocolo en Swift es similar al de interface en Java. Un protocolo es una plantilla de m\u00e9todos, propiedades y otros requisitos que definen una tarea o funcionalidad particular. Un protocolo no proporciona ninguna implementaci\u00f3n, sino que debe ser adoptado por una clase, un struct o una enumeraci\u00f3n. Un protocolo proporciona un tipo y se puede usar en muchos sitios donde se permiten usar tipos: - Como el tipo de un par\u00e1metro o de un valor devuelto por una funci\u00f3n, un m\u00e9todo o un inicializador. - Como el tipo de una constante, variable o propiedad. - Como el tipo de los \u00edtems de un array, diccionario u otros contenedores. Los protocolos se declaran con la palabra clave protocol . Dentro del protocolo especificamos las signaturas de los m\u00e9todos y si las propiedades computadas son de lectura y/o escritura. Si un m\u00e9todo modifica alguna propiedad del objeto debemos indicarlo con mutating protocol ProtocoloEjemplo { func saludar ()-> String //Propiedad calculada: debemos decir si es gettable y/o settable var descripcion : String { get set } //si la funci\u00f3n muta alg\u00fan dato, debemos especificarlo mutating func reggaetonizar () } Para indicar que una clase adopta un protocolo usamos la misma notaci\u00f3n que con la herencia class MiClase : ProtocoloEjemplo { var descripcion = \"Mi Clase\" func saludar ()-> String { return \"Hola soy \" + self . descripcion } func reggaetonizar () { self . descripcion += \" ya t\u00fa sabes\" } } let mc = MiClase () mc . reggaetonizar () mc . saludar () //Hola, soy Mi Clase ya t\u00fa sabes Al igual que en Java una clase solo puede heredar de una superclase, pero puede implementar uno o varios protocolos. En la primera l\u00ednea de la clase, donde indicamos herencia-protocolos, hay que poner la superclase antes que los protocolos para evitar ambig\u00fcedades class MiOtraClase : Superclase , ProtocoloUno , ProtocoloDos { //Definici\u00f3n de la clase } El patr\u00f3n de dise\u00f1o \"delegaci\u00f3n\" \u00b6 Delegaci\u00f3n es un patr\u00f3n de dise\u00f1o que permite a una clase o estructura pasar (o delegar ) alguna de sus responsabilidades a una instancia de otro tipo. Este patr\u00f3n est\u00e1 relacionado con la idea de composici\u00f3n : cuando queremos que un objeto realice una tarea incluimos en \u00e9l otro objeto capaz de realizarla. Este patr\u00f3n es uno de los m\u00e1s comunes en los frameworks del sistema en iOS/OSX, ya que permite que las clases del sistema hagan su trabajo apoy\u00e1ndose en c\u00f3digo proporcionado por el programador. La idea es que la clase del sistema contendr\u00e1 una referencia a un objeto proporcionado por el desarrollador y que implementa una serie de funcionalidades. Para que el compilador pueda chequear que efectivamente las implementa, este objeto debe adoptar un determinado protocolo. Por ejemplo, como veremos en la asignatura de interfaz de usuario, las tablas en iOS se implementan habitualmente con la clase del sistema UITableView . N\u00f3tese que cuando en iOS hablamos de tablas en realidad estamos hablando de listas de datos (o visto de otro modo, tablas de una \u00fanica columna), que son omnipresentes en las interfaces de usuario de apps m\u00f3viles. UITableView necesariamente es una clase gen\u00e9rica. Pero se tiene que \"adaptar\" a los datos concretos que queremos mostrar. Lo que se hace en iOS es usar el patr\u00f3n delegaci\u00f3n. Un UITableView tiene una propiedad delegate que debe ser un objeto que adopte el protocolo UITableViewDelegate . Este protocolo incluye por ejemplo un m\u00e9todo que devuelve el contenido de una fila sabiendo su n\u00famero. De este modo, cuando iOS quiere dibujar la tabla en pantalla lo que va haciendo es \"pidi\u00e9ndole\" las filas una por una al delegate . Una alternativa que podr\u00eda haber adoptado Apple es hacer que el desarrollador creara una clase que heredara de UITableView y que tuviera que implementar en ella los m\u00e9todos apropiados, pero esta alternativa es m\u00e1s problem\u00e1tica, ya que como sabemos una clase solo puede heredar de otra, y si tuvi\u00e9ramos que heredar de UITableView para tener esta funcionalidad ya no podr\u00edamos heredar de otra clase. Este patr\u00f3n no se usa \u00fanicamente con tablas sino que est\u00e1 \"por todas partes\" en los frameworks del sistema en iOS. Ya vimos por ejemplo el ApplicationDelegate cuando creamos nuestra primera aplicaci\u00f3n, pero hay muchos m\u00e1s ejemplos.","title":"M\u00e1s sobre Swift"},{"location":"s3/intro_swift_2/#mas-sobre-swift","text":"","title":"M\u00e1s sobre Swift"},{"location":"s3/intro_swift_2/#clausuras","text":"Una clausura es un bloque de c\u00f3digo que puede ser tratado como un objeto . Es algo as\u00ed como una funci\u00f3n an\u00f3nima con una sintaxis simplificada. A muchos m\u00e9todos de las bibliotecas del sistema se les pasa una funci\u00f3n para hacer su tarea. En lugar de eso se puede usar una clausura, lo que simplifica la sintaxis. Veamos un ejemplo. El m\u00e9todo sorted ordena un array. Debemos pasarle una funci\u00f3n que, dados dos datos, devuelva true si est\u00e1n ya \"en el orden correcto\". Podemos hacerlo as\u00ed: func ascendente ( a : String , b : String )-> Bool { return a < b ; } let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : ascendente ) La funci\u00f3n ascendente se puede definir en forma de clausura como: {( a : String , b : String )-> Bool in return a < b } Con clausuras definimos el c\u00f3digo donde lo necesitamos , no aparte, quedando m\u00e1s legible let nombres = [ \"James\" , \"Billy\" , \"D'Arcy\" , \"Jimmy\" ] let ord = nombres . sorted ( by : {( a : String , b : String )-> Bool in return a < b }) ord","title":"Clausuras"},{"location":"s3/intro_swift_2/#simplificando-la-definicion","text":"Podemos acortar todav\u00eda m\u00e1s la sintaxis de definici\u00f3n de las clausuras: Inferencia de tipos : en ocasiones el compilador puede inferir la signatura (tipos de par\u00e1metros y tipo de retorno), como en nuestro ejemplo, ya que a sorted se le debe pasar una funci\u00f3n con dos par\u00e1metros String y que debe devolver un Bool . Tambi\u00e9n podemos omitir los par\u00e9ntesis y la flecha let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in return a < b })) return impl\u00edcito : si la clausura solo contiene una expresi\u00f3n se asume que devuelve su resultado let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] print ( nombres . sorted ( by : { a , b in a < b })) Par\u00e1metros por defecto por defecto los par\u00e1metros reciben como nombre $i donde i es el n\u00famero (empieza en 0) let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted ( by : { $0 < $1 }) Trailing closures : si una clausura es el \u00faltimo par\u00e1metro de un m\u00e9todo, se puede omitir su nombre y poner fuera de los par\u00e9ntesis. Esto de por s\u00ed no acorta la sintaxis, pero facilita la legibilidad si el c\u00f3digo de la clausura ocupa varias l\u00edneas let nombres = [ \"Pepe\" , \"Eva\" , \"Luis\" ] let ord = nombres . sorted () { a , b in return a < b }","title":"Simplificando la definici\u00f3n"},{"location":"s3/intro_swift_2/#estructuras","text":"En Swift tambi\u00e9n existen struct s. En lenguajes como C++, clases y structs son completamente diferentes. En swift se parecen mucho: Ambas pueden contener propiedades y m\u00e9todos Definen inicializadores (== constructores ) Se instancian de forma muy parecida Se pueden definir como conformes a protocolos (parecidos a interfaces de Java) struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) print ( p1 . descripcion ) Como vemos, en el c\u00f3digo anterior no hemos definido ning\u00fan inicializador y sin embargo lo hemos llamado para construir un Libro . En structs el compilador define autom\u00e1ticamente un inicializador (llamado memberwise initializer ) que acepta las variables miembro como par\u00e1metros. Sin embargo, hay funcionalidades que tienen las clases pero no las estructuras: Herencia Deinicializadores (== destructores) Varias variables pueden referenciar a la misma instancia. Es decir, como ahora veremos, los objetos se pasan por referencia y las estructuras por valor.","title":"Estructuras"},{"location":"s3/intro_swift_2/#valor-vs-referencia","text":"Las estructuras se pasan por valor y los objetos por referencia. Eso quiere decir que si asignamos una estructura a otra variable o la pasamos como par\u00e1metro de una funci\u00f3n estamos haciendo una copia , pero si asignamos objetos, son punteros que apuntan en realidad al mismo objeto . Por ejemplo con estructuras struct Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D ( x : 1.0 , y : 0.0 ) var p2 = p1 p1 . x = - 1.0 ; print ( p2 . descripcion ) //cambiar p1 no cambia el valor de p2 Si Punto2D pasara de ser una estructura a una clase, pasar\u00edan dos cosas: Ya no tendr\u00edamos autom\u00e1ticamente definido el memberwise initializer Al asignar o pasar como par\u00e1metro estar\u00edamos referenciando la misma instancia . class Punto2D { var x , y : Double var descripcion : String { return \"( \\( x ) , \\( y ) )\" } } var p1 = Punto2D () p1 . x = 1 p1 . y = 0 var p2 = p1 //ahora p1 y p2 apuntan A LA MISMA INSTANCIA p1 . x = - 1.0 ; print ( p2 . descripcion ) //(-1.0, 0.0)","title":"Valor vs. referencia"},{"location":"s3/intro_swift_2/#escoger-estructuras-vs-clases","text":"Se recomienda usar estructuras cuando se cumplan estas condiciones: La finalidad principal es simplemente encapsular unos cuantos datos La copia por valor no va a causar problemas Las propiedades de la estructura son tambi\u00e9n valores y no referencias (o sea, la estructura no contiene objetos) No necesitamos herencia En Swift, muchos tipos de la librer\u00eda est\u00e1ndar como los String , los arrays y los diccionarios se implementan como estructuras , de modo que se pasan por valor y no por referencia.","title":"Escoger estructuras vs. clases"},{"location":"s3/intro_swift_2/#gestion-de-errores","text":"En Swift representamos un error con cualquier elemento que sea conforme al protocolo Error . Los enums son especialmente apropiados para representar errores enum ErrorImpresora : Error { case sinPapel case sinTinta ( color : String ) case enLLamas } NOTA: ya veremos qu\u00e9 son los protocolos, por el momento basta con saber que son como los interfaces en Java Para se\u00f1alar que se ha producido un error, lo lanzamos con throw throw ErrorImpresora . sinTinta ( color : \"Rojo\" ) Ante un error tenemos cuatro opciones: Propagarlo \"hacia arriba\" Capturarlo con un do..catch Manejarlo como un opcional Suponer que todo va a ir bien","title":"Gesti\u00f3n de errores"},{"location":"s3/intro_swift_2/#propagar-errores","text":"Podemos indicar que una funci\u00f3n/m\u00e9todo lanza errores marc\u00e1ndola con throws . El error llegar\u00e1 a la funci\u00f3n/m\u00e9todo que haya llamado a esta, que a su vez podr\u00eda propagarlo hacia arriba. N\u00f3tese que si llamamos a un m\u00e9todo marcado con throws debemos preceder la llamada de la palabra clave try Veamos un ejemplo, suponiendo el enum ErrorImpresora definido antes class Impresora { var temperatura = 0.0 //Marcado con \"throws\" porque lanza un error \"hacia arriba\" func verificarEstado () throws -> String { if self . temperatura > 80 { throw ErrorImpresora . enLlamas } else return \"OK\" } } //Lanza un error \"hacia arriba\" func miFuncion () throws { var miImpresora = Impresora () miImpresora . temperatura = 100 //Para llamar a un m\u00e9todo marcado con \"throws\" tenemos que usar \"try\" try miImpresora . verificarEstado () } try miFuncion () En el ejemplo anterior, el error acaba subiendo hasta el nivel superior y el programa abortar\u00eda.","title":"Propagar errores"},{"location":"s3/intro_swift_2/#capturar-errores","text":"Podemos capturar un error envolviendo la llamada a los m\u00e9todos que los lanzan en un bloque do...catch , que es muy similar al try...catch de Java o de otros lenguajes do { var miImpresora = Impresora () miImpresora . temperatura = 100 try miImpresora . verificarEstado () } catch ErrorImpresora . enLlamas { print ( \"SOCORROOOOOOOO!!!\" ) }","title":"Capturar errores"},{"location":"s3/intro_swift_2/#manejar-un-error-como-opcional","text":"En lugar de usar try en la llamada a un m\u00e9todo que puede generar un error podemos emplear la \"variante\" try? . Lo que hace esta forma es capturar el error y transformar el resultado del m\u00e9todo en un opcional, que podemos tratar con el patr\u00f3n habitual if let ... . Si ha habido un error el m\u00e9todo nos devolver\u00e1 nil var miImpresora = Impresora () miImpresora . temperatura = 100 if let estado = try ? miImpresora . verificarEstado () { print ( \"Perfecto. El estado es \\( estado ) \" ) } else { print ( \"Ha habido un error\" ) }","title":"Manejar un error como opcional"},{"location":"s3/intro_swift_2/#ignorar-los-errores","text":"Podemos usar la \"variante\" try! cuando no queremos gestionar el error porque es cr\u00edtico y si se da no tiene sentido continuar con el programa. Si el error se produjera se lanzar\u00eda inmediatamente una excepci\u00f3n en tiempo de ejecuci\u00f3n y el programa abortar\u00eda.","title":"Ignorar los errores"},{"location":"s3/intro_swift_2/#protocolos","text":"El concepto de protocolo en Swift es similar al de interface en Java. Un protocolo es una plantilla de m\u00e9todos, propiedades y otros requisitos que definen una tarea o funcionalidad particular. Un protocolo no proporciona ninguna implementaci\u00f3n, sino que debe ser adoptado por una clase, un struct o una enumeraci\u00f3n. Un protocolo proporciona un tipo y se puede usar en muchos sitios donde se permiten usar tipos: - Como el tipo de un par\u00e1metro o de un valor devuelto por una funci\u00f3n, un m\u00e9todo o un inicializador. - Como el tipo de una constante, variable o propiedad. - Como el tipo de los \u00edtems de un array, diccionario u otros contenedores. Los protocolos se declaran con la palabra clave protocol . Dentro del protocolo especificamos las signaturas de los m\u00e9todos y si las propiedades computadas son de lectura y/o escritura. Si un m\u00e9todo modifica alguna propiedad del objeto debemos indicarlo con mutating protocol ProtocoloEjemplo { func saludar ()-> String //Propiedad calculada: debemos decir si es gettable y/o settable var descripcion : String { get set } //si la funci\u00f3n muta alg\u00fan dato, debemos especificarlo mutating func reggaetonizar () } Para indicar que una clase adopta un protocolo usamos la misma notaci\u00f3n que con la herencia class MiClase : ProtocoloEjemplo { var descripcion = \"Mi Clase\" func saludar ()-> String { return \"Hola soy \" + self . descripcion } func reggaetonizar () { self . descripcion += \" ya t\u00fa sabes\" } } let mc = MiClase () mc . reggaetonizar () mc . saludar () //Hola, soy Mi Clase ya t\u00fa sabes Al igual que en Java una clase solo puede heredar de una superclase, pero puede implementar uno o varios protocolos. En la primera l\u00ednea de la clase, donde indicamos herencia-protocolos, hay que poner la superclase antes que los protocolos para evitar ambig\u00fcedades class MiOtraClase : Superclase , ProtocoloUno , ProtocoloDos { //Definici\u00f3n de la clase }","title":"Protocolos"},{"location":"s3/intro_swift_2/#el-patron-de-diseno-delegacion","text":"Delegaci\u00f3n es un patr\u00f3n de dise\u00f1o que permite a una clase o estructura pasar (o delegar ) alguna de sus responsabilidades a una instancia de otro tipo. Este patr\u00f3n est\u00e1 relacionado con la idea de composici\u00f3n : cuando queremos que un objeto realice una tarea incluimos en \u00e9l otro objeto capaz de realizarla. Este patr\u00f3n es uno de los m\u00e1s comunes en los frameworks del sistema en iOS/OSX, ya que permite que las clases del sistema hagan su trabajo apoy\u00e1ndose en c\u00f3digo proporcionado por el programador. La idea es que la clase del sistema contendr\u00e1 una referencia a un objeto proporcionado por el desarrollador y que implementa una serie de funcionalidades. Para que el compilador pueda chequear que efectivamente las implementa, este objeto debe adoptar un determinado protocolo. Por ejemplo, como veremos en la asignatura de interfaz de usuario, las tablas en iOS se implementan habitualmente con la clase del sistema UITableView . N\u00f3tese que cuando en iOS hablamos de tablas en realidad estamos hablando de listas de datos (o visto de otro modo, tablas de una \u00fanica columna), que son omnipresentes en las interfaces de usuario de apps m\u00f3viles. UITableView necesariamente es una clase gen\u00e9rica. Pero se tiene que \"adaptar\" a los datos concretos que queremos mostrar. Lo que se hace en iOS es usar el patr\u00f3n delegaci\u00f3n. Un UITableView tiene una propiedad delegate que debe ser un objeto que adopte el protocolo UITableViewDelegate . Este protocolo incluye por ejemplo un m\u00e9todo que devuelve el contenido de una fila sabiendo su n\u00famero. De este modo, cuando iOS quiere dibujar la tabla en pantalla lo que va haciendo es \"pidi\u00e9ndole\" las filas una por una al delegate . Una alternativa que podr\u00eda haber adoptado Apple es hacer que el desarrollador creara una clase que heredara de UITableView y que tuviera que implementar en ella los m\u00e9todos apropiados, pero esta alternativa es m\u00e1s problem\u00e1tica, ya que como sabemos una clase solo puede heredar de otra, y si tuvi\u00e9ramos que heredar de UITableView para tener esta funcionalidad ya no podr\u00edamos heredar de otra clase. Este patr\u00f3n no se usa \u00fanicamente con tablas sino que est\u00e1 \"por todas partes\" en los frameworks del sistema en iOS. Ya vimos por ejemplo el ApplicationDelegate cuando creamos nuestra primera aplicaci\u00f3n, pero hay muchos m\u00e1s ejemplos.","title":"El patr\u00f3n de dise\u00f1o \"delegaci\u00f3n\""},{"location":"s4/comunicacion/","text":"Comunicaci\u00f3n modelo-controlador \u00b6 Ya hemos visto c\u00f3mo se comunican bidireccionalmente el controlador y la vista: Cuando la vista genera un evento (como por ejemplo un tap en un bot\u00f3n) llama a un m\u00e9todo del controlador (un action ) El controlador puede acceder al estado actual de ciertos elementos de la vista y manipularlo a trav\u00e9s de los outlet . Tambi\u00e9n hemos visto que el controlador mantiene una referencia a las clases del modelo y que as\u00ed podemos llamar a la l\u00f3gica de negocio, pero nos falta la otra direcci\u00f3n: c\u00f3mo avisa el modelo al controlador de que se ha producido un evento importante. Por ejemplo supongamos una aplicaci\u00f3n de mensajer\u00eda en la que las clases del modelo reciben un nuevo mensaje, y hay que pas\u00e1rselo al controlador para que \u00e9ste lo muestre en la vista. Una opci\u00f3n para comunicar eventos del modelo al controlador ser\u00eda que el primero mantuviera una referencia al segundo y as\u00ed pudiera llamar a cierto m\u00e9todo o m\u00e9todos. Pero esto acoplar\u00eda el c\u00f3digo del modelo al controlador, y no nos permitir\u00eda reutilizar el modelo o partes sgnificativas de \u00e9l en otras aplicaciones, o \"protegerlo\" de posibles cambios en el controlador. Vamos a ver aqu\u00ed m\u00e9todos \"no invasivos\" para que el modelo comunique con el controlador, sin necesidad de acoplar el c\u00f3digo de ambos. Es inevitable que controlador tenga conocimiento del modelo, pero como vamos a ver no es inevitable que el modelo tenga conocimiento del controlador. En Foundation hay dos formas b\u00e1sicas de conseguir que dos objetos se comuniquen acoplando el c\u00f3digo de ambos lo menos posible: Notificaciones: un objeto puede recibir notificaciones sobre eventos que le interesen. As\u00edmismo otro objeto puede enviar notificaciones. El encargado de gestionar las notificaciones es un objeto intermediario denominado \"centro de notificaciones\". Podemos usar las notificaciones de modo que el modelo notifique que ha habido un cambio y el controlador reciba la notificaci\u00f3n y actualice la vista. Key-Value observing o KVO: un objeto puede \"vigilar\" el cambio en el valor de las propiedades de otro. Cuando se produzca un cambio, se llamar\u00e1 a una funci\u00f3n o clausura que act\u00faa de callback . Podemos usar este mecanismo para hacer que el controlador observe las propiedades del modelo que nos interesa actualizar din\u00e1micamente en la vista. Notificaciones locales \u00b6 Son algo similar a lo que en aplicaciones enterprise se llaman colas de mensajes . Implementan el patr\u00f3n de dise\u00f1o publicar/suscribir. Cuando un objeto quiere avisar al resto del sistema, publica una notificaci\u00f3n asign\u00e1ndole un nombre, y opcionalmente un payload (datos asociados). Los objetos que quieren recibir la notificaci\u00f3n indican el nombre de la que le interesa, y qu\u00e9 m\u00e9todo o clausura ejecutar cuando se reciba. El encargado de gestionar las notificaciones es el NotificationCenter . Hay uno por defecto ya inicializado en cada aplicaci\u00f3n ( NotificationCenter.default ). Se pueden crear m\u00e1s, pero en la mayor\u00eda de aplicaciones nos bastar\u00e1 con uno. A este centro de notificaciones es a quien le decimos que env\u00ede las notificaciones (publicar) o que queremos recibir las de un determinado tipo (suscribir). import Foundation class Emisor { func enviar ( mensaje : String ) { //Obtenemos el centro de notificaciones por defecto //Las notificaciones tienen un nombre, un objeto que las env\u00eda (si lo ponemos a nil no queda constancia de qui\u00e9n) y datos adicionales, un diccionario con los datos que queramos let nc = NotificationCenter . default nc . post ( name : Notification . Name ( \"saludo\" ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : mensaje ]) } } class Receptor { func suscribirse () { let nc = NotificationCenter . default //primer par\u00e1metro: a\u00f1adimos como observador a nosotros (self) //selector: al recibir la notificaci\u00f3n se llama al m\u00e9todo recibir //name: nombre de la notificaci\u00f3n que nos interesa //object: objeto del que nos interesa recibir notificaciones. nil == cualquiera nc . addObserver ( self , selector : #selector ( self . recibir ), name : Notification . Name ( \"saludo\" ), object : nil ) } @objc func recibir ( notificacion : Notification ) { print ( \"recibido!!\" ) if let userInfo = notificacion . userInfo { let mensaje = userInfo [ \"mensaje\" ] as ! String print ( \"dice: \\( mensaje ) \" ) } } } var e = Emisor () var r = Receptor () r . suscribirse () e . enviar ( mensaje : \"holaaaa\" ) El nombre de la notificaci\u00f3n no es exactamente un String, sino un Notification.Name construido a partir de un String. Para que el c\u00f3digo sea m\u00e1s seguro y menos propenso a errores podemos extender esta clase con constantes y usar estas constantes en lugar de directamente los Strings. Siguiendo con el ejemplo, har\u00edamos algo como: //En el archivo que queramos //Alguna gente usa convenciones del tipo \"NotificationName+Extensions.swift\" extension Notification . Name { static let saludo = Notification . Name ( \"saludo\" ) } y ahora cuando queramos referenciar un Notification.name lo hacemos como Notification.name.saludo o mejor a\u00fan, simplemente .saludo como en los enumerados: let nc = NotificationCenter . default nc . post ( name : . saludo ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : \"hola\" ]) Key-Value Observing \u00b6 Gracias a Foundation, un objeto cualquiera puede observar cambios en las propiedades de otro. Especificamos un bloque de c\u00f3digo (funci\u00f3n o clausura) a ejecutar cuando se produzca este cambio. Esta funcionalidad se denomina Key-Value Observing o KVO. N\u00f3tese que para que esto pueda funcionar el runtime tiene que \"interceptar\" de alg\u00fan modo los cambios en las propiedades. Estas funcionalidades est\u00e1n integradas en el runtime de Objective-C, el \"antiguo\" lenguaje de desarrollo de Apple, y Swift todav\u00eda no las incorpora de forma totalmente nativa. As\u00ed, para que KVO funcione con nuestras clases Swift vamos a tener que usar algunas anotaciones y palabras clave especiales que referencian a Objective-C Por ejemplo supongamos el siguiente c\u00f3digo, que define una clase Persona class Persona { var nombre : String var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } let pepito = Persona ( nombre : \"Pepe\" ) pepito . cumplirA\u00f1os () print ( \" \\( pepito . nombre ) tiene \\( pepito . edad ) a\u00f1o/s\" ) Supongamos que nos interesa enterarnos de cu\u00e1ndo cambia la edad de una persona, y ejecutar cierto c\u00f3digo en respuesta a esto. Podemos hacerlo con KVO. Lo primero es cambiar ciertos elementos de la clase para que use el runtime de ObjectiveC: Hacer que la clase herede de la clase base NSObject , que es la ra\u00edz de la jerarqu\u00eda de clases de ObjectiveC \"Marcar\" las propiedades que nos interesa observar con la anotaci\u00f3n @objc y la palabra clave dynamic (en lugar de usar @objc podr\u00edamos marcar la clase entera con @objcMembers ). class Persona : NSObject { var nombre : String @objc dynamic var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } Lo siguiente que necesitamos es poder especificar qu\u00e9 propiedad queremos observar. Esto se hace con una expresi\u00f3n denominada keypath . Un keypath es simplemente la trayectoria a seguir desde un objeto \"inicial\" hasta la propiedad que nos interesa. Por ejemplo algo como \"persona1.nombre\". O si una persona tuviera una propiedad conyuge : Persona podr\u00edamos ir encadenando propiedades: persona1.conyuge.nombre . Hasta Swift 3 los keypath se especificaban como cadenas, pero desde Swift 4 se han a\u00f1adido de forma \"nativa\", con una sintaxis propia que permite el chequeo de tipos por parte del compilador. Con la nueva sintaxis Los keypath comienzan por una barra invertida y se ponen sin comillas, ya que no son cadenas. Se especifican de forma gen\u00e9rica, es decir, comienzan no por un nombre de objeto concreto sino por un nombre de clase, por ejemplo \\Persona.nombre . Si el contexto permite resolver la ambig\u00fcedad se puede omitir el nombre de la clase (pero no el . , por consistencia): por ejemplo \\.nombre , \\.conyuge.nombre . Ahora ya tenemos todos los elementos para indicar que en el ejemplo anterior queremos observar los cambios en la propiedad \"edad\" del objeto \"pepito\" y en respuesta a ellos ejecutar cierto c\u00f3digo. Para ello usamos el m\u00e9todo observe sobre la instancia a observar. El primer par\u00e1metro es el keypath que nos interesa observar y el \u00faltimo una clausura con el c\u00f3digo a ejecutar cuando cambia: import Foundation let observador = pepito . observe ( \\ . edad ) { obj , cambio in print ( \" \\( obj . nombre ) ahora tiene \\( obj . edad \") } N\u00f3tese que en el keypath se puede omitir Persona al comienzo ya que claramente \"edad\" debe ser una propiedad de esta clase. La clausura con el c\u00f3digo a ejecutar recibe dos par\u00e1metros: obj , que es el objeto que estamos observando, y cambio , que nos da m\u00e1s informaci\u00f3n sobre el cambio producido (luego veremos el uso de este \u00faltimo) Cuando ya no nos interese seguir observando podemos parar el KVO llamando a invalidate sobre el valor devuelto por observe : observador . invalidate () Importante: las observaciones se seguir\u00e1n realizando mientras el objeto devuelto por observe siga definido. Cuando se \"pierde\" (por ejemplo era una variable local a una funci\u00f3n y esta ya ha terminado) el KVO se para autom\u00e1ticamente. En versiones antiguas de iOS hab\u00eda que pararlo manualmente y se produc\u00eda un error si se recib\u00edan nuevas observaciones cuando el observador ya no exist\u00eda. En el ejemplo anterior solo nos interesaba el estado actual del objeto una vez producido el cambio. En algunos casos nos puede interesar m\u00e1s informaci\u00f3n, como saber adem\u00e1s cu\u00e1l era el valor anterior de la propiedad. Para ello se usa un par\u00e1metro de observe que antes hemos omitido, llamado options , de tipo OptionSet . Desde el punto de vista de su uso, un OptionSet es un array de constantes donde especificamos un conjunto de opciones que no son mutuamente excluyentes. En nuestro caso las opciones son constantes de la clase NSKeyValueObservingOptions . Vamos a indicar por ejemplo que nos interesa que se nos informe expl\u00edcitamente del valor actual y del antiguo: let obs = pepito . observe ( \\ . edad , options :[. new , . old ]) { obj , cambio in print ( \"Antes: \\( cambio . oldValue ! ) \" ) print ( \"Ahora: \\( cambio . newValue ! ) \" ) } En options hemos indicado qu\u00e9 informaci\u00f3n queremos y esta la tenemos disponible a trav\u00e9s de propiedades del segundo par\u00e1metro de la clausura (nuestro par\u00e1metro cambio ). Hay m\u00e1s opciones de KVO, por ejemplo con .prior indicar\u00edamos que queremos recibir dos avisos, uno inmediatamente antes del cambio y otro inmediatamente despu\u00e9s. Se recomienda consultar la documentaci\u00f3n para ver m\u00e1s opciones.","title":"Comunicaci\u00f3n modelo-controlador"},{"location":"s4/comunicacion/#comunicacion-modelo-controlador","text":"Ya hemos visto c\u00f3mo se comunican bidireccionalmente el controlador y la vista: Cuando la vista genera un evento (como por ejemplo un tap en un bot\u00f3n) llama a un m\u00e9todo del controlador (un action ) El controlador puede acceder al estado actual de ciertos elementos de la vista y manipularlo a trav\u00e9s de los outlet . Tambi\u00e9n hemos visto que el controlador mantiene una referencia a las clases del modelo y que as\u00ed podemos llamar a la l\u00f3gica de negocio, pero nos falta la otra direcci\u00f3n: c\u00f3mo avisa el modelo al controlador de que se ha producido un evento importante. Por ejemplo supongamos una aplicaci\u00f3n de mensajer\u00eda en la que las clases del modelo reciben un nuevo mensaje, y hay que pas\u00e1rselo al controlador para que \u00e9ste lo muestre en la vista. Una opci\u00f3n para comunicar eventos del modelo al controlador ser\u00eda que el primero mantuviera una referencia al segundo y as\u00ed pudiera llamar a cierto m\u00e9todo o m\u00e9todos. Pero esto acoplar\u00eda el c\u00f3digo del modelo al controlador, y no nos permitir\u00eda reutilizar el modelo o partes sgnificativas de \u00e9l en otras aplicaciones, o \"protegerlo\" de posibles cambios en el controlador. Vamos a ver aqu\u00ed m\u00e9todos \"no invasivos\" para que el modelo comunique con el controlador, sin necesidad de acoplar el c\u00f3digo de ambos. Es inevitable que controlador tenga conocimiento del modelo, pero como vamos a ver no es inevitable que el modelo tenga conocimiento del controlador. En Foundation hay dos formas b\u00e1sicas de conseguir que dos objetos se comuniquen acoplando el c\u00f3digo de ambos lo menos posible: Notificaciones: un objeto puede recibir notificaciones sobre eventos que le interesen. As\u00edmismo otro objeto puede enviar notificaciones. El encargado de gestionar las notificaciones es un objeto intermediario denominado \"centro de notificaciones\". Podemos usar las notificaciones de modo que el modelo notifique que ha habido un cambio y el controlador reciba la notificaci\u00f3n y actualice la vista. Key-Value observing o KVO: un objeto puede \"vigilar\" el cambio en el valor de las propiedades de otro. Cuando se produzca un cambio, se llamar\u00e1 a una funci\u00f3n o clausura que act\u00faa de callback . Podemos usar este mecanismo para hacer que el controlador observe las propiedades del modelo que nos interesa actualizar din\u00e1micamente en la vista.","title":"Comunicaci\u00f3n modelo-controlador"},{"location":"s4/comunicacion/#notificaciones-locales","text":"Son algo similar a lo que en aplicaciones enterprise se llaman colas de mensajes . Implementan el patr\u00f3n de dise\u00f1o publicar/suscribir. Cuando un objeto quiere avisar al resto del sistema, publica una notificaci\u00f3n asign\u00e1ndole un nombre, y opcionalmente un payload (datos asociados). Los objetos que quieren recibir la notificaci\u00f3n indican el nombre de la que le interesa, y qu\u00e9 m\u00e9todo o clausura ejecutar cuando se reciba. El encargado de gestionar las notificaciones es el NotificationCenter . Hay uno por defecto ya inicializado en cada aplicaci\u00f3n ( NotificationCenter.default ). Se pueden crear m\u00e1s, pero en la mayor\u00eda de aplicaciones nos bastar\u00e1 con uno. A este centro de notificaciones es a quien le decimos que env\u00ede las notificaciones (publicar) o que queremos recibir las de un determinado tipo (suscribir). import Foundation class Emisor { func enviar ( mensaje : String ) { //Obtenemos el centro de notificaciones por defecto //Las notificaciones tienen un nombre, un objeto que las env\u00eda (si lo ponemos a nil no queda constancia de qui\u00e9n) y datos adicionales, un diccionario con los datos que queramos let nc = NotificationCenter . default nc . post ( name : Notification . Name ( \"saludo\" ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : mensaje ]) } } class Receptor { func suscribirse () { let nc = NotificationCenter . default //primer par\u00e1metro: a\u00f1adimos como observador a nosotros (self) //selector: al recibir la notificaci\u00f3n se llama al m\u00e9todo recibir //name: nombre de la notificaci\u00f3n que nos interesa //object: objeto del que nos interesa recibir notificaciones. nil == cualquiera nc . addObserver ( self , selector : #selector ( self . recibir ), name : Notification . Name ( \"saludo\" ), object : nil ) } @objc func recibir ( notificacion : Notification ) { print ( \"recibido!!\" ) if let userInfo = notificacion . userInfo { let mensaje = userInfo [ \"mensaje\" ] as ! String print ( \"dice: \\( mensaje ) \" ) } } } var e = Emisor () var r = Receptor () r . suscribirse () e . enviar ( mensaje : \"holaaaa\" ) El nombre de la notificaci\u00f3n no es exactamente un String, sino un Notification.Name construido a partir de un String. Para que el c\u00f3digo sea m\u00e1s seguro y menos propenso a errores podemos extender esta clase con constantes y usar estas constantes en lugar de directamente los Strings. Siguiendo con el ejemplo, har\u00edamos algo como: //En el archivo que queramos //Alguna gente usa convenciones del tipo \"NotificationName+Extensions.swift\" extension Notification . Name { static let saludo = Notification . Name ( \"saludo\" ) } y ahora cuando queramos referenciar un Notification.name lo hacemos como Notification.name.saludo o mejor a\u00fan, simplemente .saludo como en los enumerados: let nc = NotificationCenter . default nc . post ( name : . saludo ), object : nil , userInfo : [ \"valor\" : 1 , \"mensaje\" : \"hola\" ])","title":"Notificaciones locales"},{"location":"s4/comunicacion/#key-value-observing","text":"Gracias a Foundation, un objeto cualquiera puede observar cambios en las propiedades de otro. Especificamos un bloque de c\u00f3digo (funci\u00f3n o clausura) a ejecutar cuando se produzca este cambio. Esta funcionalidad se denomina Key-Value Observing o KVO. N\u00f3tese que para que esto pueda funcionar el runtime tiene que \"interceptar\" de alg\u00fan modo los cambios en las propiedades. Estas funcionalidades est\u00e1n integradas en el runtime de Objective-C, el \"antiguo\" lenguaje de desarrollo de Apple, y Swift todav\u00eda no las incorpora de forma totalmente nativa. As\u00ed, para que KVO funcione con nuestras clases Swift vamos a tener que usar algunas anotaciones y palabras clave especiales que referencian a Objective-C Por ejemplo supongamos el siguiente c\u00f3digo, que define una clase Persona class Persona { var nombre : String var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } let pepito = Persona ( nombre : \"Pepe\" ) pepito . cumplirA\u00f1os () print ( \" \\( pepito . nombre ) tiene \\( pepito . edad ) a\u00f1o/s\" ) Supongamos que nos interesa enterarnos de cu\u00e1ndo cambia la edad de una persona, y ejecutar cierto c\u00f3digo en respuesta a esto. Podemos hacerlo con KVO. Lo primero es cambiar ciertos elementos de la clase para que use el runtime de ObjectiveC: Hacer que la clase herede de la clase base NSObject , que es la ra\u00edz de la jerarqu\u00eda de clases de ObjectiveC \"Marcar\" las propiedades que nos interesa observar con la anotaci\u00f3n @objc y la palabra clave dynamic (en lugar de usar @objc podr\u00edamos marcar la clase entera con @objcMembers ). class Persona : NSObject { var nombre : String @objc dynamic var edad : Int = 0 func cumplirA\u00f1os () { self . edad += 1 } init ( nombre : String ) { self . nombre = nombre } } Lo siguiente que necesitamos es poder especificar qu\u00e9 propiedad queremos observar. Esto se hace con una expresi\u00f3n denominada keypath . Un keypath es simplemente la trayectoria a seguir desde un objeto \"inicial\" hasta la propiedad que nos interesa. Por ejemplo algo como \"persona1.nombre\". O si una persona tuviera una propiedad conyuge : Persona podr\u00edamos ir encadenando propiedades: persona1.conyuge.nombre . Hasta Swift 3 los keypath se especificaban como cadenas, pero desde Swift 4 se han a\u00f1adido de forma \"nativa\", con una sintaxis propia que permite el chequeo de tipos por parte del compilador. Con la nueva sintaxis Los keypath comienzan por una barra invertida y se ponen sin comillas, ya que no son cadenas. Se especifican de forma gen\u00e9rica, es decir, comienzan no por un nombre de objeto concreto sino por un nombre de clase, por ejemplo \\Persona.nombre . Si el contexto permite resolver la ambig\u00fcedad se puede omitir el nombre de la clase (pero no el . , por consistencia): por ejemplo \\.nombre , \\.conyuge.nombre . Ahora ya tenemos todos los elementos para indicar que en el ejemplo anterior queremos observar los cambios en la propiedad \"edad\" del objeto \"pepito\" y en respuesta a ellos ejecutar cierto c\u00f3digo. Para ello usamos el m\u00e9todo observe sobre la instancia a observar. El primer par\u00e1metro es el keypath que nos interesa observar y el \u00faltimo una clausura con el c\u00f3digo a ejecutar cuando cambia: import Foundation let observador = pepito . observe ( \\ . edad ) { obj , cambio in print ( \" \\( obj . nombre ) ahora tiene \\( obj . edad \") } N\u00f3tese que en el keypath se puede omitir Persona al comienzo ya que claramente \"edad\" debe ser una propiedad de esta clase. La clausura con el c\u00f3digo a ejecutar recibe dos par\u00e1metros: obj , que es el objeto que estamos observando, y cambio , que nos da m\u00e1s informaci\u00f3n sobre el cambio producido (luego veremos el uso de este \u00faltimo) Cuando ya no nos interese seguir observando podemos parar el KVO llamando a invalidate sobre el valor devuelto por observe : observador . invalidate () Importante: las observaciones se seguir\u00e1n realizando mientras el objeto devuelto por observe siga definido. Cuando se \"pierde\" (por ejemplo era una variable local a una funci\u00f3n y esta ya ha terminado) el KVO se para autom\u00e1ticamente. En versiones antiguas de iOS hab\u00eda que pararlo manualmente y se produc\u00eda un error si se recib\u00edan nuevas observaciones cuando el observador ya no exist\u00eda. En el ejemplo anterior solo nos interesaba el estado actual del objeto una vez producido el cambio. En algunos casos nos puede interesar m\u00e1s informaci\u00f3n, como saber adem\u00e1s cu\u00e1l era el valor anterior de la propiedad. Para ello se usa un par\u00e1metro de observe que antes hemos omitido, llamado options , de tipo OptionSet . Desde el punto de vista de su uso, un OptionSet es un array de constantes donde especificamos un conjunto de opciones que no son mutuamente excluyentes. En nuestro caso las opciones son constantes de la clase NSKeyValueObservingOptions . Vamos a indicar por ejemplo que nos interesa que se nos informe expl\u00edcitamente del valor actual y del antiguo: let obs = pepito . observe ( \\ . edad , options :[. new , . old ]) { obj , cambio in print ( \"Antes: \\( cambio . oldValue ! ) \" ) print ( \"Ahora: \\( cambio . newValue ! ) \" ) } En options hemos indicado qu\u00e9 informaci\u00f3n queremos y esta la tenemos disponible a trav\u00e9s de propiedades del segundo par\u00e1metro de la clausura (nuestro par\u00e1metro cambio ). Hay m\u00e1s opciones de KVO, por ejemplo con .prior indicar\u00edamos que queremos recibir dos avisos, uno inmediatamente antes del cambio y otro inmediatamente despu\u00e9s. Se recomienda consultar la documentaci\u00f3n para ver m\u00e1s opciones.","title":"Key-Value Observing"},{"location":"s4/ejercicio_i18n/","text":"Ejercicio de i18n (2 puntos) \u00b6 Haz que la interfaz de la app UAdivino se vea correctamente en espa\u00f1ol e ingl\u00e9s. Como el idioma base de desarrollo deber\u00eda ser el ingl\u00e9s primero tendr\u00e1s que cambiar los textos de los componentes de la interfaz gr\u00e1fica (el bot\u00f3n y el label con el texto est\u00e1tico) a este idioma. Ten en cuenta que necesitar\u00e1s tambi\u00e9n localizar los mensajes generados en el c\u00f3digo. En el apartado \"Localizar los mensajes en el c\u00f3digo\" tienes explicado c\u00f3mo hacerlo","title":"Ejercicio de i18n (2 puntos)"},{"location":"s4/ejercicio_i18n/#ejercicio-de-i18n-2-puntos","text":"Haz que la interfaz de la app UAdivino se vea correctamente en espa\u00f1ol e ingl\u00e9s. Como el idioma base de desarrollo deber\u00eda ser el ingl\u00e9s primero tendr\u00e1s que cambiar los textos de los componentes de la interfaz gr\u00e1fica (el bot\u00f3n y el label con el texto est\u00e1tico) a este idioma. Ten en cuenta que necesitar\u00e1s tambi\u00e9n localizar los mensajes generados en el c\u00f3digo. En el apartado \"Localizar los mensajes en el c\u00f3digo\" tienes explicado c\u00f3mo hacerlo","title":"Ejercicio de i18n (2 puntos)"},{"location":"s4/i18n/","text":"Internacionalizaci\u00f3n de aplicaciones iOS \u00b6 En un mercado global hay que tener previsto desde el principio la adaptaci\u00f3n de los mensajes y textos mostrados por la app al idioma local, y tambi\u00e9n de otras convenciones (unidades de medida, formatos de n\u00fameros y fechas,...). Al proceso de preparaci\u00f3n de la app para soportar distintos idiomas se le denomina internacionalizaci\u00f3n (o i18n, por el n\u00famero de letras existentes entre la \"i\" inicial y la \"n\" final de la palabra completa). A la adaptaci\u00f3n para un idioma concreto se la denomina localizaci\u00f3n . Vamos a ver aqu\u00ed una introducci\u00f3n a las funcionalidades b\u00e1sicas que nos da la plataforma iOS para internacionalizar y localizar nuestras aplicaciones. Configurar el soporte para los idiomas deseados \u00b6 En la versi\u00f3n actual de Xcode los proyectos ya incluyen por defecto soporte para i18n . Lo que tenemos que hacer es a\u00f1adir los idiomas para los que queramos localizar la app . Como veremos, este paso es conveniente hacerlo una vez hayamos terminado el dise\u00f1o de la interfaz, ya que los componentes de UI que a\u00f1adamos despu\u00e9s no estar\u00e1n localizados por defecto y tendremos que hacerlo manualmente En el Project Navigator de la izquierda de la pantalla debemos seleccionar el icono del proyecto. Una vez hecho esto, en la parte central hay que asegurarse de seleccionar el \"project\" y no el \"target\". En el apartado Info , al final de las propiedades veremos un apartado llamado Localizations . El idioma de desarrollo o development language es el que se va a usar por defecto para desarrollar la interfaz. Adem\u00e1s de este podemos a\u00f1adir otros idiomas. En la versi\u00f3n actual de Xcode solo est\u00e1 previsto el ingl\u00e9s como development language y no se puede cambiar desde el IDE (solo podr\u00edamos cambiarlo editando manualmente el archivo .pbxproj del proyecto). Para a\u00f1adir un idioma basta pulsar + F\u00edjate en que cuando a\u00f1adimos un idioma aparece un cuadro de di\u00e1logo que nos dice qu\u00e9 storyboards se van a internacionalizar, lo habitual ser\u00e1 seleccionarlos todos pero podemos escoger los que nos interesen. Adem\u00e1s podemos elegir el m\u00e9todo usado. Por defecto es Localizable strings , pero hay otro m\u00e9todo llamado Interface builder storyboard : Localizable strings : por cada idioma hay un archivo de texto Strings en el que se almacena la traducci\u00f3n de los textos de cada bot\u00f3n, label, etc. El storyboard es \u00fanico para todos los idiomas, y lo que se hace es cambiar solamente el texto. Interface builder storyboard : tenemos una copia del storyboard por cada idioma, y la editamos por separado. Aqu\u00ed vamos a describir c\u00f3mo usar los Localizable strings , ya que es el m\u00e9todo m\u00e1s com\u00fan. Localizar los storyboards \u00b6 Los archivos .strings \u00b6 Si hemos a\u00f1adido idiomas adicionales veremos que en el project navigator los iconos de storyboard aparecen con una flecha a la izquierda indicando que en realidad son varios archivos. Al desplegarlo veremos que es el storyboard en s\u00ed m\u00e1s un archivo .strings por cada idioma a\u00f1adido. Al abrir este archivo .strings veremos que es un archivo de texto en el que por cada componente de usuario que contenga texto hay una l\u00ednea en el formato \"identificador-del-componente\" = \"Texto mostrado\" Lo \u00fanico que tenemos que hacer es cambiar el texto al idioma correspondiente . El identificador del componente es un tanto cr\u00edptico ya que es autogenerado por Xcode,y se corresponde con el Object Id que podemos ver en el Identity inspector , aunque casi siempre es f\u00e1cil saber de qu\u00e9 componente se trata simplemente por el texto mostrado. Probar la interfaz \u00b6 Podemos previsualizar c\u00f3mo quedar\u00e1 la interfaz en los distintos idiomas sin necesidad de ejecutar la app . En el editor del storyboard clicamos sobre el bot\u00f3n de la barra superior y seleccionamos la opci\u00f3n Preview . Se mostrar\u00e1 el storyboard en el idioma base. Este idioma aparecer\u00e1 en la esquina inferior derecha, pulsando sobre \u00e9l podemos cambiarlo. Tambi\u00e9n podemos probar la app en el simulador y cambiar aqu\u00ed el idioma del sistema. Habr\u00e1 que salir de la app , ir al icono de settings (o configuraci\u00f3n en la versi\u00f3n en espa\u00f1ol) y en el apartado General cambiar el Language & Region . El proceso es un poco m\u00e1s tedioso que la simple previsualizaci\u00f3n porque hay que salir y volver a entrar en la app y adem\u00e1s el simulador tarda unos segundos en aplicar el nuevo idioma. A\u00f1adir elementos a la interfaz tras internacionalizar \u00b6 Hay un problema con el proceso descrito en los apartados anteriores y es que cuando se a\u00f1aden nuevos elementos a la interfaz de usuario, Xcode no actualiza autom\u00e1ticamente los archivos .Strings . Una posible soluci\u00f3n ser\u00eda editar manualmente los .Strings pero es un proceso tedioso porque, como hemos visto, cada componente viene identificado con su Object id y tendr\u00edamos que consultarlo manualmente en Xcode y copiarlo al archivo de texto, repitiendo la operaci\u00f3n para cada nuevo elemento de la interfaz. Apple tiene algunas herramientas que permiten automatizar el proceso en cierta medida, pero son herramientas en l\u00ednea de comandos y su uso no es precisamente trivial. Por ejemplo podr\u00edamos usar la herramienta ibtool . Supongamos que hemos a\u00f1adido una etiqueta al Main.storyboard y queremos actualizar el Main.Strings de espa\u00f1ol. Tendr\u00edamos que abrir una terminal e ir hasta el directorio donde est\u00e9 este archivo. La estructura de de directorios y archivos relativa a la internacionalizaci\u00f3n ser\u00e1 como la siguiente: Como vemos, los archivos de espa\u00f1ol est\u00e1n en un subdirectorio llamado es.lproj . En el ejemplo solo hay un Main.Strings porque la launchscreen est\u00e1 vac\u00eda y por eso no ha generado ning\u00fan archivo. Los archivos del idioma base est\u00e1n en base.lproj , y este es el que contiene los storyboards . Con la opci\u00f3n --import-strings-file le decimos a ibtool cu\u00e1l es la versi\u00f3n actual del .Strings de la que queremos partir, y con --generate-strings-file en qu\u00e9 archivo queremos generar el resultado. Finalmente ponemos el nombre del archivo con el storyboard . Por ejemplo, suponiendo que abrimos la terminal y nos movemos al directorio es.lproj , el comando ser\u00eda algo como: ibtool --generate-strings-file Main.Strings --import-strings-file Main.Strings ../Base.lproj/Main.storyboard Ponemos el mismo valor para el --generate-strings-file que para el --import-strings-file para actualizar el archivo, no queremos generar uno nuevo. Una vez hecho esto, ya podemos editar manualmente el .Strings para a\u00f1adir las traducciones de los nuevos elementos de la interfaz. Hay herramientas de terceros que automatizan bastante m\u00e1s el proceso, algunas comerciales y otras open source como por ejemplo BartyCrouch . Esta sigue siendo una herramienta de l\u00ednea de comandos pero con comandos mucho m\u00e1s sencillos, Por ejemplo podemos ejecutar simplemente bartycrouch -p trayectoria/hasta/el/proyecto para actualizar autom\u00e1ticamente todos los archivos Strings . Localizar los mensajes en el c\u00f3digo \u00b6 Hay mensajes que no est\u00e1n fijos en la interfaz, sino que se generan desde el c\u00f3digo. Por ejemplo recordemos la app UAdivino que hicimos en el tema de \"Introducci\u00f3n a las aplicaciones iOS\". Lo que tenemos que hacer para internacionalizar este tipo de mensajes es usar localized strings . Este tipo de strings no se toman de manera literal sino que se consideran claves en un archivo .Strings . El sistema sustituir\u00e1 la clave por el valor asociado en el idioma actual. La representaci\u00f3n interna de los mensajes en el c\u00f3digo ser\u00eda parecida, aunque puede ser m\u00e1s breve, ya que no es el mensaje que va a ser el usuario final. import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"si\" , \"no\" , \"ni_casualidad\" , \"claro\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } En el momento en que queremos asignar el mensaje a un elemento de usuario podemos usar la macro NSLocalizedString , que obtiene el mensaje asociado a la clave @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = NSLocalizedString ( respuesta , comment : \"\" ) } El segundo par\u00e1metro de NSLocalizedString es un comentario que pueda ayudar a un traductor de la app a entender el contexto del mensaje. En este caso no tiene sentido y lo dejamos vac\u00edo. Para que esto funcione nos falta todav\u00eda crear el archivo .strings . Por defecto se debe llamar Localizable.strings . Para crearlo, en Xcode se elige File > New > File . De entre las plantillas disponibles hay que ir a la secci\u00f3n Resource y elegir all\u00ed Strings File . Teniendo seleccionado el archivo, en el File inspector del panel de la derecha de Xcode pulsamos el bot\u00f3n Localize... para que tenga versiones en distintos idiomas. Nos preguntar\u00e1 qu\u00e9 versi\u00f3n inicial queremos crear (por defecto English ). Una vez creada esta podemos marcar el resto de idiomas que hemos a\u00f1adido a nuestra app (en nuestro caso solo espa\u00f1ol) Esto habr\u00e1 creado dos archivos distintos para Localizable.strings , uno para ingl\u00e9s y otro para espa\u00f1ol. Ahora solo tenemos que editar las claves y los valores de cada uno de ellos. Para la versi\u00f3n inglesa ser\u00eda algo como: \"si\" = \"Yes!\" ; \"no\" = \"No!\" ; \"ni_casualidad\" = \"No way!\" ; \"claro\" = \"Sure!\" ; Y para la espa\u00f1ola: \"si\" = \"\u00a1Si!\" ; \"no\" = \"\u00a1No!\" ; \"ni_casualidad\" = \"\u00a1Ni de casualidad!\" ; \"claro\" = \"\u00a1Claro que s\u00ed!\" ; Para probar esta funcionalidad tendremos que ejecutar la app en el simulador y cambiar el idioma desde la aplicaci\u00f3n de settings/configuraci\u00f3n . Es posible que en algunos casos tengamos mensajes con una parte fija y una variable. Por ejemplo un saludo en el que queremos incluir el nombre del usuario. Por desgracia, en la versi\u00f3n actual de iOS la interpolaci\u00f3n de cadenas de Swift todav\u00eda no funciona para los mensajes internacionalizados. Tenemos que usar placeholders en el mensaje, que son caracteres que funcionan de modo similar a como lo hacen los caracteres de formato en el printf de C: /* .strings en versi\u00f3n ingl\u00e9s */ saludo = \"Welcome %@\" ; ... En este caso, para \"montar\" el mensaje final tenemos que usar un inicializador de String que acepte cadenas de formato: let nombre = \"John\" let mensaje = String(format: NSLocalizedString(\"saludo\", comment: \"\"), nombre) N\u00f3tese que estos placeholders ( %@ ) vienen \"heredados\" del lenguaje Objective-C, que utiliza unos caracteres de formato similares a los de C . Por ejemplo para mostrar un n\u00famero entero se usa %d , aunque para mostrar una cadena se usa el car\u00e1cter de formato gen\u00e9rico de \"objeto\", que como se ha visto es %@ .","title":"Internacionalizaci\u00f3n de aplicaciones iOS"},{"location":"s4/i18n/#internacionalizacion-de-aplicaciones-ios","text":"En un mercado global hay que tener previsto desde el principio la adaptaci\u00f3n de los mensajes y textos mostrados por la app al idioma local, y tambi\u00e9n de otras convenciones (unidades de medida, formatos de n\u00fameros y fechas,...). Al proceso de preparaci\u00f3n de la app para soportar distintos idiomas se le denomina internacionalizaci\u00f3n (o i18n, por el n\u00famero de letras existentes entre la \"i\" inicial y la \"n\" final de la palabra completa). A la adaptaci\u00f3n para un idioma concreto se la denomina localizaci\u00f3n . Vamos a ver aqu\u00ed una introducci\u00f3n a las funcionalidades b\u00e1sicas que nos da la plataforma iOS para internacionalizar y localizar nuestras aplicaciones.","title":"Internacionalizaci\u00f3n de aplicaciones iOS"},{"location":"s4/i18n/#configurar-el-soporte-para-los-idiomas-deseados","text":"En la versi\u00f3n actual de Xcode los proyectos ya incluyen por defecto soporte para i18n . Lo que tenemos que hacer es a\u00f1adir los idiomas para los que queramos localizar la app . Como veremos, este paso es conveniente hacerlo una vez hayamos terminado el dise\u00f1o de la interfaz, ya que los componentes de UI que a\u00f1adamos despu\u00e9s no estar\u00e1n localizados por defecto y tendremos que hacerlo manualmente En el Project Navigator de la izquierda de la pantalla debemos seleccionar el icono del proyecto. Una vez hecho esto, en la parte central hay que asegurarse de seleccionar el \"project\" y no el \"target\". En el apartado Info , al final de las propiedades veremos un apartado llamado Localizations . El idioma de desarrollo o development language es el que se va a usar por defecto para desarrollar la interfaz. Adem\u00e1s de este podemos a\u00f1adir otros idiomas. En la versi\u00f3n actual de Xcode solo est\u00e1 previsto el ingl\u00e9s como development language y no se puede cambiar desde el IDE (solo podr\u00edamos cambiarlo editando manualmente el archivo .pbxproj del proyecto). Para a\u00f1adir un idioma basta pulsar + F\u00edjate en que cuando a\u00f1adimos un idioma aparece un cuadro de di\u00e1logo que nos dice qu\u00e9 storyboards se van a internacionalizar, lo habitual ser\u00e1 seleccionarlos todos pero podemos escoger los que nos interesen. Adem\u00e1s podemos elegir el m\u00e9todo usado. Por defecto es Localizable strings , pero hay otro m\u00e9todo llamado Interface builder storyboard : Localizable strings : por cada idioma hay un archivo de texto Strings en el que se almacena la traducci\u00f3n de los textos de cada bot\u00f3n, label, etc. El storyboard es \u00fanico para todos los idiomas, y lo que se hace es cambiar solamente el texto. Interface builder storyboard : tenemos una copia del storyboard por cada idioma, y la editamos por separado. Aqu\u00ed vamos a describir c\u00f3mo usar los Localizable strings , ya que es el m\u00e9todo m\u00e1s com\u00fan.","title":"Configurar el soporte para los idiomas deseados"},{"location":"s4/i18n/#localizar-los-storyboards","text":"","title":"Localizar los storyboards"},{"location":"s4/i18n/#los-archivos-strings","text":"Si hemos a\u00f1adido idiomas adicionales veremos que en el project navigator los iconos de storyboard aparecen con una flecha a la izquierda indicando que en realidad son varios archivos. Al desplegarlo veremos que es el storyboard en s\u00ed m\u00e1s un archivo .strings por cada idioma a\u00f1adido. Al abrir este archivo .strings veremos que es un archivo de texto en el que por cada componente de usuario que contenga texto hay una l\u00ednea en el formato \"identificador-del-componente\" = \"Texto mostrado\" Lo \u00fanico que tenemos que hacer es cambiar el texto al idioma correspondiente . El identificador del componente es un tanto cr\u00edptico ya que es autogenerado por Xcode,y se corresponde con el Object Id que podemos ver en el Identity inspector , aunque casi siempre es f\u00e1cil saber de qu\u00e9 componente se trata simplemente por el texto mostrado.","title":"Los archivos .strings"},{"location":"s4/i18n/#probar-la-interfaz","text":"Podemos previsualizar c\u00f3mo quedar\u00e1 la interfaz en los distintos idiomas sin necesidad de ejecutar la app . En el editor del storyboard clicamos sobre el bot\u00f3n de la barra superior y seleccionamos la opci\u00f3n Preview . Se mostrar\u00e1 el storyboard en el idioma base. Este idioma aparecer\u00e1 en la esquina inferior derecha, pulsando sobre \u00e9l podemos cambiarlo. Tambi\u00e9n podemos probar la app en el simulador y cambiar aqu\u00ed el idioma del sistema. Habr\u00e1 que salir de la app , ir al icono de settings (o configuraci\u00f3n en la versi\u00f3n en espa\u00f1ol) y en el apartado General cambiar el Language & Region . El proceso es un poco m\u00e1s tedioso que la simple previsualizaci\u00f3n porque hay que salir y volver a entrar en la app y adem\u00e1s el simulador tarda unos segundos en aplicar el nuevo idioma.","title":"Probar la interfaz"},{"location":"s4/i18n/#anadir-elementos-a-la-interfaz-tras-internacionalizar","text":"Hay un problema con el proceso descrito en los apartados anteriores y es que cuando se a\u00f1aden nuevos elementos a la interfaz de usuario, Xcode no actualiza autom\u00e1ticamente los archivos .Strings . Una posible soluci\u00f3n ser\u00eda editar manualmente los .Strings pero es un proceso tedioso porque, como hemos visto, cada componente viene identificado con su Object id y tendr\u00edamos que consultarlo manualmente en Xcode y copiarlo al archivo de texto, repitiendo la operaci\u00f3n para cada nuevo elemento de la interfaz. Apple tiene algunas herramientas que permiten automatizar el proceso en cierta medida, pero son herramientas en l\u00ednea de comandos y su uso no es precisamente trivial. Por ejemplo podr\u00edamos usar la herramienta ibtool . Supongamos que hemos a\u00f1adido una etiqueta al Main.storyboard y queremos actualizar el Main.Strings de espa\u00f1ol. Tendr\u00edamos que abrir una terminal e ir hasta el directorio donde est\u00e9 este archivo. La estructura de de directorios y archivos relativa a la internacionalizaci\u00f3n ser\u00e1 como la siguiente: Como vemos, los archivos de espa\u00f1ol est\u00e1n en un subdirectorio llamado es.lproj . En el ejemplo solo hay un Main.Strings porque la launchscreen est\u00e1 vac\u00eda y por eso no ha generado ning\u00fan archivo. Los archivos del idioma base est\u00e1n en base.lproj , y este es el que contiene los storyboards . Con la opci\u00f3n --import-strings-file le decimos a ibtool cu\u00e1l es la versi\u00f3n actual del .Strings de la que queremos partir, y con --generate-strings-file en qu\u00e9 archivo queremos generar el resultado. Finalmente ponemos el nombre del archivo con el storyboard . Por ejemplo, suponiendo que abrimos la terminal y nos movemos al directorio es.lproj , el comando ser\u00eda algo como: ibtool --generate-strings-file Main.Strings --import-strings-file Main.Strings ../Base.lproj/Main.storyboard Ponemos el mismo valor para el --generate-strings-file que para el --import-strings-file para actualizar el archivo, no queremos generar uno nuevo. Una vez hecho esto, ya podemos editar manualmente el .Strings para a\u00f1adir las traducciones de los nuevos elementos de la interfaz. Hay herramientas de terceros que automatizan bastante m\u00e1s el proceso, algunas comerciales y otras open source como por ejemplo BartyCrouch . Esta sigue siendo una herramienta de l\u00ednea de comandos pero con comandos mucho m\u00e1s sencillos, Por ejemplo podemos ejecutar simplemente bartycrouch -p trayectoria/hasta/el/proyecto para actualizar autom\u00e1ticamente todos los archivos Strings .","title":"A\u00f1adir elementos a la interfaz tras internacionalizar"},{"location":"s4/i18n/#localizar-los-mensajes-en-el-codigo","text":"Hay mensajes que no est\u00e1n fijos en la interfaz, sino que se generan desde el c\u00f3digo. Por ejemplo recordemos la app UAdivino que hicimos en el tema de \"Introducci\u00f3n a las aplicaciones iOS\". Lo que tenemos que hacer para internacionalizar este tipo de mensajes es usar localized strings . Este tipo de strings no se toman de manera literal sino que se consideran claves en un archivo .Strings . El sistema sustituir\u00e1 la clave por el valor asociado en el idioma actual. La representaci\u00f3n interna de los mensajes en el c\u00f3digo ser\u00eda parecida, aunque puede ser m\u00e1s breve, ya que no es el mensaje que va a ser el usuario final. import Foundation class Adivino { func obtenerRespuesta () -> String { let respuestas = [ \"si\" , \"no\" , \"ni_casualidad\" , \"claro\" ] let indice = Int ( arc4random_uniform ( UInt32 ( respuestas . count ))) return respuestas [ indice ] } } En el momento en que queremos asignar el mensaje a un elemento de usuario podemos usar la macro NSLocalizedString , que obtiene el mensaje asociado a la clave @IBAction func botonPulsado ( _ sender : AnyObject ) { let respuesta = self . miAdivino . obtenerRespuesta () self . labelRespuesta . text = NSLocalizedString ( respuesta , comment : \"\" ) } El segundo par\u00e1metro de NSLocalizedString es un comentario que pueda ayudar a un traductor de la app a entender el contexto del mensaje. En este caso no tiene sentido y lo dejamos vac\u00edo. Para que esto funcione nos falta todav\u00eda crear el archivo .strings . Por defecto se debe llamar Localizable.strings . Para crearlo, en Xcode se elige File > New > File . De entre las plantillas disponibles hay que ir a la secci\u00f3n Resource y elegir all\u00ed Strings File . Teniendo seleccionado el archivo, en el File inspector del panel de la derecha de Xcode pulsamos el bot\u00f3n Localize... para que tenga versiones en distintos idiomas. Nos preguntar\u00e1 qu\u00e9 versi\u00f3n inicial queremos crear (por defecto English ). Una vez creada esta podemos marcar el resto de idiomas que hemos a\u00f1adido a nuestra app (en nuestro caso solo espa\u00f1ol) Esto habr\u00e1 creado dos archivos distintos para Localizable.strings , uno para ingl\u00e9s y otro para espa\u00f1ol. Ahora solo tenemos que editar las claves y los valores de cada uno de ellos. Para la versi\u00f3n inglesa ser\u00eda algo como: \"si\" = \"Yes!\" ; \"no\" = \"No!\" ; \"ni_casualidad\" = \"No way!\" ; \"claro\" = \"Sure!\" ; Y para la espa\u00f1ola: \"si\" = \"\u00a1Si!\" ; \"no\" = \"\u00a1No!\" ; \"ni_casualidad\" = \"\u00a1Ni de casualidad!\" ; \"claro\" = \"\u00a1Claro que s\u00ed!\" ; Para probar esta funcionalidad tendremos que ejecutar la app en el simulador y cambiar el idioma desde la aplicaci\u00f3n de settings/configuraci\u00f3n . Es posible que en algunos casos tengamos mensajes con una parte fija y una variable. Por ejemplo un saludo en el que queremos incluir el nombre del usuario. Por desgracia, en la versi\u00f3n actual de iOS la interpolaci\u00f3n de cadenas de Swift todav\u00eda no funciona para los mensajes internacionalizados. Tenemos que usar placeholders en el mensaje, que son caracteres que funcionan de modo similar a como lo hacen los caracteres de formato en el printf de C: /* .strings en versi\u00f3n ingl\u00e9s */ saludo = \"Welcome %@\" ; ... En este caso, para \"montar\" el mensaje final tenemos que usar un inicializador de String que acepte cadenas de formato: let nombre = \"John\" let mensaje = String(format: NSLocalizedString(\"saludo\", comment: \"\"), nombre) N\u00f3tese que estos placeholders ( %@ ) vienen \"heredados\" del lenguaje Objective-C, que utiliza unos caracteres de formato similares a los de C . Por ejemplo para mostrar un n\u00famero entero se usa %d , aunque para mostrar una cadena se usa el car\u00e1cter de formato gen\u00e9rico de \"objeto\", que como se ha visto es %@ .","title":"Localizar los mensajes en el c\u00f3digo"},{"location":"s5/testing/","text":"Testing en Xcode \u00b6 XCode incluye desde la versi\u00f3n 5 un framework de testing llamado XCTest . En el asistente de creaci\u00f3n de un proyecto, cuando elegimos el nombre del proyecto podemos marcar los correspondientes checkbox para crear los tests asociados al proyecto. Como veremos luego con m\u00e1s detalle tenemos dos tipos gen\u00e9ricos de tests: las pruebas unitarias ( unit tests ) y las pruebas de interfaz de usuario ( ui tests ). Si tenemos un proyecto ya creado sin test , podemos crearlos a posteriori con File > New > Target > iOS unit test bundle (o iOS UI test bundle ). El navegador de Tests \u00b6 Para moverse por los tests, lo m\u00e1s sencillo es usar el Test Navigator , que aparece en el \u00e1rea de Navegadores, a la izquierda de la pantalla. Su icono es el quinto por la izquierda, un rombo . En este navegador podemos ver todos los tests, ir al fuente clicando sobre el nombre del test y ejecutarlos pulsando sobre el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece a la derecha cuando pasamos el rat\u00f3n por encima. Pruebas unitarias \u00b6 En XCTest hay varios tipos distintos de pruebas unitarias: Tests de \u201cl\u00f3gica\u201d : lo que todo el mundo entiende habitualmente por pruebas unitarias, es decir pruebas en las que comprobamos si determinado m\u00e9todo funciona o no correctamente. Tests de tiempo de respuesta : en los que podemos ver estad\u00edsticas del tiempo que tarda en ejecutarse determinado bloque de c\u00f3digo. Podemos fijar un baseline de tiempo de modo que el test se considerar\u00e1 que no pasa si est\u00e1 por encima del baseline Tests as\u00edncronos : con c\u00f3digo as\u00edncrono podemos tener el problema de que Xcode no sepa cu\u00e1ndo ha acabado de ejecutarse nuestro c\u00f3digo y por tanto se puede dar por acabado el test. Por ejemplo si lanzamos una petici\u00f3n HTTP no podemos hacer las comprobaciones hasta que no llegue la respuesta. En este tipo de test podemos indicar a Xcode cu\u00e1ndo lo puede dar por terminado, o en caso de sobrepasar un timeout que lo de por fallido. Un ejemplo \u00b6 XCTest es muy similar a otros frameworks de pruebas unitarias como JUnit , as\u00ed que es sencillo de usar para alguien que ya haya usado este \u00faltimo Por ejemplo, supongamos que tenemos un juego de tres en raya y aqu\u00ed tenemos parte del modelo (se omite el c\u00f3digo interno de los m\u00e9todos, para mayor brevedad) enum Casilla { case vacia , X , O } enum ErrorJuego : Error { case casillaNoExiste } class Juego { var tablero : [[ Casilla ]] func getCasilla ( fila : Int , col : Int ) throws -> Casilla { ... } func setCasilla ( fila : Int , col : Int , valor : Casilla ) throws { ... } init ( filas : Int , cols : Int ) { ... } } \u00bfC\u00f3mo estar razonablemente seguros de que el c\u00f3digo de los m\u00e9todos es correcto?. Podemos comprobar varias cosas, por ejemplo Que cuando se inicializa el tablero todas las casillas est\u00e1n vac\u00edas Que las casillas se pueden obtener/fijar correctamente a un valor dado Que cuando se intenta obtener/fijar una casilla que no existe se produce un error Vamos a ver c\u00f3mo podemos automatizar todas estas comprobaciones en una suite de pruebas. Estructura de una suite de pruebas \u00b6 Podemos ver la estructura que tiene un conjunto o suite de pruebas en la plantilla de tests que crea Xcode. En el caso de nuestro ejemplo podr\u00eda ser algo como lo siguiente (suponiendo que el proyecto se llama TresEnRaya ) import XCTest @ testable import TresEnRaya class TresEnRayaTests : XCTestCase { override func setUp () { super . setUp () // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown () { // Put teardown code here. This method is called after the invocation of each test method in the class. super . tearDown () } donde hay que destacar: El import XCTest incluye las librer\u00edas de testing Con el import TresEnRaya evidentemente importamos el c\u00f3digo del proyecto. El @testable de delante cambia impl\u00edcitamente los modificadores de acceso de las propiedades de las clases del m\u00f3dulo, para que sean accesibles a los test La clase que contiene la suite debe heredar de XCTestCase Al igual que en frameworks de testing como JUnit hay un setUp() y tearDown que se ejecutan al inicio y al final de cada test , respectivamente. En el primero podemos colocar c\u00f3digo que inicialice los valores necesarios antes de cada test y en el segundo \"limpiar\" lo que haya hecho el test si es necesario. Las pruebas unitarias se deben implementar en m\u00e9todos que no devuelvan nada y cuyo nombre debe comenzar por test . Aserciones \u00b6 Las aserciones son las cosas que queremos comprobar que son ciertas. Si lo son, entonces el c\u00f3digo debe estar funcionando correctamente (al menos en el aspecto que estamos comprobando). Para hacer una aserci\u00f3n se usa la familia de m\u00e9todos XCTAssert . Decimos familia porque podemos hacer diferentes tipos de comprobaciones, por ejemplo: Comprobar que algo es cierto con XCTAssert o XCTAssertTrue : por ejemplo comprobar que justo tras inicializar el tres en raya, la posici\u00f3n (0,0) del tablero contiene la casilla vac\u00eda. Comprobar que algo es falso con XCTAssertFalse . Una alternativa a la comprobaci\u00f3n que dec\u00edamos antes ser\u00eda comprobar que no es una X ni tampoco una O. Comprobar que algo es igual a algo con XCTAssertEqual , por ejemplo que tras fijar una casilla a un valor al obtener la casilla obtenemos ese valor. Comprobar que una operaci\u00f3n genera un error con XCTAssertThrowsError : por ejemplo si inicializamos un tablero de 3x3 y luego intentamos acceder a la casilla (5,5). Esto son algunas variantes de XCTAssert aplicables a nuestro ejemplo, pero hay bastantes m\u00e1s (comprobar que algo es menor, mayor que algo, o que una operaci\u00f3n no lanza un error, o que algo es nil ,...). En todas las aserciones podemos poner como par\u00e1metro final un mensaje (Un String ) que aparecer\u00e1 si falla el test XCTAssertTrue ( 3 > 5 , \"Esta prueba va a fallar seguro\" ); Para m\u00e1s detalles sobre los distintos tipos de aserciones se recomienda consultar el apartado \"Test Assertions\" de la documentaci\u00f3n de XCTest Ejecutar las pruebas y ver el resultado \u00b6 En el Test navigator podemos pulsar el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece al pasar el rat\u00f3n por encima de cada test, para ejecutarlo individualmente o bien el que aparece en la suite completa para ejecutar todas sus pruebas. Se pondr\u00e1 en marcha el simulador de iOS con la aplicaci\u00f3n, ejecutar\u00e1 las pruebas y terminar\u00e1. En el test navigator y en el c\u00f3digo fuente de la suite aparecer\u00e1 un icono al lado de cada test indicando si ha pasado o no. Si no ha pasado aparecer\u00e1 adem\u00e1s un mensaje en el fuente indic\u00e1ndolo. Tambi\u00e9n podemos ver los mensajes de error en el Report Navigator .","title":"Testing en Xcode"},{"location":"s5/testing/#testing-en-xcode","text":"XCode incluye desde la versi\u00f3n 5 un framework de testing llamado XCTest . En el asistente de creaci\u00f3n de un proyecto, cuando elegimos el nombre del proyecto podemos marcar los correspondientes checkbox para crear los tests asociados al proyecto. Como veremos luego con m\u00e1s detalle tenemos dos tipos gen\u00e9ricos de tests: las pruebas unitarias ( unit tests ) y las pruebas de interfaz de usuario ( ui tests ). Si tenemos un proyecto ya creado sin test , podemos crearlos a posteriori con File > New > Target > iOS unit test bundle (o iOS UI test bundle ).","title":"Testing en Xcode"},{"location":"s5/testing/#el-navegador-de-tests","text":"Para moverse por los tests, lo m\u00e1s sencillo es usar el Test Navigator , que aparece en el \u00e1rea de Navegadores, a la izquierda de la pantalla. Su icono es el quinto por la izquierda, un rombo . En este navegador podemos ver todos los tests, ir al fuente clicando sobre el nombre del test y ejecutarlos pulsando sobre el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece a la derecha cuando pasamos el rat\u00f3n por encima.","title":"El navegador de Tests"},{"location":"s5/testing/#pruebas-unitarias","text":"En XCTest hay varios tipos distintos de pruebas unitarias: Tests de \u201cl\u00f3gica\u201d : lo que todo el mundo entiende habitualmente por pruebas unitarias, es decir pruebas en las que comprobamos si determinado m\u00e9todo funciona o no correctamente. Tests de tiempo de respuesta : en los que podemos ver estad\u00edsticas del tiempo que tarda en ejecutarse determinado bloque de c\u00f3digo. Podemos fijar un baseline de tiempo de modo que el test se considerar\u00e1 que no pasa si est\u00e1 por encima del baseline Tests as\u00edncronos : con c\u00f3digo as\u00edncrono podemos tener el problema de que Xcode no sepa cu\u00e1ndo ha acabado de ejecutarse nuestro c\u00f3digo y por tanto se puede dar por acabado el test. Por ejemplo si lanzamos una petici\u00f3n HTTP no podemos hacer las comprobaciones hasta que no llegue la respuesta. En este tipo de test podemos indicar a Xcode cu\u00e1ndo lo puede dar por terminado, o en caso de sobrepasar un timeout que lo de por fallido.","title":"Pruebas unitarias"},{"location":"s5/testing/#un-ejemplo","text":"XCTest es muy similar a otros frameworks de pruebas unitarias como JUnit , as\u00ed que es sencillo de usar para alguien que ya haya usado este \u00faltimo Por ejemplo, supongamos que tenemos un juego de tres en raya y aqu\u00ed tenemos parte del modelo (se omite el c\u00f3digo interno de los m\u00e9todos, para mayor brevedad) enum Casilla { case vacia , X , O } enum ErrorJuego : Error { case casillaNoExiste } class Juego { var tablero : [[ Casilla ]] func getCasilla ( fila : Int , col : Int ) throws -> Casilla { ... } func setCasilla ( fila : Int , col : Int , valor : Casilla ) throws { ... } init ( filas : Int , cols : Int ) { ... } } \u00bfC\u00f3mo estar razonablemente seguros de que el c\u00f3digo de los m\u00e9todos es correcto?. Podemos comprobar varias cosas, por ejemplo Que cuando se inicializa el tablero todas las casillas est\u00e1n vac\u00edas Que las casillas se pueden obtener/fijar correctamente a un valor dado Que cuando se intenta obtener/fijar una casilla que no existe se produce un error Vamos a ver c\u00f3mo podemos automatizar todas estas comprobaciones en una suite de pruebas.","title":"Un ejemplo"},{"location":"s5/testing/#estructura-de-una-suite-de-pruebas","text":"Podemos ver la estructura que tiene un conjunto o suite de pruebas en la plantilla de tests que crea Xcode. En el caso de nuestro ejemplo podr\u00eda ser algo como lo siguiente (suponiendo que el proyecto se llama TresEnRaya ) import XCTest @ testable import TresEnRaya class TresEnRayaTests : XCTestCase { override func setUp () { super . setUp () // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown () { // Put teardown code here. This method is called after the invocation of each test method in the class. super . tearDown () } donde hay que destacar: El import XCTest incluye las librer\u00edas de testing Con el import TresEnRaya evidentemente importamos el c\u00f3digo del proyecto. El @testable de delante cambia impl\u00edcitamente los modificadores de acceso de las propiedades de las clases del m\u00f3dulo, para que sean accesibles a los test La clase que contiene la suite debe heredar de XCTestCase Al igual que en frameworks de testing como JUnit hay un setUp() y tearDown que se ejecutan al inicio y al final de cada test , respectivamente. En el primero podemos colocar c\u00f3digo que inicialice los valores necesarios antes de cada test y en el segundo \"limpiar\" lo que haya hecho el test si es necesario. Las pruebas unitarias se deben implementar en m\u00e9todos que no devuelvan nada y cuyo nombre debe comenzar por test .","title":"Estructura de una suite de pruebas"},{"location":"s5/testing/#aserciones","text":"Las aserciones son las cosas que queremos comprobar que son ciertas. Si lo son, entonces el c\u00f3digo debe estar funcionando correctamente (al menos en el aspecto que estamos comprobando). Para hacer una aserci\u00f3n se usa la familia de m\u00e9todos XCTAssert . Decimos familia porque podemos hacer diferentes tipos de comprobaciones, por ejemplo: Comprobar que algo es cierto con XCTAssert o XCTAssertTrue : por ejemplo comprobar que justo tras inicializar el tres en raya, la posici\u00f3n (0,0) del tablero contiene la casilla vac\u00eda. Comprobar que algo es falso con XCTAssertFalse . Una alternativa a la comprobaci\u00f3n que dec\u00edamos antes ser\u00eda comprobar que no es una X ni tampoco una O. Comprobar que algo es igual a algo con XCTAssertEqual , por ejemplo que tras fijar una casilla a un valor al obtener la casilla obtenemos ese valor. Comprobar que una operaci\u00f3n genera un error con XCTAssertThrowsError : por ejemplo si inicializamos un tablero de 3x3 y luego intentamos acceder a la casilla (5,5). Esto son algunas variantes de XCTAssert aplicables a nuestro ejemplo, pero hay bastantes m\u00e1s (comprobar que algo es menor, mayor que algo, o que una operaci\u00f3n no lanza un error, o que algo es nil ,...). En todas las aserciones podemos poner como par\u00e1metro final un mensaje (Un String ) que aparecer\u00e1 si falla el test XCTAssertTrue ( 3 > 5 , \"Esta prueba va a fallar seguro\" ); Para m\u00e1s detalles sobre los distintos tipos de aserciones se recomienda consultar el apartado \"Test Assertions\" de la documentaci\u00f3n de XCTest","title":"Aserciones"},{"location":"s5/testing/#ejecutar-las-pruebas-y-ver-el-resultado","text":"En el Test navigator podemos pulsar el peque\u00f1o bot\u00f3n de \u201cplay\u201d que aparece al pasar el rat\u00f3n por encima de cada test, para ejecutarlo individualmente o bien el que aparece en la suite completa para ejecutar todas sus pruebas. Se pondr\u00e1 en marcha el simulador de iOS con la aplicaci\u00f3n, ejecutar\u00e1 las pruebas y terminar\u00e1. En el test navigator y en el c\u00f3digo fuente de la suite aparecer\u00e1 un icono al lado de cada test indicando si ha pasado o no. Si no ha pasado aparecer\u00e1 adem\u00e1s un mensaje en el fuente indic\u00e1ndolo. Tambi\u00e9n podemos ver los mensajes de error en el Report Navigator .","title":"Ejecutar las pruebas y ver el resultado"}]}